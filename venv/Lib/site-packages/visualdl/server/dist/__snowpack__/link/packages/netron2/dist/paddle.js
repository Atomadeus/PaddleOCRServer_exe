var paddle=paddle||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");paddle.ModelFactory=class{match(t){const e=t.identifier,s=e.split(".").pop().toLowerCase();return"__model__"===e||"paddle"===s||"pdmodel"===s}open(t,e){return e.require("./paddle-proto").then((()=>{let s=null;const a=t.identifier;try{paddle.proto=protobuf.get("paddle").paddle.framework.proto;const e=protobuf.Reader.create(t.buffer);s=paddle.proto.ProgramDesc.decode(e)}catch(t){throw new paddle.Error("File format is not paddle.ProgramDesc ("+t.message+") in '"+a+"'.")}return paddle.Metadata.open(e).then((a=>{try{const e=new Set;for(const t of s.blocks){const s=new Set;for(const e of t.vars)e.persistable&&e.type&&e.type.type!=paddle.proto.VarType.Type.FETCH_LIST&&e.type.type!=paddle.proto.VarType.Type.FEED_MINIBATCH&&s.add(e.name);for(const a of t.ops)for(const t of a.inputs)for(const a of t.arguments)s.has(a)&&e.add(a)}const r=Array.from(e).map((e=>t.request(e,null)));return Promise.all(r).then((t=>{const r=new Map,n=Array.from(e);for(let e=0;e<n.length;e++)r.set(n[e],t[e]);return new paddle.Model(a,s,r)})).catch((t=>new paddle.Model(a,s,new Map)))}catch(t){throw e.exception(t,!1),new paddle.Error(t.message)}}))}))}},paddle.Model=class{constructor(t,e,s){this._graphs=e.blocks.map((e=>new paddle.Graph(t,e,s)))}get graphs(){return this._graphs}get format(){return"PaddlePaddle"}},paddle.Graph=class{constructor(t,e,s){this._nodes=[],this._inputs=[],this._outputs=[],this._name=`blocks[${e.idx}]`;const a=new Map;for(const t of e.vars){const e=t.type&&t.type.type&&t.type.lod_tensor&&t.type.lod_tensor.tensor?new paddle.TensorType(t.type.lod_tensor.tensor):null,r=t.persistable&&t.type&&t.type.type!=paddle.proto.VarType.Type.FETCH_LIST&&t.type.type!=paddle.proto.VarType.Type.FEED_MINIBATCH?new paddle.Tensor(e,s.get(t.name)):null;a.set(t.name,new paddle.Argument(t.name,e,r))}const r={};for(let t=0;t<e.ops.length;t++){for(const s of e.ops[t].inputs)s.arguments=s.arguments.map((t=>r[t]?r[t]:t));for(const s of e.ops[t].outputs)s.arguments=s.arguments.map((e=>{if(r[e]){const s=e+"\n"+t.toString();return r[e]=s,s}return r[e]=e,e}))}for(const t of e.ops){for(const e of t.inputs)for(const t of e.arguments){const e=t;a.has(e)||a.set(e,new paddle.Argument(e,null,null))}for(const e of t.outputs)for(const t of e.arguments){const e=t;a.has(e)||a.set(e,new paddle.Argument(e,null,null))}}let n=null,i=null;for(const s of e.ops)if("feed"==s.type){const t=s.attrs.filter((t=>"col"==t.name))[0].i.toString();this._inputs.push(new paddle.Parameter(t,s.outputs[0].arguments.map((t=>a.get(t)))))}else if("fetch"==s.type){const t=s.attrs.filter((t=>"col"==t.name))[0].i.toString();this._outputs.push(new paddle.Parameter(t,s.inputs[0].arguments.map((t=>a.get(t)))))}else{const e=new paddle.Node(t,s,a);1==s.inputs.length&&1==s.inputs[0].arguments.length&&s.outputs.length>=1&&1==s.outputs[0].arguments.length&&s.inputs[0].arguments[0].split("\n").shift()==s.outputs[0].arguments[0].split("\n").shift()&&n&&i==s.inputs[0].arguments[0].split("\n").shift()?n.chain.push(e):(this._nodes.push(e),n=null,i=null,1==s.outputs.length&&1==s.outputs[0].arguments.length&&(n=e,i=s.outputs[0].arguments[0].split("\n").shift()))}}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},paddle.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},paddle.Argument=class{constructor(t,e,s){if("string"!=typeof t)throw new paddle.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=s||null}get name(){return this._name}get type(){return this._type?this._type:this._initializer?this._initializer.type:null}get initializer(){return this._initializer}},paddle.Node=class{constructor(t,e,s){this._metadata=t,this._type=e.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];for(const s of e.attrs){const e=t.attribute(this._type,this._name);this._attributes.push(new paddle.Attribute(e,s))}for(const t of e.inputs)t.arguments.length>0&&this._inputs.push(new paddle.Parameter(t.parameter,t.arguments.map((t=>s.get(t)))));for(const t of e.outputs)t.arguments.length>0&&this._outputs.push(new paddle.Parameter(t.parameter,t.arguments.map((t=>s.get(t)))));this._update(this._inputs,"X"),this._update(this._inputs,"Input"),this._update(this._outputs,"Y"),this._update(this._outputs,"Out")}get type(){return this._type}get name(){return""}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}_update(t,e){let s=null;for(let a=0;a<t.length;a++)if(t[a].name==e){s=t[a],t.splice(a,1);break}s&&t.splice(0,0,s)}},paddle.Attribute=class{constructor(t,e){switch(this._name=e.name,this._value="?",e.type){case paddle.proto.AttrType.STRING:this._type="string",this._value=e.s;break;case paddle.proto.AttrType.STRINGS:this._type="string[]",this._value=e.strings;break;case paddle.proto.AttrType.BOOLEAN:this._type="boolean",this._value=e.b;break;case paddle.proto.AttrType.BOOLEANS:this._type="boolean[]",this._value=e.bools;break;case paddle.proto.AttrType.FLOAT:this._type="float32",this._value=e.f;break;case paddle.proto.AttrType.FLOATS:this._type="float[]",this._value=e.floats;break;case paddle.proto.AttrType.INT:this._type="int32",this._value=e.i;break;case paddle.proto.AttrType.INTS:this._type="int32[]",this._value=e.ints;break;case paddle.proto.AttrType.LONG:this._type="int64";break;case paddle.proto.AttrType.LONGS:this._type="int64[]"}switch(this._name){case"use_mkldnn":case"use_cudnn":case"op_callstack":case"op_role":case"op_role_var":case"op_namescope":case"is_test":this._visible=!1}if(t&&Object.prototype.hasOwnProperty.call(t,"default")){const e=t.default,s=this._value;(e==s||Array.isArray(s)&&Array.isArray(e)&&s.length==e.length&&s.every(((t,s)=>t==e[s])))&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},paddle.Tensor=class{constructor(t,e){if(this._type=t,e&&e.length>20&&e.slice(0,16).every((t=>0===t))){const t=new DataView(e.buffer,e.byteOffset,e.byteLength).getUint32(16,!0);this._data=e.slice(20+t)}}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return paddle.Tensor._stringify(e,"","    ")}_context(){const t={index:0,count:0,state:null};if(!this._data)return t.state="Tensor data is empty.",t;if(!this._type)return t.state="Tensor has no data type.",t;switch(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.view=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dataType){case"float32":case"int32":case"int64":break;default:t.state="Tensor data type '"+t.dataType+"' is not implemented."}return t}_decode(t,e){const s=0!==t.shape.length?t.shape:[1],a=[],r=s[e];if(e==s.length-1)for(let e=0;e<r;e++){if(t.count>t.limit)return a.push("..."),a;switch(t.dataType){case"float32":a.push(t.view.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"int32":a.push(t.view.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":a.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++}}else for(let s=0;s<r;s++){if(t.count>t.limit)return a.push("..."),a;a.push(this._decode(t,e+1))}return 0==t.shape.length?a[0]:a}static _stringify(t,e,s){if(Array.isArray(t)){const a=[];a.push(e+"[");const r=t.map((t=>paddle.Tensor._stringify(t,e+s,s)));return r.length>0&&a.push(r.join(",\n")),a.push(e+"]"),a.join("\n")}return"string"==typeof t?e+t:t==1/0?e+"Infinity":t==-1/0?e+"-Infinity":isNaN(t)?e+"NaN":e+t.toString()}},paddle.TensorType=class{constructor(t){switch(t.data_type){case paddle.proto.VarType.Type.INT32:this._dataType="int32";break;case paddle.proto.VarType.Type.INT64:this._dataType="int64";break;case paddle.proto.VarType.Type.FP32:this._dataType="float32";break;case paddle.proto.VarType.Type.FP64:this._dataType="float64";break;default:this._dataType="?"}this._shape=new paddle.TensorShape(t.dims)}get dataType(){return this._dataType}get shape(){return this._shape}get denotation(){return this._denotation}toString(){return this.dataType+this._shape.toString()}},paddle.TensorShape=class{constructor(t){t=t.map((t=>t.toNumber())),this._dimensions=t.map((t=>-1!=t?t:"?"))}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},paddle.Metadata=class{static open(t){return paddle.Metadata._metadata?Promise.resolve(paddle.Metadata._metadata):t.request(null,"paddle-metadata.json","utf-8").then((t=>(paddle.Metadata._metadata=new paddle.Metadata(t),paddle.Metadata._metadata))).catch((()=>(paddle.Metadata._metadata=new paddle.Metadata(null),paddle.Metadata._metadata)))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const t of e)t.schema.name=t.name,this._map[t.name]=t.schema}}type(t){return this._map[t]||null}attribute(t,e){let s=this._attributeCache[t];if(!s){s={};const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const t of e.attributes)s[t.name]=t;this._attributeCache[t]=s}return s[e]||null}},paddle.Error=class extends Error{constructor(t){super(t),this.name="Error loading PaddlePaddle model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=paddle.ModelFactory);