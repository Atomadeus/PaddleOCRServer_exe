var coreml=coreml||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");coreml.ModelFactory=class{match(e){return"mlmodel"==e.identifier.split(".").pop().toLowerCase()}open(e,t){return t.require("./coreml-proto").then((()=>{const i=e.identifier;let r=null;try{coreml.proto=protobuf.get("coreml").CoreML.Specification;const t=protobuf.Reader.create(e.buffer);r=coreml.proto.Model.decode(t)}catch(e){throw new coreml.Error("File format is not coreml.Model ("+e.message+") in '"+i+"'.")}return coreml.Metadata.open(t).then((e=>{try{return new coreml.Model(e,r)}catch(e){t.exception(e,!1);const r=e&&e.message?e.message:e.toString();throw new coreml.Error(r.replace(/\.$/,"")+" in '"+i+"'.")}}))}))}},coreml.Model=class{constructor(e,t){if(this._specificationVersion=t.specificationVersion,this._graphs=[new coreml.Graph(e,t)],t.description&&t.description.metadata){const i=t.description.metadata;i.versionString&&(this._version=i.versionString),i.author&&(this._author=i.author),i.shortDescription&&(this._description=i.shortDescription),i.license&&(this._license=i.license),e.userDefined&&Object.keys(i.userDefined).length}}get format(){return"Core ML v"+this._specificationVersion.toString()}get version(){return this._version||null}get description(){return this._description||null}get author(){return this._author||null}get license(){return this._license||null}get graphs(){return this._graphs}},coreml.Graph=class{constructor(e,t){this._metadata=e,this._description=t.description,this._groups=!1,this._inputs=[],this._outputs=[],this._nodes=[],this._description&&(this._inputs=this._description.input.map((e=>{const t=new coreml.Argument(e.name,coreml.Graph._formatFeatureType(e.type),e.shortDescription,null);return new coreml.Parameter(e.name,!0,[t])})),this._outputs=this._description.output.map((e=>{const t=new coreml.Argument(e.name,coreml.Graph._formatFeatureType(e.type),e.shortDescription,null);return new coreml.Parameter(e.name,!0,[t])}))),this._type=this._loadModel(t,{},"")}get name(){return""}get type(){return this._type}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}get groups(){return this._groups}_updateOutput(e,t){for(const i of this._nodes)for(const r of i.outputs)for(const i of r.arguments)i.name===e&&(i.name=t);return t}_updateClassifierOutput(e,t){let i=t.labelProbabilityLayerName;if(!i&&this._nodes.length>0){const e=this._nodes.slice(-1).pop();e&&1==e.outputs.length&&1==e.outputs[0].arguments.length&&(i=e.outputs[0].arguments[0].name)}let r=this._description.predictedFeatureName,s=this._description.predictedProbabilitiesName;if((r||s)&&i&&t.ClassLabels){r=r||"?",s=s||"?";const e=this._updateOutput(i,i+":labelProbabilityLayerName"),a=t.ClassLabels;this._nodes.push(new coreml.Node(this._metadata,this._group,a,null,"",t[a],[e],[s,r]))}}_updatePreprocessing(e,t,i){if(i&&i.length>0){const r=this._description.input[0].name,s=[];for(const e of this._nodes)e.inputs.some((e=>e.arguments.some((e=>e.name==r))))&&s.push(e);let a=r,n=0;for(const s of i){const i=s.featureName?s.featureName:a;a=r+":"+n.toString(),this._createNode(e,t,s.preprocessor,null,"",s[s.preprocessor],[i],[a]),n++}for(const e of s)for(const t of e.inputs)for(const e of t.arguments)e.name===r&&(e.name=a)}}_loadModel(e,t,i){this._groups=this._groups|i.length>0;const r=e&&e.description&&e.description.metadata&&e.description.metadata.shortDescription?e.description.metadata.shortDescription:"";switch(e.Type){case"neuralNetworkClassifier":{const s=e.neuralNetworkClassifier;for(const e of s.layers)this._createNode(t,i,e.layer,e.name,r,e[e.layer],e.input,e.output);return this._updateClassifierOutput(i,s),this._updatePreprocessing(t,i,s.preprocessing),"Neural Network Classifier"}case"neuralNetwork":{const s=e.neuralNetwork;for(const e of s.layers)this._createNode(t,i,e.layer,e.name,r,e[e.layer],e.input,e.output);return this._updatePreprocessing(t,i,s.preprocessing),"Neural Network"}case"neuralNetworkRegressor":{const s=e.neuralNetworkRegressor;for(const e of s.layers)this._createNode(t,i,e.layer,e.name,r,e[e.layer],e.input,e.output);return this._updatePreprocessing(t,i,s),"Neural Network Regressor"}case"pipeline":for(let r=0;r<e.pipeline.models.length;r++)this._loadModel(e.pipeline.models[r],t,(i?i+"/":"")+"pipeline["+r.toString()+"]");return"Pipeline";case"pipelineClassifier":for(let r=0;r<e.pipelineClassifier.pipeline.models.length;r++)this._loadModel(e.pipelineClassifier.pipeline.models[r],t,(i?i+"/":"")+"pipelineClassifier["+r.toString()+"]");return"Pipeline Classifier";case"pipelineRegressor":for(let r=0;r<e.pipelineRegressor.pipeline.models.length;r++)this._loadModel(e.pipelineRegressor.pipeline.models[r],t,(i?i+"/":"")+"pipelineRegressor["+r.toString()+"]");return"Pipeline Regressor";case"glmClassifier":return this._createNode(t,i,"glmClassifier",null,r,{classEncoding:e.glmClassifier.classEncoding,offset:e.glmClassifier.offset,weights:e.glmClassifier.weights},[e.description.input[0].name],[e.description.predictedProbabilitiesName]),this._updateClassifierOutput(i,e.glmClassifier),"Generalized Linear Classifier";case"glmRegressor":return this._createNode(t,i,"glmRegressor",null,r,e.glmRegressor,[e.description.input[0].name],[e.description.output[0].name]),"Generalized Linear Regressor";case"dictVectorizer":return this._createNode(t,i,"dictVectorizer",null,r,e.dictVectorizer,[e.description.input[0].name],[e.description.output[0].name]),"Dictionary Vectorizer";case"featureVectorizer":return this._createNode(t,i,"featureVectorizer",null,r,e.featureVectorizer,coreml.Graph._formatFeatureDescriptionList(e.description.input),[e.description.output[0].name]),"Feature Vectorizer";case"treeEnsembleClassifier":return this._createNode(t,i,"treeEnsembleClassifier",null,r,e.treeEnsembleClassifier.treeEnsemble,[e.description.input[0].name],[e.description.output[0].name]),this._updateClassifierOutput(i,e.treeEnsembleClassifier),"Tree Ensemble Classifier";case"treeEnsembleRegressor":return this._createNode(t,i,"treeEnsembleRegressor",null,r,e.treeEnsembleRegressor.treeEnsemble,[e.description.input[0].name],[e.description.output[0].name]),"Tree Ensemble Regressor";case"supportVectorClassifier":return this._createNode(t,i,"supportVectorClassifier",null,r,{coefficients:e.supportVectorClassifier.coefficients,denseSupportVectors:e.supportVectorClassifier.denseSupportVectors,kernel:e.supportVectorClassifier.kernel,numberOfSupportVectorsPerClass:e.supportVectorClassifier.numberOfSupportVectorsPerClass,probA:e.supportVectorClassifier.probA,probB:e.supportVectorClassifier.probB,rho:e.supportVectorClassifier.rho,supportVectors:e.supportVectorClassifier.supportVectors},[e.description.input[0].name],[e.description.output[0].name]),this._updateClassifierOutput(i,e.supportVectorClassifier),"Support Vector Classifier";case"supportVectorRegressor":return this._createNode(t,i,"supportVectorRegressor",null,r,{coefficients:e.supportVectorRegressor.coefficients,kernel:e.supportVectorRegressor.kernel,rho:e.supportVectorRegressor.rho,supportVectors:e.supportVectorRegressor.supportVectors},[e.description.input[0].name],[e.description.output[0].name]),"Support Vector Regressor";case"arrayFeatureExtractor":return this._createNode(t,i,"arrayFeatureExtractor",null,r,{extractIndex:e.arrayFeatureExtractor.extractIndex},[e.description.input[0].name],[e.description.output[0].name]),"Array Feature Extractor";case"oneHotEncoder":{const s=e.oneHotEncoder.CategoryType,a={outputSparse:e.oneHotEncoder.outputSparse};return a[s]=e.oneHotEncoder[s],this._createNode(t,i,"oneHotEncoder",null,r,a,[e.description.input[0].name],[e.description.output[0].name]),"One Hot Encoder"}case"imputer":{const s=e.imputer.ImputedValue,a=e.imputer.ReplaceValue,n={};return n[s]=e.imputer[s],n[a]=e.imputer[a],this._createNode(t,i,"oneHotEncoder",null,r,n,[e.description.input[0].name],[e.description.output[0].name]),"Imputer"}case"normalizer":return this._createNode(t,i,"normalizer",null,r,e.normalizer,[e.description.input[0].name],[e.description.output[0].name]),"Normalizer";case"wordTagger":return this._createNode(t,i,"wordTagger",null,r,e.wordTagger,[e.description.input[0].name],[e.wordTagger.tokensOutputFeatureName,e.wordTagger.tokenTagsOutputFeatureName,e.wordTagger.tokenLocationsOutputFeatureName,e.wordTagger.tokenLengthsOutputFeatureName]),"Word Tagger";case"textClassifier":return this._createNode(t,i,"textClassifier",null,r,e.textClassifier,[e.description.input[0].name],[e.description.output[0].name]),"Text Classifier";case"nonMaximumSuppression":{const s={pickTop:e.nonMaximumSuppression.pickTop,stringClassLabels:e.nonMaximumSuppression.stringClassLabels,iouThreshold:e.nonMaximumSuppression.iouThreshold,confidenceThreshold:e.nonMaximumSuppression.confidenceThreshold};return this._createNode(t,i,"nonMaximumSuppression",null,r,s,[e.nonMaximumSuppression.confidenceInputFeatureName,e.nonMaximumSuppression.coordinatesInputFeatureName,e.nonMaximumSuppression.iouThresholdInputFeatureName,e.nonMaximumSuppression.confidenceThresholdInputFeatureName],[e.nonMaximumSuppression.confidenceOutputFeatureName,e.nonMaximumSuppression.coordinatesOutputFeatureName]),"Non Maximum Suppression"}case"visionFeaturePrint":{const s={scene:e.visionFeaturePrint.scene};return this._createNode(t,i,"visionFeaturePrint",null,r,s,[e.description.input[0].name],[e.description.output[0].name]),"Vision Feature Print"}case"soundAnalysisPreprocessing":return this._createNode(t,i,"soundAnalysisPreprocessing",null,r,e.soundAnalysisPreprocessing,[e.description.input[0].name],[e.description.output[0].name]),"Sound Analysis Preprocessing";case"kNearestNeighborsClassifier":return this._createNode(t,i,"kNearestNeighborsClassifier",null,r,e.kNearestNeighborsClassifier,[e.description.input[0].name],[e.description.output[0].name]),this._updateClassifierOutput(i,e.kNearestNeighborsClassifier),"Nearest Neighbors Classifier";case"itemSimilarityRecommender":return this._createNode(t,i,"itemSimilarityRecommender",null,r,{itemStringIds:e.itemSimilarityRecommender.itemStringIds.vector,itemItemSimilarities:e.itemSimilarityRecommender.itemItemSimilarities},e.description.input.map((e=>e.name)),e.description.output.map((e=>e.name))),"Item Similarity Recommender";case"linkedModel":return this._createNode(t,i,"linkedModel",null,r,e.linkedModel.linkedModelFile,[e.description.input[0].name],[e.description.output[0].name]),"Linked Model";case"customModel":return this._createNode(t,i,"customModel",null,r,{className:e.customModel.className,parameters:e.customModel.parameters},[e.description.input[0].name],[e.description.output[0].name]),"customModel"}throw new coreml.Error("Unknown model type '"+JSON.stringify(Object.keys(e))+"'.")}_createNode(e,t,i,r,s,a,n,o){n=n.map((t=>e[t]?e[t].argument:t)),o=o.map((t=>{if(e[t]){e[t].counter++;const i=t+"\n"+e[t].counter.toString();return e[t].argument=i,i}return e[t]={argument:t,counter:0},t}));const u=new coreml.Node(this._metadata,t,i,r,s,a,n,o);return this._nodes.push(u),u}static _formatFeatureType(e){let t="?";if(e){switch(e.Type){case"multiArrayType":{let i=new coreml.TensorShape([]);e.multiArrayType.shape&&e.multiArrayType.shape.length>0&&(i=new coreml.TensorShape(e.multiArrayType.shape));let r="?";switch(e.multiArrayType.dataType){case coreml.proto.ArrayFeatureType.ArrayDataType.FLOAT32:r="float32";break;case coreml.proto.ArrayFeatureType.ArrayDataType.INT32:r="int32";break;case coreml.proto.ArrayFeatureType.ArrayDataType.DOUBLE:r="float64"}t=new coreml.TensorType(r,i);break}case"stringType":t=new coreml.TensorType("string");break;case"doubleType":t=new coreml.TensorType("float64");break;case"int64Type":t=new coreml.TensorType("int64");break;case"dictionaryType":t=new coreml.MapType(e.dictionaryType.KeyType.replace("KeyType",""),"float64");break;case"imageType":t=new coreml.ImageType(e.imageType.colorSpace,e.imageType.width,e.imageType.height)}e.isOptional&&(t=new coreml.OptionalType(t))}return t}static _formatFeatureDescriptionList(e){return e.map((e=>e.name))}},coreml.Parameter=class{constructor(e,t,i){this._name=e,this._visible=t,this._arguments=i}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},coreml.Argument=class{constructor(e,t,i,r){if("string"!=typeof e)throw new coreml.Error("Invalid argument identifier '"+JSON.stringify(e)+"'.");this._name=e,this._type=t,this._description=i||null,this._initializer=r||null}get name(){return this._name}set name(e){this._name=e}get type(){return this._initializer?this._initializer.type:this._type}get description(){return this._description}get quantization(){return this._initializer?this._initializer.quantization:null}get initializer(){return this._initializer}},coreml.Node=class{constructor(e,t,i,r,s,a,n,o){if(this._metadata=e,t&&(this._group=t),!i)throw new Error("Undefined node type.");this._type=i,this._name=r||"",this._description=s||"",this._attributes=[];const u=[];if(a){const t=this._initialize(a,u);for(const i of Object.keys(a))if(!t[i]){const t=e.attribute(this.type,i);this._attributes.push(new coreml.Attribute(t,i,a[i]))}}this._inputs=this._metadata.getInputs(this._type,n).map((e=>new coreml.Parameter(e.name,!0,e.arguments.map((e=>new coreml.Argument(e.name,e.type,null,null)))))),this._inputs=this._inputs.concat(u),this._outputs=o.map(((e,t)=>{const i=this._metadata.getOutputName(this._type,t);return new coreml.Parameter(i,!0,[new coreml.Argument(e,null,null,null)])}))}get type(){return this._type}get name(){return this._name}get description(){return this._description}get metadata(){return this._metadata.type(this.type)}get group(){return this._group?this._group:null}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}_initialize(e,t){switch(this._type){case"convolution":{const i=[e.outputChannels,e.kernelChannels,e.kernelSize[0],e.kernelSize[1]];return e.isDeconvolution&&(i[0]=e.kernelChannels,i[1]=Math.floor(e.outputChannels/(0!=e.nGroups?e.nGroups:1))),this._initializer(t,"Weights","weights",i,e.weights),e.hasBias&&this._initializer(t,"Weights","bias",[e.outputChannels],e.bias),{weights:!0,bias:e.hasBias}}case"innerProduct":return this._initializer(t,"Weights","weights",[e.outputChannels,e.inputChannels],e.weights),e.hasBias&&this._initializer(t,"Weights","bias",[e.outputChannels],e.bias),{weights:!0,bias:e.hasBias};case"batchnorm":return this._initializer(t,"Weights","gamma",[e.channels],e.gamma),this._initializer(t,"Weights","beta",[e.channels],e.beta),e.mean&&this._initializer(t,"Weights","mean",[e.channels],e.mean),e.variance&&this._initializer(t,"Weights","variance",[e.channels],e.variance),{gamma:!0,beta:!0,mean:!0,variance:!0};case"embedding":return this._initializer(t,"Weights","weights",[e.inputDim,e.outputChannels],e.weights),{weights:!0};case"loadConstant":return this._initializer(t,"Weights","data",e.shape,e.data),{data:!0};case"scale":return this._initializer(t,"Weights","scale",e.shapeScale,e.scale),e.hasBias&&this._initializer(t,"Weights","bias",e.shapeBias,e.bias),{scale:!0,bias:e.hasBias};case"bias":return this._initializer(t,"Weights","bias",e.shape,e.bias),{bias:!0};case"simpleRecurrent":return this._initializer(t,"Weights","weights",[e.outputVectorSize,e.inputVectorSize],e.weightMatrix),this._initializer(t,"Weights","recurrent",[e.outputVectorSize,e.inputVectorSize],e.recursionMatrix),e.hasBiasVectors&&this._initializer(t,"Weights","bias",[e.outputVectorSize],e.biasVector),{weightMatrix:!0,recursionMatrix:!0,biasVector:e.hasBiasVectors};case"gru":{const i=[e.outputVectorSize,e.outputVectorSize],r=[e.outputVectorSize,e.inputVectorSize],s=[e.outputVectorSize];return this._initializer(t,"Weights","updateGateWeightMatrix",r,e.updateGateWeightMatrix),this._initializer(t,"Weights","resetGateWeightMatrix",r,e.resetGateWeightMatrix),this._initializer(t,"Weights","outputGateWeightMatrix",r,e.outputGateWeightMatrix),this._initializer(t,"Weights","updateGateRecursionMatrix",i,e.updateGateRecursionMatrix),this._initializer(t,"Weights","resetGateRecursionMatrix",i,e.resetGateRecursionMatrix),this._initializer(t,"Weights","outputGateRecursionMatrix",i,e.outputGateRecursionMatrix),e.hasBiasVectors&&(this._initializer(t,"Weights","updateGateBiasVector",s,e.updateGateBiasVector),this._initializer(t,"Weights","resetGateBiasVector",s,e.resetGateBiasVector),this._initializer(t,"Weights","outputGateBiasVector",s,e.outputGateBiasVector)),{updateGateWeightMatrix:!0,resetGateWeightMatrix:!0,outputGateWeightMatrix:!0,updateGateRecursionMatrix:!0,resetGateRecursionMatrix:!0,outputGateRecursionMatrix:!0,updateGateBiasVector:e.hasBiasVectors,resetGateBiasVector:e.hasBiasVectors,outputGateBiasVector:e.hasBiasVectors}}case"uniDirectionalLSTM":case"biDirectionalLSTM":{const i="uniDirectionalLSTM"==this._type?1:2,r=[e.outputVectorSize,e.inputVectorSize],s=[e.outputVectorSize];for(let a=0;a<i;a++){const n=1==i?e.weightParams:e.weightParams[a],o=0==a?"":"_rev";this._initializer(t,"Weights","inputGateWeightMatrix"+o,r,n.inputGateWeightMatrix),this._initializer(t,"Weights","forgetGateWeightMatrix"+o,r,n.forgetGateWeightMatrix),this._initializer(t,"Weights","blockInputWeightMatrix"+o,r,n.blockInputWeightMatrix),this._initializer(t,"Weights","outputGateWeightMatrix"+o,r,n.outputGateWeightMatrix),this._initializer(t,"Weights","inputGateRecursionMatrix"+o,r,n.inputGateRecursionMatrix),this._initializer(t,"Weights","forgetGateRecursionMatrix"+o,r,n.forgetGateRecursionMatrix),this._initializer(t,"Weights","blockInputRecursionMatrix"+o,r,n.blockInputRecursionMatrix),this._initializer(t,"Weights","outputGateRecursionMatrix"+o,r,n.outputGateRecursionMatrix),e.params.hasBiasVectors&&(this._initializer(t,"Weights","inputGateBiasVector"+o,s,n.inputGateBiasVector),this._initializer(t,"Weights","forgetGateBiasVector"+o,s,n.forgetGateBiasVector),this._initializer(t,"Weights","blockInputBiasVector"+o,s,n.blockInputBiasVector),this._initializer(t,"Weights","outputGateBiasVector"+o,s,n.outputGateBiasVector)),e.params.hasPeepholeVectors&&(this._initializer(t,"Weights","inputGatePeepholeVector"+o,s,n.inputGatePeepholeVector),this._initializer(t,"Weights","forgetGatePeepholeVector"+o,s,n.forgetGatePeepholeVector),this._initializer(t,"Weights","outputGatePeepholeVector"+o,s,n.outputGatePeepholeVector))}return{weightParams:!0}}case"dictVectorizer":return e.stringToIndex=this._convertVector(e.stringToIndex),{};case"wordTagger":return e.modelParameterData=Array.from(e.modelParameterData),e.stringTags=this._convertVector(e.stringTags),{tokensOutputFeatureName:!0,tokenTagsOutputFeatureName:!0,tokenLengthsOutputFeatureName:!0,tokenLocationsOutputFeatureName:!0};case"textClassifier":return e.modelParameterData=Array.from(e.modelParameterData),e.stringClassLabels=this._convertVector(e.stringClassLabels),{};case"nonMaximumSuppression":return e.stringClassLabels=this._convertVector(e.stringClassLabels),{}}return{}}_convertVector(e){return e&&1==Object.keys(e).length&&e.vector?e.vector:e}_initializer(e,t,i,r,s){const a=new coreml.Tensor(t,i,r,s),n=new coreml.Argument("",null,null,a);let o=!0;const u=this._metadata.getInputSchema(this._type,i);u&&Object.prototype.hasOwnProperty.call(u,"visible")&&!u.visible&&(o=!1),e.push(new coreml.Parameter(i,o,[n]))}},coreml.Attribute=class{constructor(e,t,i){if(this._name=t,this._value=i,e){if(e.type&&(this._type=e.type),this._type&&coreml.proto){let e=coreml.proto;const t=this._type.split(".");for(;e&&t.length>0;)e=e[t.shift()];e&&e[this._value]&&(this._value=e[this.value])}Object.prototype.hasOwnProperty.call(e,"visible")&&!e.visible?this._visible=!1:Object.prototype.hasOwnProperty.call(e,"default")&&(Array.isArray(i)&&(i=i.map((e=>e&&long.Long.isLong(e)?e.toNumber():e))),JSON.stringify(e.default)==JSON.stringify(i)&&(this._visible=!1))}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},coreml.Tensor=class{constructor(e,t,i,r){this._kind=e,this._name=t,this._data=null;let s="?";r&&(r.floatValue&&r.floatValue.length>0?(this._data=r.floatValue,s="float32"):r.float16Value&&r.float16Value.length>0?(this._data=r.float16Value,s="float16"):r.rawValue&&r.rawValue.length>0&&(r.quantization?(this._data=r.rawValue,s="uint"+r.quantization.numberOfBits.toString()):i=[]),this._quantization=r.quantization||null),this._type=new coreml.TensorType(s,new coreml.TensorShape(i))}get name(){return this._name}get kind(){return this._kind}get type(){return this._type}get quantization(){if(this._quantization){if(this._quantization.lookupTableQuantization&&this._quantization.lookupTableQuantization.floatValue&&this._quantization.lookupTableQuantization.floatValue.length>0){const e=[];for(const t of Object.keys(this._quantization.lookupTableQuantization.floatValue))e.push(t.toString()+" = "+this._quantization.lookupTableQuantization.floatValue[t].toString());return e.join("; ")}return"?"}return null}get state(){return this._context().state}get value(){const e=this._context();return e.state?null:(e.limit=Number.MAX_SAFE_INTEGER,this._decode(e,0))}toString(){const e=this._context();if(e.state)return"";e.limit=1e4;const t=this._decode(e,0);return JSON.stringify(t,null,4)}_context(){const e={state:null,index:0,count:0};if(e.dataType=this._type.dataType,e.dimensions=this._type.shape.dimensions,!this._data)return e.state="Tensor data is empty.",e;switch(e.dataType){case"float32":e.data=this._data;break;case"float16":e.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:this._quantization?(e.dataType="quantization",e.bits=long.Long.isLong(this._quantization.numberOfBits)?this._quantization.numberOfBits.toNumber():this._quantization.numberOfBits,e.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength)):e.state="Tensor data type is not implemented."}return e}_decode(e,t){const i=[],r=e.dimensions[t];if(t==e.dimensions.length-1)for(let t=0;t<r;t++){if(e.count>e.limit)return i.push("..."),i;switch(e.dataType){case"float32":i.push(this._data[e.index]),e.index++;break;case"float16":i.push(e.data.getFloat16(e.index,!0)),e.index+=2;break;case"quantization":i.push(e.data.getBits(e.index,e.bits)),e.index++}e.count++}else for(let s=0;s<r;s++){if(e.count>e.limit)return i.push("..."),i;i.push(this._decode(e,t+1))}return i}},coreml.TensorType=class{constructor(e,t){this._dataType=e,this._shape=t||new coreml.TensorShape([])}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},coreml.TensorShape=class{constructor(e){this._dimensions=e}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.map((e=>e.toString())).join(",")+"]":""}},coreml.MapType=class{constructor(e,t){this._keyType=e,this._valueType=t}get keyType(){return this._keyType}get valueType(){return this._valueType}toString(){return"map<"+this._keyType+","+this._valueType.toString()+">"}},coreml.ImageType=class{constructor(e,t,i){switch(this._colorSpace="?",e){case coreml.proto.ImageFeatureType.ColorSpace.GRAYSCALE:this._colorSpace="Grayscale";break;case coreml.proto.ImageFeatureType.ColorSpace.RGB:this._colorSpace="RGB";break;case coreml.proto.ImageFeatureType.ColorSpace.BGR:this._colorSpace="BGR"}this._width=t,this._height=i}toString(){return"image<"+this._colorSpace+","+this._width.toString()+"x"+this._height.toString()+">"}},coreml.OptionalType=class{constructor(e){this._type=e}toString(){return this._type.toString()+"?"}},coreml.Metadata=class{static open(e){return coreml.Metadata._metadata?Promise.resolve(coreml.Metadata._metadata):e.request(null,"coreml-metadata.json","utf-8").then((e=>(coreml.Metadata._metadata=new coreml.Metadata(e),coreml.Metadata._metadata))).catch((()=>(coreml.Metadata._metadata=new coreml.Metadata(null),coreml.Metadata._metadata)))}constructor(e){if(this._map=new Map,this._attributeCache=new Map,this._inputCache={},e){const t=JSON.parse(e);if(t)for(const e of t)e.name&&e.schema&&(e.schema.name=e.name,this._map.set(e.name,e.schema))}}type(e){return this._map.get(e)}attribute(e,t){const i=e+":"+t;if(!this._attributeCache.has(i)){const t=this.type(e);if(t&&t.attributes&&t.attributes.length>0)for(const i of t.attributes)this._attributeCache.set(e+":"+i.name,i);this._attributeCache.has(i)||this._attributeCache.set(i,null)}return this._attributeCache.get(i)}getInputSchema(e,t){let i=this._inputCache[e];if(!i){i={};const t=this.type(e);if(t&&t.inputs&&t.inputs.length>0)for(const e of t.inputs)i[e.name]=e;this._inputCache[e]=i}return i[t]||null}getInputs(e,t){const i=[],r=this._map[e];let s=0;for(;s<t.length;){const e={arguments:[]};let a=1,n=null;r&&r.inputs?s<r.inputs.length&&(n=r.inputs[s].name,"variadic"==r.inputs[s].option&&(a=t.length-s)):0==s&&(n="input"),e.name=n||"("+s.toString()+")";const o=t.slice(s,s+a);for(let t=0;t<o.length;t++)e.arguments.push({name:o[t]});s+=a,i.push(e)}return i}getOutputName(e,t){const i=this._map[e];if(i){const e=i.outputs;if(e&&t<e.length){const i=e[t];if(i){const e=i.name;if(e)return e}}}return 0==t?"output":"("+t.toString()+")"}},coreml.Error=class extends Error{constructor(e){super(e),this.name="Error loading Core ML model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=coreml.ModelFactory);