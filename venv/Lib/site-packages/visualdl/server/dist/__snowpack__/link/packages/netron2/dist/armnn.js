var armnn=armnn||{},base=base||require("./base"),flatbuffers=flatbuffers||require("./flatbuffers"),long=long||{Long:require("long")};armnn.ModelFactory=class{match(t){const e=t.identifier.split(".").pop().toLowerCase();if("armnn"==e)return!0;if("json"===e){const e=t.text;if(-1!==e.indexOf('"layers"',0)&&-1!==e.indexOf('"layer_type"',0))return!0}return!1}open(t,e){return e.require("./armnn-schema").then((n=>{armnn.schema=flatbuffers.get("armnn").armnnSerializer;const a=t.identifier;let r=null;try{switch(a.split(".").pop().toLowerCase()){case"armnn":{const e=new flatbuffers.Reader(t.buffer);r=armnn.schema.SerializedGraph.create(e);break}case"json":{const e=new flatbuffers.TextReader(t.text);r=armnn.schema.SerializedGraph.createText(e);break}}}catch(t){e.exception(t,!1);const n=t&&t.message?t.message:t.toString();throw new armnn.Error(n.replace(/\.$/,"")+" in '"+a+"'.")}return armnn.Metadata.open(e).then((t=>{try{return new armnn.Model(t,r)}catch(t){const e=t&&t.message?t.message:t.toString();throw new new armnn.Error(e.replace(/\.$/,"")+" in '"+a+"'.")}}))}))}},armnn.Model=class{constructor(t,e){this._graphs=[],this._graphs.push(new armnn.Graph(t,e))}get format(){return"Arm NN"}get description(){return""}get graphs(){return this._graphs}},armnn.Graph=class{constructor(t,e){this._name="",this._nodes=[],this._inputs=[],this._outputs=[];const n={};for(let t=0;t<e.layers.length;t++){const a=armnn.Node.getBase(e.layers[t]);for(let t=0;t<a.outputSlots.length;t++){const e=a.index.toString()+":"+t.toString();n[e]=new armnn.Argument(e,a.outputSlots[t].tensorInfo,null)}}for(let a=0;a<e.layers.length;a++){const r=e.layers[a];switch(r.layer.constructor.name){case"InputLayer":{const t=armnn.Node.getBase(r),e=t?t.layerName:"";for(let a=0;a<t.outputSlots.length;a++){const r=n[t.index.toString()+":"+a.toString()];this._inputs.push(new armnn.Parameter(e,[r]))}break}case"OutputLayer":{const t=armnn.Node.getBase(r),e=t?t.layerName:"";for(let a=0;a<t.inputSlots.length;a++){const r=t.inputSlots[a].connection,s=r.sourceLayerIndex,i=r.outputSlotIndex,o=n[s.toString()+":"+i.toString()];this._outputs.push(new armnn.Parameter(e,[o]))}break}default:this._nodes.push(new armnn.Node(t,r,n))}}}get name(){return this._name}get groups(){return!1}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},armnn.Node=class{constructor(t,e,n){this._metadata=t,this._type=e.layer.constructor.name,this._name="",this._outputs=[],this._inputs=[],this._attributes=[];const a=armnn.Node.getBase(e);if(a){this._name=a.layerName;for(let t=0;t<a.inputSlots.length;t++){const e=a.inputSlots[t].connection,r=e.sourceLayerIndex,s=e.outputSlotIndex,i=n[r.toString()+":"+s.toString()];this._inputs.push(new armnn.Parameter("input",[i]))}for(let t=0;t<a.outputSlots.length;t++){const e=n[a.index.toString()+":"+t.toString()];this._outputs.push(new armnn.Parameter("output",[e]))}}const r=this._metadata.type(this._type);if(r){const t=armnn.Node.castLayer(e);if(r.bindings)for(let e=0;e<r.bindings.length;e++){const n=r.bindings[e],a=t.base()[n.src]();this._attributes.push(new armnn.Attribute(n.name,n.type,a))}if(r.attributes)for(const e of r.attributes){const n=this.packAttr(t,e);this._attributes.push(new armnn.Attribute(e.name,e.type,n))}if(r.inputs)for(let e=0;e<r.inputs.length;e++){const n=r.inputs[e],a=t[n.src];if(a){const t=[new armnn.Argument("",null,a)];this._inputs.push(new armnn.Parameter(n.name,t))}}}}get type(){return this._type.replace(/Layer$/,"")}get name(){return this._name}get domain(){return null}get metadata(){return this._metadata.type(this._type)}get group(){return null}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}static castLayer(t){return t.layer}static getBase(t){return(t=armnn.Node.castLayer(t)).base.base?t.base.base:t.base}getAttr(t,e){if(void 0===t[e])return"undefined";const n=t[e];return Array.isArray(n)?n.join(", "):n}packAttr(t,e){const n=null===t?null:t.descriptor,a=e.src,r=e.src_type;if(void 0!==r){const t=this.getAttr(n,a);return void 0!==armnn.schema[r+"Name"]?armnn.schema[r+"Name"][t]:t}if(Array.isArray(a)){const t=[];for(let e=0;e<a.length;e++)t.push(this.getAttr(n,a[e]));return t.join(", ")}return this.getAttr(n,a)}static makeKey(t,e){return t.toString()+"_"+e.toString()}},armnn.Attribute=class{constructor(t,e,n){switch(this._name=t,this._value=n,this._visible=!0,e){case"int":this._type="int32";break;case"uint":this._type="uint32";break;case"float":this._type="float32";break;case"string":this._type="string"}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},armnn.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},armnn.Argument=class{constructor(t,e,n){if("string"!=typeof t)throw new armnn.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");const a=n?n.info:e;this._name=t,this._type=new armnn.TensorType(a),this._initializer=n?new armnn.Tensor(a,n):null,this._type.dataType.startsWith("q")&&a&&(this._scale=a.quantizationScale,this._zeroPoint=a.quantizationOffset)}get name(){return this._name}get type(){return this._type}get quantization(){if(void 0!==this._scale&&void 0!==this._zeroPoint)return this._scale.toString()+" * "+(0==this._zeroPoint?"q":"(q - "+this._zeroPoint.toString()+")")}get initializer(){return this._initializer}},armnn.Tensor=class{constructor(t,e){this._name="",this._type=new armnn.TensorType(t),this._kind="Initializer",this._data=e.data.data.slice(0)}get name(){return this._name}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0};return null==this._data?(t.state="Tensor data is empty.",t):(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t)}_decode(t,e){let n=t.shape;0==n.length&&(n=[1]);const a=n[e],r=[];if(e==n.length-1)for(let e=0;e<a;e++){if(t.count>t.limit)return r.push("..."),r;switch(t.dataType){case"float16":r.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"float32":r.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"quint8":r.push(t.data.getUint8(t.index)),t.index+=1,t.count++;break;case"qint16":r.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++;break;case"int32":r.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"boolean":r.push(t.data.getInt8(t.index)),t.index+=1,t.count++}}else for(let n=0;n<a;n++){if(t.count>t.limit)return r.push("..."),r;r.push(this._decode(t,e+1))}return 0==t.shape.length?r[0]:r}},armnn.TensorType=class{constructor(t){const e=t.dataType;switch(e){case 0:this._dataType="float16";break;case 1:this._dataType="float32";break;case 2:this._dataType="quint8";break;case 3:this._dataType="int32";break;case 4:this._dataType="boolean";break;case 5:this._dataType="qint16";break;case 6:this._dataType="quint8";break;case 7:this._dataType="qint16";break;default:throw new armnn.Error("Unknown data type '"+JSON.stringify(e)+"'.")}this._shape=new armnn.TensorShape(t.dimensions)}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},armnn.TensorShape=class{constructor(t){this._dimensions=Array.from(t)}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.map((t=>t.toString())).join(",")+"]":""}},armnn.Metadata=class{static open(t){return armnn.Metadata._metadata?Promise.resolve(armnn.Metadata._metadata):t.request(null,"armnn-metadata.json","utf-8").then((t=>(armnn.Metadata._metadata=new armnn.Metadata(t),armnn.Metadata._metadata))).catch((()=>(armnn.Metadata._metadata=new armnn.Metadata(null),armnn.Metadata._metadata)))}constructor(t){if(this._map={},t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map[t.name]=t.schema)}}type(t){return this._map[t]}attribute(t,e){const n=this.type(t);if(n){let t=n.attributeMap;if(!t){if(t={},n.attributes)for(const e of n.attributes)t[e.name]=e;n.attributeMap=t}const a=t[e];if(a)return a}return null}},armnn.Error=class extends Error{constructor(t){super(t),this.name="Error loading Arm NN model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=armnn.ModelFactory);