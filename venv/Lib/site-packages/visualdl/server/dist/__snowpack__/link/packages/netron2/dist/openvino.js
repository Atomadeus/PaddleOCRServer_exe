var openvino=openvino||{},base=base||require("./base"),long=long||{Long:require("long")};openvino.ModelFactory=class{match(t){const e=t.identifier,n=e.split(".").pop().toLowerCase();if("xml"===n&&t.text.includes("<net"))return!0;if("bin"===n){switch(e){case"natives_blob.bin":case"snapshot_blob.bin":case"v8_context_snapshot.bin":return!1}const n=t.buffer,s=[33,168,239,190,173,222];if(n&&n.length>6&&s.every(((t,e)=>t==n[e])))return!1;if(n.length>4){const t=n[0]|n[1]<<8|n[2]<<16|n[3]<<24;if(0===t||1===t||19950407===t||871224===t||180310===t)return!1}return!0}return!1}open(t,e){const n=t.identifier;switch(n.split(".").pop().toLowerCase()){case"xml":return t.request(n.substring(0,n.length-4)+".bin",null).then((s=>this._openModel(n,e,t.text,s))).catch((()=>this._openModel(n,e,t.text,null)));case"bin":return t.request(n.substring(0,n.length-4)+".xml","utf-8").then((s=>this._openModel(n,e,s,t.buffer))).catch((t=>{e.exception(t,!1);const s=t&&t.message?t.message:t.toString();throw new openvino.Error(s.replace(/\.$/,"")+" in '"+n+"'.")}))}}_openModel(t,e,n,s){return openvino.Metadata.open(e).then((i=>{try{let o=!1;const a=new DOMParser({errorHandler:()=>{o=!0}}).parseFromString(n,"text/xml");if(o||null==a.documentElement||a.getElementsByTagName("parsererror").length>0)throw new openvino.Error("File format is not OpenVINO.");if(!a.documentElement||"net"!=a.documentElement.nodeName)throw new openvino.Error("File format is not OpenVINO IR.");const r=openvino.XmlReader.read(a.documentElement),u=new openvino.Model(i,r,s);return r.disconnectedLayers&&e.exception(new openvino.Error("Graph contains not connected layers "+JSON.stringify(r.disconnectedLayers)+" in '"+t+"'.")),u}catch(n){e.exception(n,!1);const s=n&&n.message?n.message:n.toString();throw new openvino.Error(s.replace(/\.$/,"")+" in '"+t+"'.")}}))}},openvino.Model=class{constructor(t,e,n){this._name=e.name||"",this._graphs=[new openvino.Graph(t,e,n)]}get name(){return this._name}get format(){return"OpenVINO IR"}get graphs(){return this._graphs}},openvino.Graph=class{constructor(t,e,n){this._name=e.name||"",this._nodes=[],this._inputs=[],this._outputs=[],this._arguments={};for(const s of this._const(e.layers,e.edges)){const i=s.inputs.map((t=>this._argument(s.id,s.precision,t,e.edges))),o=s.outputs.map((t=>this._argument(s.id,t.precision||s.precision,t,null)));switch(s.type){case"Input":{const t=s.name||"";this._inputs.push(new openvino.Parameter(t,o));break}default:this._nodes.push(new openvino.Node(this,t,n,s,i,o))}}this._replaceTensorIteratorWithSubgraph(t,n,e.layers,e.edges),delete this._arguments;const s=new Set;for(const t of this._nodes)for(const e of t.outputs)for(const t of e.arguments)s.add(t.name);for(const t of this.inputs)for(const e of t.arguments)s.add(e.name);const i=new Set;for(const t of this._nodes)for(const e of t.inputs)for(const n of e.arguments)n.initializer||s.has(n.name)||i.add(t);0!==i.size&&(e.disconnectedLayers=Array.from(i).map((t=>t.name)))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}_argument(t,e,n,s){let i=t+":"+n.id;s&&(i=s[i]);let o=this._arguments[i];if(!o){const t=0==n.dims.length?null:new openvino.TensorShape(n.dims);o=new openvino.Argument(i,new openvino.TensorType(e,t),null)}return o}_replaceTensorIteratorWithSubgraph(t,e,n,s){const i=n.filter((t=>"TensorIterator"===t.type));for(const n of i){const i=n.id,o=this._nodes.find((t=>t._id===i)),a=n.body.layers,r=n.body.edges,u=n.back_edges,p=Object.assign({},r,u),l=n.port_map;for(const n of this._const(a,p,u)){const s=n.inputs.map((t=>this._argument(n.id,n.precision,t,p))),o=n.outputs.map((t=>this._argument(n.id,n.precision||t.precision,t,null))),a=new openvino.Node(this,t,e,n,s,o);a._id=i+"_"+n.id;for(const t of a._inputs)for(const e of t.arguments)e.name&&(e._name=i+"_"+e.name);for(const t of a._outputs)for(const e of t.arguments)e.name&&(e._name=i+"_"+e.name);this._nodes.push(a)}for(const t of l.input){const e=this._nodes.find((e=>e._id===i+"_"+t.internal_layer_id)),n=s[i+":"+t.external_port_id];if(n){const t=n.split(":"),s=t[0],i=t[1];if(this._nodes.find((t=>t._id===s))){if(!e._inputs)throw new openvino.Error("Tensor Iterator node with name '"+e._id+"' does not have inputs.");const t=s+":"+i,n=e._inputs.find((t=>Boolean(t.arguments.find((t=>!t.name)))));if(n){const e=n._arguments.find((t=>!t._name));e&&(e._name=t)}else e._inputs.push(new openvino.Parameter((e._inputs.length+1).toString(),[new openvino.Argument(t,null,null)]))}else{const t=o._inputs.find((t=>"input"===t._name));if(!t)return;const n=e._inputs.find((t=>Boolean(t.arguments.find((t=>!t.name)))));if(n){const e=n.arguments.find((t=>!t.name));e&&(e._name=t.arguments[0].name)}}}}for(const t of l.output){const e=this._nodes.find((e=>e._id===`${i}_${t.internal_layer_id}`)),n=i+":"+t.external_port_id,o=Object.keys(s).filter((t=>s[t]===n));for(const t of o){const n=t.split(":")[0],s=this._nodes.find((t=>t._id===n));if(s._inputs&&(!s._inputs||0!==s._inputs.length)&&e._outputs&&e._outputs[0])for(const t of s._inputs)for(const n of t._arguments){if(!n.name||n.name&&n.name.split(":")[0]!==i)continue;const t=e.outputs[0].arguments[0].name.split(":")[1];n._name=e.id+":"+t}}}this._nodes=this._nodes.filter((t=>t.id!==n.id))}}_const(t,e,n){const s=[];n=n||{},t=t.slice();for(const e of t){if("Const"===e.type&&0===e.inputs.length&&1===e.outputs.length&&0===e.blobs.length&&e.data&&e.data.length>3){const t={};for(const n of e.data)t[n.name]=n.value;if(t.element_type&&t.offset&&t.size){const n=t.element_type;let s=null;switch(n){case"f16":s="FP16";break;case"f32":s="FP32";break;default:s=n.toUpperCase()}const i=t.shape?t.shape.split(",").map((t=>parseInt(t.trim(),10))):null;e.data=[],e.blobs.push({name:"custom",precision:s,offset:parseInt(t.offset,10),size:parseInt(t.size,10),shape:i})}}"Const"===e.type&&1===e.blobs.length&&!e.blobs[0].shape&&0===e.inputs.length&&1===e.outputs.length&&e.outputs[0].dims&&(e.blobs[0].shape=e.outputs[0].dims)}const i=new Map;for(const e of t)if("Const"===e.type&&0===e.inputs.length&&1===e.outputs.length){const t=e.id+":"+e.outputs[0].id;i.set(t,{layer:e,counter:0})}for(const t of Object.keys(e)){const n=e[t];i.has(n)&&i.get(n).counter++}if(n)for(const t of Object.keys(n)){const e=n[t];i.has(e)&&i.get(e).counter++}for(const t of i)1!==t[1].counter&&i.delete(t[0]);for(const s of t)if(0===s.blobs.length)for(let t=s.inputs.length-1;t>0;t--){const o=s.inputs[t],a=s.id+":"+o.id,r=e[a]||n[a];if(!i.has(r))break;const u=i.get(r).layer,p=u.blobs[0];p&&(p.id=u.name||u.id,p.kind="Const",s.blobs.push(p),s.inputs.splice(t,1),i.get(r).layer=null,i.get(r).delete=!0)}for(;t.length>0;){const e=t.shift();if("Const"===e.type&&0===e.inputs.length&&1===e.outputs.length){const t=e.id+":"+e.outputs[0].id;if(i.has(t)&&i.get(t).delete)continue}s.push(e)}return s}},openvino.Node=class{constructor(t,e,n,s,i,o){this._metadata=e,this._type=s.type,this._name=s.name||"",this._id=s.id,this._inputs=[],this._outputs=[],this._initializers=[],this._attributes=[];const a=s.precision;let r=0;for(const t of i){const e=0==r?"input":r.toString();this._inputs.push(new openvino.Parameter(e,[t])),r++}let u=0;for(const t of o){const e=0==u?"output":u.toString();this._outputs.push(new openvino.Parameter(e,[t])),u++}const p={};for(const t of s.data){p[t.name]=t.value;const n=e.attribute(this.type,t.name);this._attributes.push(new openvino.Attribute(n,t.name,t.value))}for(const t of s.blobs){const e=t.name,s=t.offset,i=t.size,o=n&&s+i<=n.length?n.slice(s,s+i):null;let r=t.shape||null;const u=t.kind||"Blob",l=t.id||"",h=t.precision||a,c={FP16:2,FP32:4,I8:1,I16:2,I32:4,I64:8,U8:1,U16:2,U32:4,U64:8}[h];if(c)switch(this._type+":"+e){case"FullyConnected:weights":{const t=parseInt(p["out-size"],10);r=[i/(t*c),t];break}case"FullyConnected:biases":r=[parseInt(p["out-size"],10)];break;case"Convolution:weights":case"Deconvolution:weights":{const t=this.inputs[0].arguments[0].type.shape.dimensions[1],e=parseInt(p.group||"1",10),n=p["kernel-x"]&&p["kernel-y"]?[parseInt(p["kernel-x"],10),parseInt(p["kernel-y"],10)]:p.kernel.split(",").map((t=>parseInt(t.trim(),10))),s=parseInt(p.output,10);r=[Math.floor(t/e),s].concat(n);break}case"ScaleShift:weights":case"ScaleShift:biases":case"Convolution:biases":case"Normalize:weights":case"PReLU:weights":r=[Math.floor(i/c)];break;case"Const:custom":this._outputs.length>0&&this._outputs[0].arguments.length>0&&this._outputs[0].arguments[0].type&&this._outputs[0].arguments[0].type.shape&&this._outputs[0].arguments[0].type.shape.dimensions&&(r=this._outputs[0].arguments[0].type.shape.dimensions)}const d=r?new openvino.TensorShape(r):null;this._initializers.push(new openvino.Parameter(e,[new openvino.Argument(l,null,new openvino.Tensor(h,d,o,u))]))}}get id(){return this._id}get name(){return this._name}get device(){return this._device||""}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs.concat(this._initializers)}get outputs(){return this._outputs}},openvino.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},openvino.Argument=class{constructor(t,e,n){this._name=t,this._type=e||null,this._initializer=n||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},openvino.Attribute=class{constructor(t,e,n){if(this._name=e,this._value=n,t){if(Object.prototype.hasOwnProperty.call(t,"type"))switch(this._type=t.type,t.type){case"boolean":switch(n){case"1":case"true":this._value=!0;break;case"0":case"false":this._value=!1}break;case"int32":{const t=Number.parseInt(this._value,10);this._value=Number.isNaN(this._value-t)?n:t;break}case"float32":case"float64":{const t=Number.parseFloat(this._value);this._value=Number.isNaN(this._value-t)?n:t;break}case"int32[]":if(this._value.length>2){let t=[];this._value.split(",").map((e=>{e=e.trim();const n=Number.parseInt(e,10);Number.isNaN(e-n)?t=null:null!=t&&t.push(n)})),null!=t&&(this._value=t)}break;case"float32[]":if(this._value.length>2){let t=[];this._value.split(",").map((e=>{e=e.trim();const n=Number.parseFloat(e);Number.isNaN(e-n)?t=null:null!=t&&t.push(n)})),null!=t&&(this._value=t)}}if(Object.prototype.hasOwnProperty.call(t,"visible")&&0==t.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(t,"default")){let e=t.default;if(this._value==e)this._visible=!1;else if(Array.isArray(this._value)&&Array.isArray(e)){if(e=e.slice(0,e.length),e.length>1&&null==e[e.length-1])for(e.pop();e.length<this._value.length;)e.push(e[e.length-1]);this._value.every(((t,n)=>t==e[n]))&&(this._visible=!1)}}}}get name(){return this._name}get value(){return this._value}get type(){return this._type}get visible(){return 0!=this._visible}},openvino.Tensor=class{constructor(t,e,n,s){this._data=n,this._type=new openvino.TensorType(t,e),this._kind=s}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return openvino.Tensor._stringify(e,"","    ")}_context(){const t={state:null};return this._data?this._type.shape?(t.index=0,t.count=0,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t):(t.state="Tensor shape is not defined.",t):(t.state="Tensor data is empty.",t)}_decode(t,e){const n=0==t.shape.length?[1]:t.shape,s=[],i=n[e];if(e==n.length-1)for(let e=0;e<i;e++){if(t.count>t.limit)return s.push("..."),s;switch(this._type.dataType){case"float32":s.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":s.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"int8":s.push(t.data.getInt8(t.index)),t.index+=1,t.count++;break;case"int16":s.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++;break;case"int32":s.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":s.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++;break;case"uint8":s.push(t.data.getUint8(t.index)),t.index+=1,t.count++;break;case"uint16":s.push(t.data.getUint16(t.index,!0)),t.index+=2,t.count++;break;case"uint32":s.push(t.data.getUint32(t.index,!0)),t.index+=4,t.count++;break;case"uint64":s.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!0)),t.index+=8,t.count++}}else for(let n=0;n<i;n++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return 0==t.shape.length?s[0]:s}static _stringify(t,e,n){if(Array.isArray(t)){const s=[];s.push(e+"[");const i=t.map((t=>openvino.Tensor._stringify(t,e+n,n)));return i.length>0&&s.push(i.join(",\n")),s.push(e+"]"),s.join("\n")}return"string"==typeof t?e+t:t==1/0?e+"Infinity":t==-1/0?e+"-Infinity":isNaN(t)?e+"NaN":e+t.toString()}},openvino.TensorType=class{constructor(t,e){switch(t=t?t.toLowerCase():t){case"f16":case"fp16":this._dataType="float16";break;case"f32":case"fp32":this._dataType="float32";break;case"i8":this._dataType="int8";break;case"i16":this._dataType="int16";break;case"i32":this._dataType="int32";break;case"i64":this._dataType="int64";break;case"u1":this._dataType="boolean";break;case"u8":this._dataType="uint8";break;case"u16":this._dataType="uint16";break;case"u32":this._dataType="uint32";break;case"u64":this._dataType="uint64";break;case"bool":this._dataType="boolean";break;case"":case null:this._dataType="?";break;default:throw new openvino.Error("Unknown precision '"+JSON.stringify(t)+"'.")}this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return null==this._shape?this.dataType+"[?]":this.dataType+this._shape.toString()}},openvino.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},openvino.Metadata=class{static open(t){return openvino.Metadata._metadata?Promise.resolve(openvino.Metadata._metadata):t.request(null,"openvino-metadata.json","utf-8").then((t=>(openvino.Metadata._metadata=new openvino.Metadata(t),openvino.Metadata._metadata))).catch((()=>(openvino.Metadata._metadata=new openvino.Metadata(null),openvino.Metadata._metadata)))}constructor(t){if(this._map=new Map,this._attributeMap=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)if(t&&t.name&&t.schema){if(this._map.has(t.name))throw new openvino.Error("Duplicate metadata key '"+t.name+"'.");t.schema.name=t.name,this._map.set(t.name,t.schema)}}}type(t){return this._map.get(t)||null}attribute(t,e){const n=t+":"+e;if(!this._attributeMap.has(n)){this._attributeMap.set(n,null);const e=this.type(t);if(e&&e.attributes)for(const n of e.attributes)this._attributeMap.set(t+":"+n.name,n)}return this._attributeMap.get(n)}},openvino.XmlReader=class{static read(t){const e=(t,e)=>{const n=[];let s=t.firstChild;for(;null!=s;)1==s.nodeType&&s.nodeName==e&&n.push(s),s=s.nextSibling;return n},n=(t,n)=>{const s=e(t,n);if(s.length>1)throw new openvino.Error("Element '"+t.nodeName+"' has multiple '"+n+"' elements.");return s.length>0?s[0]:null},s=(t,s)=>{const i=n(t,s);return i?e(i,"port").map((t=>({id:t.getAttribute("id"),precision:t.getAttribute("precision"),dims:Array.prototype.slice.call(t.getElementsByTagName("dim")).map((t=>parseInt(t.textContent.trim(),10)))}))):[]},i=t=>{const a=n(t,"layers");return a?e(a,"layer").map((t=>{const e=n(t,"data"),a=n(t,"blobs"),r={id:t.getAttribute("id"),name:t.getAttribute("name"),type:t.getAttribute("type"),precision:t.getAttribute("precision"),data:e?Array.from(e.attributes).map((t=>({name:t.name,value:t.value}))):[],blobs:a?Array.from(a.childNodes).filter((t=>1===t.nodeType)).map((t=>({name:t.nodeName,precision:t.getAttribute("precision"),offset:parseInt(t.getAttribute("offset"),10),size:parseInt(t.getAttribute("size"),10)}))):[],inputs:s(t,"input"),outputs:s(t,"output")};if("TensorIterator"===r.type){r.back_edges=o(t,"back_edges");const e=n(t,"body");e&&(r.body={layers:i(e),edges:o(e)});const s=n(t,"port_map");if(s){r.port_map={input:[],output:[]};for(const t of Array.from(s.childNodes).filter((t=>1===t.nodeType))){const e={axis:t.getAttribute("axis"),external_port_id:t.getAttribute("external_port_id"),internal_layer_id:t.getAttribute("internal_layer_id"),internal_port_id:t.getAttribute("internal_port_id")};switch(t.nodeName){case"input":r.port_map.input.push(e);break;case"output":r.port_map.output.push(e)}}}}return r})):[]},o=(t,s)=>{const i={},o=n(t,s||"edges");if(o)for(const t of e(o,"edge")){const e=t.getAttribute("from-layer"),n=t.getAttribute("from-port");i[t.getAttribute("to-layer")+":"+t.getAttribute("to-port")]=e+":"+n}return i};return{name:t.getAttribute("name"),batch:t.getAttribute("batch"),version:t.getAttribute("version"),layers:i(t),edges:o(t)}}},openvino.Error=class extends Error{constructor(t){super(t),this.name="Error loading OpenVINO model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=openvino.ModelFactory);