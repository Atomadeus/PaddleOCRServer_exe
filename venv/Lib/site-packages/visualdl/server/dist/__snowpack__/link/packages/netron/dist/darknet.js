var darknet=darknet||{},base=base||require("./base"),long=long||{Long:require("long")};darknet.ModelFactory=class{match(t){const e=t.identifier.split(".").pop().toLowerCase();if("cfg"==e||"model"==e){const e=t.text;if(-1!==e.substring(0,Math.min(e.length,1024)).indexOf("[net]"))return!0}return!1}open(t,e){return darknet.Metadata.open(e).then((e=>{const s=t.identifier,n=s.split(".");n.pop();const o=n.join(".");return t.request(o+".weights",null).then((n=>this._openModel(e,s,t.text,n))).catch((()=>this._openModel(e,s,t.text,null)))}))}_openModel(t,e,s,n){try{return new darknet.Model(t,s,n?new darknet.Weights(n):null)}catch(t){const s=t&&t.message?t.message:t.toString();throw new darknet.Error(s.replace(/\.$/,"")+" in '"+e+"'.")}}},darknet.Model=class{constructor(t,e,s){this._graphs=[],this._graphs.push(new darknet.Graph(t,e,s))}get format(){return"Darknet"}get graphs(){return this._graphs}},darknet.Graph=class{constructor(t,e,s){this._inputs=[],this._outputs=[],this._nodes=[];const n=[];let o=null;const u=e.split("\n");let a=0;for(;u.length>0;){a++;const t=u.shift(),e=t.replace(/\s/g,"");if(e.length>0)switch(e[0]){case"#":case";":break;case"[":o={},o.line=a,o.type="]"===e[e.length-1]?e.substring(1,e.length-1):e.substring(1),o.options={},n.push(o);break;default:if(!o||e[0]<32||e[0]>126)throw new darknet.Error("Invalid cfg '"+t.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+a.toString()+".");if(o){const s=e.indexOf("=");if(s<0)throw new darknet.Error("Invalid cfg '"+t.replace(/[^\x20-\x7E]+/g,"").trim()+"' at line "+a.toString()+".");const n=e.substring(0,s),u=e.substring(s+1);o.options[n]=u}}}const r=(t,e,s)=>{let n=t[e];if("string"==typeof n&&n.startsWith("$")){const t=n.substring(1);n=g.has(t)?g.get(t):n}if(void 0!==n){const s=parseInt(n,10);if(!Number.isInteger(s))throw new darknet.Error("Invalid int option '"+JSON.stringify(t[e])+"'.");return s}return s},i=(t,e,s)=>{const n=t[e];return void 0!==n?n:s},h=(t,e)=>{if(t.some((t=>0===t||void 0===t||isNaN(t))))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(t)+"' in '"+e+"'.");return new darknet.TensorShape(t)},l=(t,e,n)=>{const o=s?s.bytes(4*e.reduce(((t,e)=>t*e))):null,u=new darknet.TensorType("float32",h(e,"load_weights")),a=new darknet.Tensor(u,o),r=new darknet.Argument("",null,a);return new darknet.Parameter(t,!1!==n,[r])},p=(t,e,s)=>{t.weights.push(l(e+"scale",[s],""===e)),t.weights.push(l(e+"mean",[s],""===e)),t.weights.push(l(e+"variance",[s],""===e))},c=(t,e,s,n,o,u,a,r,i,c,_,w)=>{t.out_w=Math.floor((s+2*_-r)/i)+1,t.out_h=Math.floor((n+2*_-r)/c)+1,t.out_c=u,t.out=t.out_w*t.out_h*t.out_c,t.weights.push(l(e+"biases",[u],""===e)),w&&p(t,e,u),t.weights.push(l(e+"weights",[Math.floor(o/a),u,r,r],""===e)),t.outputs[0].type=new darknet.TensorType("float32",h([t.out_w,t.out_h,t.out_c],"make_convolutional_layer"))},_=(t,e,s,n,o)=>{t.out_h=1,t.out_w=1,t.out_c=n,t.out=n,t.weights.push(l(e+"biases",[n],""===e)),o&&p(t,e,n),t.weights.push(l(e+"weights",[s,n],""===e)),t.outputs[0].type=new darknet.TensorType("float32",h([n],"make_connected_layer"))},w={},g=new Map,d=n.shift();switch(d.type){case"net":case"network":w.h=r(d.options,"height",0),w.w=r(d.options,"width",0),w.c=r(d.options,"channels",0),w.inputs=r(d.options,"inputs",w.h*w.w*w.c);for(const t of Object.keys(d.options))g.set(t,d.options[t])}const y=w.w&&w.h&&w.c?new darknet.TensorType("float32",h([w.w,w.h,w.c],"params-if")):new darknet.TensorType("float32",h([w.inputs],"params-else")),f="input";if(w.arguments=[new darknet.Argument(f,y,null)],this._inputs.push(new darknet.Parameter(f,!0,w.arguments)),0===n.length)throw new darknet.Error("Config file has no sections.");let m=!0;for(let t=0;t<n.length;t++){const e=n[t];e.name=t.toString(),e.chain=[],e.layer={};const o=e.options,u=e.layer;switch(u.inputs=[].concat(w.arguments),u.outputs=[new darknet.Argument(t.toString(),null,null)],u.weights=[],e.type){case"shortcut":{const e=o.from?o.from.split(",").map((t=>Number.parseInt(t.trim(),10))):[];for(let s of e){s=s<0?t+s:s;const e=n[s].layer;e&&u.inputs.push(e.outputs[0])}delete o.from;break}case"sam":case"scale_channels":{let e=r(o,"from",0);e=e<0?t+e:e;const s=n[e].layer;s&&u.inputs.push(s.outputs[0]),delete o.from;break}case"route":{u.inputs=[],u.layers=[];const e=o.layers?o.layers.split(",").map((t=>Number.parseInt(t.trim(),10))):[];for(let s=0;s<e.length;s++){const o=n[e[s]<0?t+e[s]:e[s]].layer;o&&(u.inputs.push(o.outputs[0]),u.layers.push(o))}delete o.layers;break}}if(m){switch(e.type){case"conv":case"convolutional":case"deconvolutional":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==w.w||t[1]!==w.h||t[2]!==w.c)throw new darknet.Error("Layer before convolutional layer must output image.");const s=r(o,"size",1),n=r(o,"filters",1),a=r(o,"pad",0)?s>>1:r(o,"padding",0);let h=r(o,"stride_x",-1),l=r(o,"stride_y",-1);if(h<1||l<1){const t=r(o,"stride",1);h=h<1?t:h,l=l<1?t:l}const p=r(o,"groups",1),_=r(o,"batch_normalize",0),g=i(o,"activation","logistic");c(u,"",w.w,w.h,w.c,n,p,s,h,l,a,_),"logistic"!==g&&e.chain.push({type:g});break}case"connected":{const t=r(o,"output",1),s=r(o,"batch_normalize",0),n=i(o,"activation","logistic");_(u,"",w.inputs,t,s),"logistic"!==n&&e.chain.push({type:n});break}case"local":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==w.w||t[1]!==w.h||t[2]!==w.c)throw new darknet.Error("Layer before avgpool layer must output image.");const s=r(o,"filters",1),n=r(o,"size",1),a=r(o,"stride",1),p=r(o,"pad",0),c=i(o,"activation","logistic");u.out_h=Math.floor((w.h-(p?1:n))/a)+1,u.out_w=Math.floor((w.w-(p?1:n))/a)+1,u.out_c=s,u.out=u.out_w*u.out_h*u.out_c,u.weights.push(l("weights",[w.c,s,n,n,u.out_h*u.out_w])),u.weights.push(l("biases",[u.out_w*u.out_h*u.out_c])),u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"local")),"logistic"!==c&&e.chain.push({type:c});break}case"batchnorm":u.out_h=w.h,u.out_w=w.w,u.out_c=w.c,u.out=u.in,p(s,e,"",u.out),u.outputs[0].type=new darknet.TensorType("float32",h([u.ouputs],"batchnorm"));break;case"activation":u.out_h=w.h,u.out_w=w.w,u.out_c=w.c,u.out=u.in,u.outputs[0].type=new darknet.TensorType("float32",h([u.ouputs],"activation"));break;case"max":case"maxpool":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==w.w||t[1]!==w.h||t[2]!==w.c)throw new darknet.Error("Layer before maxpool layer must output image.");const e=r(o,"antialiasing",0),s=r(o,"stride",1),n=r(o,"stride_x",s),a=r(o,"stride_y",s),i=e?1:n,l=e?1:a,p=r(o,"size",s),_=r(o,"padding",p-1),g=r(o,"out_channels",1);if(r(o,"maxpool_depth",0)?(u.out_c=g,u.out_w=w.w,u.out_h=w.h):(u.out_w=Math.floor((w.w+_-p)/i)+1,u.out_h=Math.floor((w.h+_-p)/l)+1,u.out_c=w.c),e){const t=2===e?2:3,s=2===e?0:Math.floor(t/3);u.input_layer={weights:[],outputs:u.outputs},c(u.input_layer,"",u.out_h,u.out_w,u.out_c,u.out_c,u.out_c,t,n,a,s,0),u.out_w=u.input_layer.out_w,u.out_h=u.input_layer.out_h,u.out_c=u.input_layer.out_c}else u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"maxpool"));u.out=u.out_w*u.out_h*u.out_c;break}case"avgpool":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==w.w||t[1]!==w.h||t[2]!==w.c)throw new darknet.Error("Layer before avgpool layer must output image.");u.out_w=1,u.out_h=1,u.out_c=w.c,u.out=u.out_c,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"avgpool"));break}case"crnn":{const t=r(o,"size",3),e=r(o,"stride",1),s=r(o,"output",1),n=r(o,"hidden",1),a=r(o,"groups",1),i=r(o,"pad",0)?t>>1:r(o,"padding",0),h=r(o,"batch_normalize",0);u.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},c(u.input_layer,"input_",w.h,w.w,w.c,n,a,t,e,e,i,h),u.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},c(u.self_layer,"self_",w.h,w.w,n,n,a,t,e,e,i,h),u.output_layer={weights:[],outputs:u.outputs},c(u.output_layer,"output_",w.h,w.w,n,s,a,t,e,e,i,h),u.weights=u.weights.concat(u.input_layer.weights),u.weights=u.weights.concat(u.self_layer.weights),u.weights=u.weights.concat(u.output_layer.weights),u.out_h=u.output_layer.out_h,u.out_w=u.output_layer.out_w,u.out_c=s,u.out=u.output_layer.out;break}case"rnn":{const t=r(o,"output",1),e=r(o,"hidden",1),s=r(o,"batch_normalize",0),n=w.inputs;u.input_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.input_layer,"input_",n,e,s),u.self_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.self_layer,"self_",e,e,s),u.output_layer={weights:[],outputs:u.outputs},_(u.output_layer,"output_",e,t,s),u.weights=u.weights.concat(u.input_layer.weights),u.weights=u.weights.concat(u.self_layer.weights),u.weights=u.weights.concat(u.output_layer.weights),u.out_w=1,u.out_h=1,u.out_c=t,u.out=t;break}case"gru":{const t=w.inputs,e=r(o,"output",1),s=r(o,"batch_normalize",0);u.input_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.input_z_layer,"input_z",t,e,s),u.state_z_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.state_z_layer,"state_z",e,e,s),u.input_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.input_r_layer,"input_r",t,e,s),u.state_r_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.state_r_layer,"state_r",e,e,s),u.input_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.input_h_layer,"input_h",t,e,s),u.state_h_layer={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.state_h_layer,"state_h",e,e,s),u.weights=u.weights.concat(u.input_z_layer.weights),u.weights=u.weights.concat(u.state_z_layer.weights),u.weights=u.weights.concat(u.input_r_layer.weights),u.weights=u.weights.concat(u.state_r_layer.weights),u.weights=u.weights.concat(u.input_h_layer.weights),u.weights=u.weights.concat(u.state_h_layer.weights),u.out=e,u.outputs[0].type=new darknet.TensorType("float32",h([e],"gru"));break}case"lstm":{const t=w.inputs,e=r(o,"output",1),n=r(o,"batch_normalize",0);u.uf={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.uf,"uf_",t,e,n),u.ui={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.ui,"ui_",t,e,n),u.ug={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.ug,"ug_",t,e,n),u.uo={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.uo,"uo_",t,e,n),u.wf={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.wf,"wf_",e,e,n),u.wi={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.wi,"wi_",e,e,n),u.wg={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.wg,"wg_",e,e,n),u.wo={weights:[],outputs:[new darknet.Argument("",null,null)]},_(u.wo,"wo_",e,e,n),u.weights=u.weights.concat(u.uf.weights),u.weights=u.weights.concat(u.ui.weights),u.weights=u.weights.concat(u.ug.weights),u.weights=u.weights.concat(u.uo.weights),u.weights=u.weights.concat(u.wf.weights),u.weights=u.weights.concat(u.wi.weights),u.weights=u.weights.concat(u.wg.weights),u.weights=u.weights.concat(u.wo.weights),u.out_w=1,u.out_h=1,u.out_c=e,u.out=e,u.outputs[0].type=new darknet.TensorType("float32",h([e],"lstm")),s=null;break}case"softmax":u.out_w=w.w,u.out_h=w.h,u.out_c=w.c,u.out=w.inputs,u.outputs[0].type=new darknet.TensorType("float32",h([u.out],"softmax"));break;case"dropout":u.out_w=w.w,u.out_h=w.h,u.out_c=w.c,u.out=w.inputs,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"dropout"));break;case"upsample":{const t=r(o,"stride",2);u.out_w=w.w*t,u.out_h=w.h*t,u.out_c=w.c,u.out=u.out_w*u.out_h*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"upsample"));break}case"crop":{const t=u.inputs[0].type.shape.dimensions;if(t[0]!==w.w||t[1]!==w.h||t[2]!==w.c)throw new darknet.Error("Layer before crop layer must output image.");const e=r(o,"crop_height",1),s=r(o,"crop_width",1);u.out_w=s,u.out_h=e,u.out_c=w.c,u.out=u.out_w*u.out_h*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"crop"));break}case"yolo":{const t=r(o,"classes",20),e=r(o,"num",1);u.out_h=w.h,u.out_w=w.w,u.out_c=e*(t+4+1),u.out=u.out_h*u.out_w*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"yolo"));break}case"Gaussian_yolo":{const t=r(o,"classes",20),e=r(o,"num",1);u.out_h=w.h,u.out_w=w.w,u.out_c=e*(t+8+1),u.out=u.out_h*u.out_w*u.out_c,u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"Gaussian_yolo"));break}case"region":{const t=r(o,"coords",4),e=r(o,"classes",20),s=r(o,"num",1);u.out=w.h*w.w*s*(e+t+1),u.outputs[0].type=new darknet.TensorType("float32",h([w.h,w.w,s,e+t+1],"region"));break}case"cost":u.out=w.inputs,u.outputs[0].type=new darknet.TensorType("float32",h([u.out],"cost"));break;case"reorg":{const t=r(o,"stride",1),e=r(o,"reverse",0),s=r(o,"extra",0);e?(u.out_w=w.w*t,u.out_h=w.h*t,u.out_c=Math.floor(w.c/(t*t))):(u.out_w=Math.floor(w.w/t),u.out_h=Math.floor(w.h/t),u.out_c=w.c*(t*t)),u.out=u.out_h*u.out_w*u.out_c,s&&(u.out_w=0,u.out_h=0,u.out_c=0,u.out=w.h*w.w*w.c+s),u.outputs[0].type=new darknet.TensorType("float32",h([u.out],"reorg"));break}case"route":{const t=[].concat(u.layers),e=r(o,"groups",1);u.out=0;for(const s of t)u.out+=s.outputs/e;if(t.length>0){const s=t.shift();for(u.out_w=s.out_w,u.out_h=s.out_h,u.out_c=s.out_c/e;t.length>0;){const e=t.shift();if(e.out_w!==s.out_w||e.out_h!==s.out_h){m=!1;break}u.out_c+=e.out_c}m&&(u.outputs[0].type=new darknet.TensorType("float32",h([u.out_w,u.out_h,u.out_c],"route")))}else m=!1;m||(u.out_h=0,u.out_w=0,u.out_c=0);break}case"shortcut":case"scale_channels":case"sam":{const t=i(o,"activation","linear");u.out_w=w.w,u.out_h=w.h,u.out_c=w.c,u.out=w.w*w.h*w.c,u.outputs[0].type=new darknet.TensorType("float32",h([w.w,w.h,w.c],"shortcut|scale_channels|sam")),"linear"!==t&&e.chain.push({type:t});break}case"detection":u.out_w=w.w,u.out_h=w.h,u.out_c=w.c,u.out=w.inputs,u.outputs[0].type=new darknet.TensorType("float32",h([u.out],"detection"));break;default:m=!1}w.h=u.out_h,w.w=u.out_w,w.c=u.out_c,w.inputs=u.out,w.last=e}w.arguments=u.outputs}for(let e=0;e<n.length;e++)this._nodes.push(new darknet.Node(t,d,n[e]));s&&s.validate()}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},darknet.Parameter=class{constructor(t,e,s){this._name=t,this._visible=e,this._arguments=s}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},darknet.Argument=class{constructor(t,e,s){if("string"!=typeof t)throw new darknet.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e,this._initializer=s}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}set type(t){if(this._type)throw new darknet.Error("Invalid argument type set operation.");this._type=t}get initializer(){return this._initializer}},darknet.Node=class{constructor(t,e,s){this._name=s.name||"",this._location=void 0!==s.line?s.line.toString():void 0,this._metadata=t,this._type=s.type,this._attributes=[],this._inputs=[],this._outputs=[],this._chain=[];const n=s.layer;if(n&&n.inputs&&n.inputs.length>0&&this._inputs.push(new darknet.Parameter(n.inputs.length<=1?"input":"inputs",!0,n.inputs)),n&&n.weights&&n.weights.length>0&&(this._inputs=this._inputs.concat(n.weights)),n&&n.outputs&&n.outputs.length>0&&this._outputs.push(new darknet.Parameter(n.outputs.length<=1?"output":"outputs",!0,n.outputs)),s.chain)for(const n of s.chain)this._chain.push(new darknet.Node(t,e,n,""));const o=s.options;if(o)for(const e of Object.keys(o))this._attributes.push(new darknet.Attribute(t.attribute(this._type,e),e,o[e]))}get name(){return this._name}get location(){return this._location}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}},darknet.Attribute=class{constructor(t,e,s){if(this._name=e,this._value=s,t){switch(this._type=t.type||"",this._type){case"int32":{const t=parseInt(this._value,10);Number.isInteger(t)&&(this._value=t);break}case"float32":{const t=parseFloat(this._value);isNaN(t)||(this._value=t);break}case"int32[]":{const t=this._value.split(",").map((t=>parseInt(t.trim(),10)));t.every((t=>Number.isInteger(t)))&&(this._value=t);break}}(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&this._value==t.default)&&(this._visible=!1)}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},darknet.Tensor=class{constructor(t,e){this._type=t,this._data=e}get kind(){return"Tensor"}get name(){return""}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={};return this._data?(t.state=null,t.position=0,t.count=0,t.dataView=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t.dimensions=this.type.shape.dimensions,t):(t.state="Tensor data is empty.",t)}_decode(t,e){const s=[],n=t.dimensions[e];if(e==t.dimensions.length-1)for(let e=0;e<n;e++){if(t.count>t.limit)return s.push("..."),s;s.push(t.dataView.getFloat32(t.position,!0)),t.position+=4,t.count++}else for(let o=0;o<n;o++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return s}},darknet.TensorType=class{constructor(t,e){this._dataType=t,this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return(this._dataType||"?")+this._shape.toString()}},darknet.TensorShape=class{constructor(t){if(t.some((t=>0===t||void 0===t||isNaN(t))))throw new darknet.Error("Invalid tensor shape '"+JSON.stringify(t)+"'.");this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?0==this._dimensions.length?"":"["+this._dimensions.map((t=>t.toString())).join(",")+"]":""}},darknet.Weights=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0;const e=this.int32(),s=this.int32(),n=this.int32();if(this._seen=10*e+s>=2?this.int64():this.int32(),e>1e3||s>1e3)throw new darknet.Error("Unsupported transpose weights file version '"+[e,s,n].join(".")+"'.")}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int64(){const t=this.int32(),e=this.int32();return new long.Long(t,e,!0).toNumber()}bytes(t){const e=this._position;return this.skip(t),this._buffer.subarray(e,this._position)}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new darknet.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}validate(){if(this._position!==this._buffer.length)throw new darknet.Error("Invalid weights size.")}},darknet.Metadata=class{static open(t){return darknet.Metadata._metadata?Promise.resolve(darknet.Metadata._metadata):t.request(null,"darknet-metadata.json","utf-8").then((t=>(darknet.Metadata._metadata=new darknet.Metadata(t),darknet.Metadata._metadata))).catch((()=>(darknet.Metadata._metadata=new darknet.Metadata(null),darknet.Metadata._metadata)))}constructor(t){if(this._map=new Map,this._attributeMap=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)if(t&&t.name&&t.schema){if(this._map.has(t.name))throw new darknet.Error("Duplicate metadata key '"+t.name+"'.");t.schema.name=t.name,this._map.set(t.name,t.schema)}}}type(t){return this._map.get(t)||null}attribute(t,e){const s=t+":"+e;if(!this._attributeMap.has(s)){this._attributeMap.set(s,null);const e=this.type(t);if(e&&e.attributes)for(const s of e.attributes)this._attributeMap.set(t+":"+s.name,s)}return this._attributeMap.get(s)}},darknet.Error=class extends Error{constructor(t){super(t),this.name="Error loading Darknet model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=darknet.ModelFactory);