var tf=tf||{},long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");tf.ModelFactory=class{match(t){const e=t.identifier,s=e.split(".").pop().toLowerCase();if("meta"===s&&0!==t.tags("pb").size)return!0;if("pbtxt"===s||"prototxt"===s){if(e.endsWith("predict_net.pbtxt")||e.endsWith("predict_net.prototxt")||e.endsWith("init_net.pbtxt")||e.endsWith("init_net.prototxt"))return!1;const s=t.tags("pbtxt");if(s.has("input_stream")||s.has("output_stream"))return!1;if(s.has("node")||s.has("saved_model_schema_version")||s.has("meta_graphs")||s.has("graph_def"))return!0}if("pb"===s||"pbtxt"===s||"prototxt"===s){if(e.endsWith("predict_net.pb")||e.endsWith("init_net.pb"))return!1;if("tfhub_module.pb"==e){const e=t.buffer;if(e&&2==e.length&&8==e[0]&&3==e[1])return!1}const s=t.tags("pb");if(0===s.size){const e=t.tags("pbtxt");if(e.has("input_stream")||e.has("output_stream"))return!1;if(e.has("node")||e.has("saved_model_schema_version")||e.has("meta_graphs")||e.has("graph_def"))return!0}else{if(s.has(1)&&0===s.get(1)&&s.has(2)&&0===s.get(2)&&s.has(9)&&2===s.get(9))return!1;if(!Array.from(s.values()).some((t=>5===t)))return!0}}if("json"===s)try{const e=JSON.parse(t.text);if(e&&e.format&&"graph-model"===e.format&&e.modelTopology)return!0}catch(t){}if(("index"===s||"ckpt"===s)&&t.buffer.length>8){const e=t.buffer.subarray(t.buffer.length-8,t.buffer.length),s=[87,251,128,139,36,117,71,219];if(e.every(((t,e)=>t===s[e])))return!0}return!1}open(t,e){return e.require("./tf-proto").then((()=>{tf.proto=protobuf.get("tf").tensorflow;let s=null,n=null,o=null;const r=t.identifier,a=r.split(".").pop().toLowerCase();switch(a){case"ckpt":case"index":return tf.ModelFactory._openBundle(t,e);case"json":try{const e=JSON.parse(t.text),r=new tf.proto.GraphDef,a=new tf.proto.MetaGraphDef;a.graph_def=r,s=new tf.proto.SavedModel,s.meta_graphs.push(a);for(const t of e.modelTopology.node)r.node.push(t),t.input=t.input||[];n="TensorFlow.js "+e.format,o=e.convertedBy||e.generatedBy||""}catch(t){throw new tf.Error("File text format is not TensorFlow.js graph-model ("+t.message+") in '"+r+"'.")}break;default:{const e=t.tags("pbtxt");if(e.has("node")||e.has("saved_model_schema_version")||e.has("meta_graphs")||e.has("graph_def")){if(e.has("saved_model_schema_version")||e.has("meta_graphs"))try{(r.endsWith("saved_model.pbtxt")||r.endsWith("saved_model.prototxt"))&&(s=tf.proto.SavedModel.decodeText(protobuf.TextReader.create(t.text)),n="TensorFlow Saved Model",s&&Object.prototype.hasOwnProperty.call(s,"saved_model_schema_version")&&(n=n+" v"+s.saved_model_schema_version.toString()))}catch(t){throw new tf.Error("File text format is not tensorflow.SavedModel ("+t.message+") in '"+r+"'.")}else if(e.has("graph_def"))try{if(!s){const e=tf.proto.MetaGraphDef.decodeText(protobuf.TextReader.create(t.text));s=new tf.proto.SavedModel,s.meta_graphs.push(e),n="TensorFlow MetaGraph"}}catch(t){throw new tf.Error("File text format is not tensorflow.MetaGraphDef ("+t.message+") in '"+r+"'.")}else if(e.has("node"))try{const e=tf.proto.GraphDef.decodeText(protobuf.TextReader.create(t.text)),o=new tf.proto.MetaGraphDef;o.graph_def=e,s=new tf.proto.SavedModel,s.meta_graphs.push(o),n="TensorFlow Graph"}catch(t){throw new tf.Error("File text format is not tensorflow.GraphDef ("+t.message+") in '"+r+"'.")}}else{try{if(r.endsWith("saved_model.pb")){const e=protobuf.Reader.create(t.buffer);s=tf.proto.SavedModel.decode(e),n="TensorFlow Saved Model",s&&Object.prototype.hasOwnProperty.call(s,"saved_model_schema_version")&&(n=n+" v"+s.saved_model_schema_version.toString())}}catch(e){const s=t.buffer;if(s.length>3&&8==s[0]&&1==s[1]&&18==s[2])throw new tf.Error("File format is not tensorflow.SavedModel ("+e.message+") in '"+r+"'.")}try{if(!s&&"meta"==a){const e=protobuf.Reader.create(t.buffer),o=tf.proto.MetaGraphDef.decode(e);s=new tf.proto.SavedModel,s.meta_graphs.push(o),n="TensorFlow MetaGraph"}}catch(t){throw new tf.Error("File format is not tensorflow.MetaGraphDef ("+t.message+") in '"+r+"'.")}try{if(!s){const e=protobuf.Reader.create(t.buffer),o=tf.proto.GraphDef.decode(e),r=new tf.proto.MetaGraphDef;r.graph_def=o,s=new tf.proto.SavedModel,s.meta_graphs.push(r),n="TensorFlow Graph"}}catch(t){throw new tf.Error("File format is not tensorflow.GraphDef ("+t.message+") in '"+r+"'.")}}s&&s.meta_graphs&&s.meta_graphs.length>0&&s.meta_graphs[0].meta_info_def&&Object.prototype.hasOwnProperty.call(s.meta_graphs[0].meta_info_def,"tensorflow_version")&&(o="TensorFlow v"+s.meta_graphs[0].meta_info_def.tensorflow_version);break}}return tf.Metadata.open(e).then((a=>{if(1===s.meta_graphs.length&&s.meta_graphs[0].object_graph_def&&s.meta_graphs[0].object_graph_def.nodes&&s.meta_graphs[0].object_graph_def.nodes.length>0){const r="variables/variables.index";return t.request(r,null).then((i=>tf.TensorBundle.open(i,r,t,e).then((t=>tf.ModelFactory._openModel(r,e,a,s,n,o,t))))).catch((()=>tf.ModelFactory._openModel(r,e,a,s,n,o,null)))}return tf.ModelFactory._openModel(r,e,a,s,n,o,null)}))}))}static _openModel(t,e,s,n,o,r,a){try{return new tf.Model(s,n,o,r,a)}catch(s){e.exception(s,!1);const n=s&&s.message?s.message:s.toString();throw new tf.Error(n.replace(/\.$/,"")+" in '"+t+"'.")}}static _openBundle(t,e){return tf.Metadata.open(e).then((s=>{const n=t.identifier;return tf.TensorBundle.open(t.buffer,n,t,e).then((t=>new tf.Model(s,null,"TensorFlow Tensor Bundle v"+t.format.toString(),null,t))).catch((t=>{e.exception(t,!1);const s=t&&t.message?t.message:t.toString();throw new tf.Error(s.replace(/\.$/,"")+" in '"+n+"'.")}))}))}},tf.Model=class{constructor(t,e,s,n,o){if(this._format=s,this._producer=n||"",this._graphs=[],e){for(let s=0;s<e.meta_graphs.length;s++){const n=e.meta_graphs[s];let r=null;r=n.any_info?n.any_info.toString():e.meta_graphs.length>1?s.toString():"-",this._graphs.push(new tf.Graph(t,n,r,o))}const s=[],n=[...this._graphs];for(;n.length>0;){const t=n.shift();s.push(t);for(const e of t.functions)n.push(e)}this._graphs=s}else this._graphs.push(new tf.Graph(t,null,"",o))}get format(){return this._format}get producer(){return this._producer}get description(){return null}get graphs(){return this._graphs}},tf.Graph=class{constructor(t,e,s,n){if(this._metadata=t,this._version=null,this._name=s,this._inputs=[],this._outputs=[],this._nodes=[],this._functions=[],e&&e.graph_def){this._metadata=new tf.GraphMetadata(t,e.meta_info_def);const s=e.graph_def;s.versions?this._version="v"+s.versions.producer.toString():s.version?this._version=s.version:e.meta_info_def&&e.meta_info_def.tensorflow_version&&(this._version=e.meta_info_def.tensorflow_version),e.meta_info_def&&e.meta_info_def.tags&&(this._tags=e.meta_info_def.tags.join(", "));const n=s.node;if(n){const t={};this._namespaces={};for(const e of n){const s=e.name;if(t[s]=e,"Const"!=e.op){const t=s.lastIndexOf("/");if(-1!=t){const e=s.substring(0,t);this._namespaces[e]=!0}}e.output=[]}for(const e of n){const s=e.input;e.input=[],e.controlDependencies=[];for(const n of s){const s=n.split(":",2),o=s[0],r=1==s.length?0:parseInt(s[1]);let a=o.startsWith("^")?o.substring(1):o;const i=t[a];if(a=0==r?a:a+":"+r.toString(),o.startsWith("^")?e.controlDependencies.push(a):e.input.push(a),i){for(let t=i.output.length;t<=r;t++)i.output.push("");i.output[r]=a}}}this._nodeOutputCountMap={};for(const t of n){for(const e of t.input)this._nodeOutputCountMap[e]=(this._nodeOutputCountMap[e]||0)+1;for(const e of t.controlDependencies)this._nodeOutputCountMap[e]=(this._nodeOutputCountMap[e]||0)+1}const e={};for(const t of n)if("Const"==t.op&&0==t.input.length&&0==t.controlDependencies.length&&this._checkSingleOutput(t)){const s=t.attr.value;if(s&&Object.prototype.hasOwnProperty.call(s,"tensor")){const n=t.output[0];n&&(e[n]=new tf.Tensor(s.tensor,t.name,"Constant"))}}for(const t of n)if("Identity"==t.op&&1==t.input.length&&0==t.controlDependencies.length&&this._checkSingleOutput(t)){const s=t.input[0],n=e[s];n&&(e[s]="-",n.kind="Identity Constant",e[t.output[0]]=n)}const s={};for(const t of n)if("Placeholder"==t.op&&0==t.input.length&&0==t.controlDependencies.length&&1==t.output.length){const e=t.attr.dtype,n=t.attr.shape;if(e&&e.type&&n&&n.shape){const o=new tf.TensorType(e.type,n.shape),r=new tf.Argument(t.output[0],o,null);s[t.output[0]]=new tf.Parameter(t.name,[r])}}this._inputs=Object.keys(s).map((t=>s[t]));for(const t of n){const n=t.name;e[n]||s[n]||this._nodes.push(new tf.Node(this,t,t.op,t.name,e,null))}}if(s.library){const t=s.library.function;for(const e of t)this._functions.push(new tf.Function(this,e,this._metadata))}}else if(n){const t=[],e=new Map;for(const s of n.tensors){const o=s.name.split("/");if(2===n.format){if("_CHECKPOINTABLE_OBJECT_GRAPH"===s.name||s.name.startsWith("optimizer/")||s.name.startsWith("keras_api/metrics/")||s.name.endsWith("/ExponentialMovingAverage")||-1!==s.name.indexOf(".OPTIMIZER_SLOT"))continue;s.name.endsWith("/.ATTRIBUTES/VARIABLE_VALUE")&&(o.pop(),o.pop())}const r=o.pop(),a=o.join("/");e.has(a)||(t.push(a),e.set(a,[])),e.get(a).push({name:r,value:s})}for(const s of t)this._nodes.push(new tf.Node(this,null,"Node",s,null,e.get(s)))}}get name(){return this._name}get version(){return this._version}get tags(){return this._tags}get groups(){return!1}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}get metadata(){return this._metadata}get namespaces(){return this._namespaces}get functions(){return this._functions}_checkSingleOutput(t){if(1!=t.output.length)return!1;const e=t.output[0];return 1==this._nodeOutputCountMap[e]}},tf.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},tf.Argument=class{constructor(t,e,s){if("string"!=typeof t)throw new tf.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=s||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},tf.Function=class{constructor(t,e,s){this._name=e.signature.name,this._version=null,this._tags=null,this._inputs=[],this._outputs=[],this._nodes=[],this._metadata=s,this._namespaces={},this._functions=[];const n=e.signature.input_arg;if(n)for(const t of n){const e=new tf.Argument(t.name,new tf.TensorType(t.type,null),null);this._inputs.push(new tf.Parameter(t.name,[e]))}const o={};for(const t of Object.keys(e.ret)){const s=e.ret[t].split(":",2);o[t]=s[0]}const r={},a=e.signature.output_arg;if(a)for(const t of a){const e=o[t.name];this._outputs.push(new tf.Parameter(t.name,[new tf.Argument(e,new tf.TensorType(t.type,null),null)])),r[e]=t.name}const i=e.node_def;if(i){const t={};for(const e of i){const s=e.name;if(t[s]=e,"Const"!=e.op){const t=s.lastIndexOf("/");if(-1!=t){const e=s.substring(0,t);this._namespaces[e]=!0}}e.output=[]}for(const e of i){const s=e.input;e.input=[],e.controlDependencies=[];for(const n of s){const s=n.split(":",3),o=s[0],r=1==s.length?0:parseInt(s[s.length-1]);let a=o.startsWith("^")?o.substring(1):o;const i=t[a];if(a=0==r?a:a+":"+r.toString(),o.startsWith("^")?e.controlDependencies.push(a):e.input.push(a),i){for(let t=i.output.length;t<=r;t++)i.output.push("");i.output[r]=a}}r[e.name]&&e.output.push(e.name)}const e={};for(const t of i){for(const s of t.input)e[s]=(e[s]||0)+1;for(const s of t.controlDependencies)e[s]=(e[s]||0)+1}const s={};for(const t of i)if("Const"==t.op&&0==t.input.length&&0==t.controlDependencies.length&&tf.Function._checkSingleOutput(t,e)){const e=t.attr.value;if(e&&Object.prototype.hasOwnProperty.call(e,"tensor")){const n=t.output[0];n&&(s[n]=new tf.Tensor(e.tensor,t.name,"Constant"))}}for(const t of i)if("Identity"==t.op&&1==t.input.length&&0==t.controlDependencies.length&&tf.Function._checkSingleOutput(t,e)){const e=t.input[0],n=s[e];n&&(s[e]="-",n.kind="Identity Constant",s[t.output[0]]=n)}for(const t of i)s[t.name]||this._nodes.push(new tf.Node(this,t,t.op,t.name,s,null))}}get name(){return this._name}get version(){return this._version}get tags(){return this._tags}get groups(){return!1}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}get metadata(){return this._metadata}get namespaces(){return this._namespaces}get functions(){return this._functions}static _checkSingleOutput(t,e){return 1==t.output.length&&1==e[t.output[0]]}},tf.Node=class{constructor(t,e,s,n,o,r){if(this._graph=t,this._type=s,this._name=n,this._attributes=[],this._inputs=[],this._outputs=[],e){Object.prototype.hasOwnProperty.call(e,"device")&&(this._device=e.device);const s=t.metadata;if(e.attr)for(const t of Object.keys(e.attr)){const n=s.attribute(this._type,t),o=!s.getAttributeVisibleMap(this._type)[t];this._attributes.push(new tf.Attribute(n,t,e.attr[t],o))}const n=s.type(this._type);let r=0;const a=e.input.filter((t=>!t.startsWith("^")));if(n&&n.inputs)for(const t of n.inputs){let s=1;if(t.numberAttr){const n=e.attr[t.numberAttr];n&&n.i&&(s=n.i)}else if(t.typeListAttr){const n=e.attr[t.typeListAttr];n&&n.list&&n.list.type&&(s=n.list.type.length)}const n=a.slice(r,r+s).map((t=>new tf.Argument(t,null,o[t])));this._inputs.push(new tf.Parameter(t.name,n)),r+=s}this._inputs=this._inputs.concat(a.slice(r).map(((t,e)=>new tf.Parameter((r+e).toString(),[new tf.Argument(t,null,o[t])]))));let i=0;const p=e.output;if(n&&n.outputs)for(const t of n.outputs){let s=1;if(t.numberAttr){const n=e.attr[t.numberAttr];n&&n.i&&(s=n.i)}else if(t.typeListAttr){const n=e.attr[t.typeListAttr];n&&n.list&&n.list.type&&(s=n.list.type.length)}const n=p.slice(i,i+s).map((t=>new tf.Argument(t,null,null)));this._outputs.push(new tf.Parameter(t.name,n)),i+=s}this._outputs=this._outputs.concat(p.slice(i).map(((t,e)=>new tf.Parameter((i+e).toString(),[new tf.Argument(t,null,null)])))),this._controlDependencies=e.controlDependencies}else if(r)for(const t of r)this._inputs.push(new tf.Parameter(t.name,[new tf.Argument(t.value.name,null,t.value)]))}get type(){return this._type}get name(){return this._name}get device(){return this._device||null}get group(){const t=this._name;if(this._graph.namespaces[t])return t;const e=t.lastIndexOf("/");if(-1!=e){const s=t.substring(0,e);if(this._graph.namespaces[s])return s}return""}get description(){return""}get domain(){return null}get metadata(){return this._graph.metadata.type(this.type)}get inputs(){return this._inputs}get outputs(){return this._outputs}get controlDependencies(){return this._controlDependencies}get attributes(){return this._attributes}},tf.Attribute=class{constructor(t,e,s,n){switch(this._name=e,this._value=null,this._type=null,Object.prototype.hasOwnProperty.call(s,"tensor")?(this._type="tensor",this._value=new tf.Tensor(s.tensor)):t&&t.type&&(this._type=t.type),s.value){case"type":this._type="type",this._value=tf.Tensor.formatDataType(s.type);break;case"i":this._value=s.i;break;case"f":this._value=s.f;break;case"b":this._value=s.b;break;case"shape":this._type="shape",this._value=new tf.TensorShape(s.shape);break;case"s":this._value=tf.Utility.decodeText(s.s);break;case"func":{const t=s.func;this._type="function",this._value=t.name;break}case"list":{const t=s.list;t.s&&t.s.length>0?this._value=t.s.map((t=>tf.Utility.decodeText(t))):t.i&&t.i.length>0?this._value=t.i:t.f&&t.f.length>0?this._value=t.f:t.type&&t.type.length>0?(this._type="type[]",this._value=t.type.map((t=>tf.Tensor.formatDataType(t)))):t.shape&&t.shape.length>0?(this._type="shape[]",this._value=t.shape.map((t=>new tf.TensorShape(t)))):this._value=[];break}}if(t)if(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(t,"default")&&(!Array.isArray(this._value)||Array.isArray(t.default)||this._value.length===t.default.length)){let e=this._value,s=t.default;if("float32"===this._type){const t=new Float32Array(1);t[0]=e,e=t[0],t[0]=s,s=t[0]}const n=tf.GraphMetadata._formatAttributeValue(e),o=tf.GraphMetadata._formatAttributeValue(s);JSON.stringify(n)==JSON.stringify(o)&&(this._visible=!1)}"_output_shapes"==e&&(this._visible=!1,this._type="shape[]"),"_class"==e&&(this._visible=!1),!1===n&&(this._visible=!1)}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},tf.Tensor=class{constructor(t,e,s){this._type=new tf.TensorType(t.dtype,t.tensor_shape||t.tensorShape),this._name=e,this._kind=s||null,this._tensor=t}get name(){return this._name}get type(){return this._type}get kind(){return this._kind}set kind(t){this._kind=t}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0,size:1};if(!this._tensor.dtype)return t.state="Tensor has no data type.",t;const e=this._tensor.tensor_shape||this._tensor.tensorShape;if(!e||!e.dim)return t.state="Tensor has no dimensions.",t;for(const s of e.dim)t.size=t.size*(s.size?s.size:0);switch(this._tensor.dtype){case"DT_FLOAT":case tf.proto.DataType.DT_FLOAT:this._tensor.tensor_content&&this._tensor.tensor_content.length>0?t.rawData=new DataView(this._tensor.tensor_content.buffer,this._tensor.tensor_content.byteOffset,this._tensor.tensor_content.byteLength):this._tensor.float_val&&this._tensor.float_val.length==t.size?t.data=this._tensor.float_val:t.state="Tensor data is empty.";break;case tf.proto.DataType.DT_QINT8:case tf.proto.DataType.DT_QUINT8:this._tensor.tensor_content&&this._tensor.tensor_content.length>0?t.rawData=new DataView(this._tensor.tensor_content.buffer,this._tensor.tensor_content.byteOffset,this._tensor.tensor_content.byteLength):t.state="Tensor data is empty.";break;case tf.proto.DataType.DT_INT32:case tf.proto.DataType.DT_UINT32:this._tensor.tensor_content&&this._tensor.tensor_content.length>0?t.rawData=new DataView(this._tensor.tensor_content.buffer,this._tensor.tensor_content.byteOffset,this._tensor.tensor_content.byteLength):this._tensor.int_val&&this._tensor.int_val.length==t.size?t.data=this._tensor.int_val:t.state="Tensor data is empty.";break;case tf.proto.DataType.DT_STRING:this._tensor.tensor_content&&this._tensor.tensor_content.length>0?t.state="Tensor data type is not implemented.":this._tensor.string_val&&this._tensor.string_val.length==t.size?t.data=this._tensor.string_val:t.state="Tensor data is empty.";break;case tf.proto.DataType.DT_BOOL:t.state="Tensor data type 'bool' is not implemented.";break;default:t.state="Tensor data type '"+this._tensor.dtype+"' is not implemented."}return t.shape=e.dim.map((t=>t.size)),t}_decode(t,e){let s=t.shape;0==s.length&&(s=[1]);const n=[],o=s[e];if(e==s.length-1)for(let e=0;e<o;e++){if(t.count>t.limit)return n.push("..."),n;if(t.data){const e=t.data[t.index++];n.push(this._tensor.dtype==tf.proto.DataType.DT_STRING?tf.Utility.decodeText(e):e),t.count++}else if(t.rawData)switch(this._tensor.dtype){case tf.proto.DataType.DT_FLOAT:n.push(t.rawData.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case tf.proto.DataType.DT_INT32:n.push(t.rawData.getInt32(t.index,!0)),t.index+=4,t.count++;break;case tf.proto.DataType.DT_UINT32:n.push(t.rawData.getUint32(t.index,!0)),t.index+=4,t.count++;break;case tf.proto.DataType.DT_QINT8:n.push(t.rawData.getInt8(t.index,!0)),t.index+=1,t.count++;break;case tf.proto.DataType.DT_QUINT8:n.push(t.rawData.getUint8(t.index,!0)),t.index+=1,t.count++}}else for(let r=0;r<o;r++){if(t.count>t.limit)return n.push("..."),n;n.push(this._decode(t,e+1,s))}return 0==t.shape.length?n[0]:n}static formatDataType(t){if(!tf.Tensor.dataType){tf.Tensor.dataType={};for(let t of Object.keys(tf.proto.DataType)){const e=tf.proto.DataType[t];t=t.startsWith("DT_")?t.substring(3):t,tf.Tensor.dataType[e]=t.toLowerCase()}tf.Tensor.dataType[tf.proto.DataType.DT_HALF]="float16",tf.Tensor.dataType[tf.proto.DataType.DT_FLOAT]="float32",tf.Tensor.dataType[tf.proto.DataType.DT_DOUBLE]="float64",tf.Tensor.dataType.DT_FLOAT="float32"}return tf.Tensor.dataType[t]||"?"}},tf.TensorType=class{constructor(t,e){this._dtype=t,this._shape=new tf.TensorShape(e)}get dataType(){return this._dtype?tf.Tensor.formatDataType(this._dtype):"?"}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},tf.TensorShape=class{constructor(t){this._shape=t}get dimensions(){return this._shape&&this._shape.dim?this._shape.unknown_rank?null:0==this._shape.dim.length?[]:1!=this._shape.dim.length||this._shape.dim[0].size?this._shape.dim.map((t=>t.size&&-1!=t.size?t.size:"?")):[0]:null}toString(){return this._shape&&this._shape.dim?this._shape.unknown_rank?"[-]":0==this._shape.dim.length?"":1!=this._shape.dim.length||this._shape.dim[0].size?"["+this._shape.dim.map((t=>t.size&&-1!=t.size?t.size.toString():"?")).join(",")+"]":"[0]":"?"}},tf.TensorBundle=class{static open(t,e,s,n){const o=e.toLowerCase().endsWith(".index")?2:1;if(t.length<=48)throw new tf.Error("Invalid index file size.");const r=new tf.TensorBundle.BinaryReader(t,n);r.seek(-8);const a=[87,251,128,139,36,117,71,219];if(!r.bytes(8).every(((t,e)=>t===a[e])))throw new tf.Error("Invalid table signature.");r.seek(-48),r.varint64(),r.varint64();const i=r.varint64(),p=r.varint64();r.seek(i);const h=r.clone(p),u=r.byte();if(0!==u)throw new tf.Error("Unsupported block compression '"+u+"'.");h.seek(-4);const f=h.int32();h.seek(-4-4*f);const l=[];for(let t=0;t<f;t++)l.push(h.int32());const c=new TextDecoder,_=new Map;for(let t=0;t<f;t++){h.seek(l[t]),h.varint32();const e=h.varint32(),s=h.varint32();h.skip(e);const n=h.clone(s);r.seek(n.varint64());const o=r.clone(n.varint64());let a="";for(;!o.end();){const t=o.varint32(),e=o.varint32(),s=o.varint32();if(0===t&&0===e&&0===s)break;a=a.substring(0,t),a+=c.decode(o.bytes(e));const n=o.bytes(s);_.set(a,n)}}if(!_.has(""))throw new tf.Error("Bundle header not available.");if(1===o)return Promise.resolve(new tf.TensorBundle(o,_,[]));const d=_.get(""),m=protobuf.Reader.create(d),g=tf.proto.BundleHeaderProto.decode(m).num_shards,y=[];for(let t=0;t<g;t++){const n=("0000"+t).slice(-5),o=("0000"+g).slice(-5),r=e.split(".");r.pop();const a=r.join(".")+".data-"+n+"-of-"+o;y.push(s.request(a,null))}return Promise.all(y).then((t=>new tf.TensorBundle(o,_,t))).catch((t=>(n.exception(t,!1),new tf.TensorBundle(o,_,null))))}constructor(t,e,s){switch(this._format=t,this._tensors=[],t){case 1:{const t=e.get(""),s=protobuf.Reader.create(t),n=tf.proto.SavedTensorSlices.decode(s),o=new Map;for(const t of e)if(""!==t[0]&&"global_step"!==t[0]){const e=protobuf.Reader.create(t[1]),s=tf.proto.SavedTensorSlices.decode(e),n=s.data.name,r=s.data.data;if(o.has(n)){const t=o.get(n);null!==t&&(r[t.key]&&r[t.key].length>0?t.value=t.value.concat(r[t.key]):o.set(n,null))}else if(r.tensor_content&&r.tensor_content.length>0)o.set(n,{key:"tensor_content",value:r.tensor_content});else{const t=Object.keys(r).filter((t=>t.endsWith("_val")&&r[t]&&r[t].length>0));o.set(n,1==t.length?{key:t[0],value:r[t[0]]}:null)}}for(const t of n.meta.tensor)if("global_step"!==t.name){const e=new tf.proto.TensorProto;e.dtype=t.type,e.tensor_shape=t.shape;const s=o.get(t.name);s&&(e[s.key]=s.value),this._tensors.push(new tf.Tensor(e,t.name,null))}break}case 2:e.forEach(((t,e)=>{if(""!==e){const n=protobuf.Reader.create(t),o=tf.proto.BundleEntryProto.decode(n),r=new tf.proto.TensorProto;r.dtype=o.dtype,r.tensor_shape=o.shape;const a=o.offset instanceof long.Long?o.offset.toNumber():o.offset,i=o.size instanceof long.Long?o.size.toNumber():o.size;s&&(r.tensor_content=s[o.shard_id].slice(a,a+i)),this._tensors.push(new tf.Tensor(r,e,null))}}))}}get format(){return this._format}get tensors(){return this._tensors}},tf.TensorBundle.BinaryReader=class{constructor(t){t&&(this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0,this._start=0,this._end=this._buffer.length)}seek(t){if(this._position=t>=0?this._start+t:this._end+t,this._position>this._end)throw new tf.Error("Expected "+(this._position-this._end)+" more bytes. The file might be corrupted. Unexpected end of file.")}skip(t){if(this._position+=t,this._position>this._end)throw new tf.Error("Expected "+(this._position-this._end)+" more bytes. The file might be corrupted. Unexpected end of file.")}end(){return this._position>=this._end}clone(t){const e=new tf.TensorBundle.BinaryReader;return e._buffer=this._buffer,e._dataView=this._dataView,e._start=this._position,e._position=this._position,this.skip(t),e._end=this._position,e}bytes(t){const e=this._position;return this.skip(t),this._buffer.subarray(e,this._position)}byte(){const t=this._position;return this.skip(1),this._dataView.getUint8(t)}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}varint32(){return this.varint64()}varint64(){let t=0;for(let e=0;e<=63;e+=7){const s=this.byte();if(!(128&s)){t|=s<<e;break}t|=(127&s)<<e}return t}},tf.GraphMetadata=class{constructor(t){this._metadata=t,this._map={},this._attributeCache={}}type(t){var e=this._metadata.type(t);return e||(e=this._map[t]),e}attribute(t,e){let s=this._attributeCache[t];if(!s){s={};const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const t of e.attributes)s[t.name]=t;this._attributeCache[t]=s}return s[e]||null}getAttributeVisibleMap(t){const e=this.type(t);if(e){let t=e.__visisbleAttributeMap__;if(!t){if(t={},e.inputs)for(const s of e.inputs)s.typeAttr?t[s.typeAttr]=!0:s.typeListAttr&&(t[s.typeListAttr]=!0),s.numberAttr&&(t[s.numberAttr]=!0);if(e.outputs)for(const s of e.outputs)s.typeAttr?t[s.typeAttr]=!0:s.typeListAttr&&(t[s.typeListAttr]=!0),s.numberAttr&&(t[s.numberAttr]=!0);e.__visisbleAttributeMap__=t}return t}return{}}static _formatAttributeValue(t){if(null==t)return null;if(t&&long.Long.isLong(t)&&(t=t.toNumber()),Array.isArray(t))return t.map((t=>tf.GraphMetadata._formatAttributeValue(t)));if(t===Object(t))switch(t.type){case"type":return tf.Tensor.formatDataType(t.value);case"shape":case"tensor":return t.value}return"string"==typeof t?'"'+t+'"':t.toString()}},tf.Metadata=class{static open(t){return tf.Metadata._metadata?Promise.resolve(tf.Metadata._metadata):t.request(null,"tf-metadata.json","utf-8").then((t=>(tf.Metadata._metadata=new tf.Metadata(t),tf.Metadata._metadata))).catch((()=>(tf.Metadata._metadata=new tf.Metadata(null),tf.Metadata._metadata)))}constructor(t){if(this._map={},t&&t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map[t.name]=t.schema)}}type(t){return this._map[t]}},tf.Utility=class{static decodeText(t){return"string"==typeof t?t:0===t.length?"":(tf.Utility._utf8Decoder=tf.Utility._utf8Decoder||new TextDecoder("utf-8"),tf.Utility._utf8Decoder.decode(t))}},tf.Error=class extends Error{constructor(t){super(t),this.name="Error loading TensorFlow model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=tf.ModelFactory);