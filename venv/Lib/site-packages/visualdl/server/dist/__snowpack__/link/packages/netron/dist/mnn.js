var mnn=mnn||{},base=base||require("./base"),flatbuffers=flatbuffers||require("./flatbuffers");mnn.ModelFactory=class{match(e){return"mnn"==e.identifier.split(".").pop().toLowerCase()}open(e,t){return t.require("./mnn-schema").then((n=>mnn.Metadata.open(t).then((n=>{const a=e.identifier;try{mnn.schema=flatbuffers.get("mnn").MNN;const t=new flatbuffers.Reader(e.buffer),a=mnn.schema.Net.create(t);return new mnn.Model(n,a)}catch(e){t.exception(e,!1);const n=e&&e.message?e.message:e.toString();throw new mnn.Error(n.replace(/\.$/,"")+" in '"+a+"'.")}}))))}},mnn.Model=class{constructor(e,t){switch(t.sourceType){case mnn.schema.NetSource.CAFFE:this._source="Caffe";break;case mnn.schema.NetSource.TENSORFLOW:this._source="TensorFlow";break;case mnn.schema.NetSource.TFLITE:this._source="TensorFlow Lite";break;case mnn.schema.NetSource.ONNX:this._source="ONNX"}this._graphs=[new mnn.Graph(e,t)]}get format(){return"MNN v2"}get source(){return this._source||""}get graphs(){return this._graphs}},mnn.Graph=class{constructor(e,t){this._nodes=[],this._inputs=[],this._outputs=[];const n=new Set;for(let a=0;a<t.oplists.length;a++){const s=t.oplists[a];if(s.type===mnn.schema.OpType.Input){const e=[];for(let n=0;n<s.outputIndexes.length;n++){const a=s.outputIndexes[n],i=t.tensorName[a],r=t.extraTensorDescribe[a],m=r?r.blob:null,o=m?new mnn.TensorType(m.dataType,new mnn.TensorShape(m.dims)):null;e.push(new mnn.Argument(i,o,null))}this._inputs.push(new mnn.Parameter(s.name,!0,e))}else this._nodes.push(new mnn.Node(e,s,t));for(let e=0;e<s.inputIndexes.length;e++){const t=s.inputIndexes[e];n.add(t)}}for(let e=0;e<t.tensorName.length;e++)if(!n.has(e)){const n=t.tensorName[e],a=t.extraTensorDescribe[e],s=a?a.blob:null,i=s?new mnn.TensorType(s.dataType,new mnn.TensorShape(s.dims)):null;this._outputs.push(new mnn.Parameter(n,!0,[new mnn.Argument(n,i,null)]))}}get name(){return""}get groups(){return!1}get nodes(){return this._nodes}get outputs(){return this._outputs}get inputs(){return this._inputs}},mnn.Node=class{constructor(e,t,n){this._metadata=e,this._type=mnn.Utility.enum("OpType",t.type)||"("+t.type.toString()+")",this._name=t.name||"",this._attributes=[],this._inputs=[],this._outputs=[],this._chains=[];const a=[];for(let e=0;e<t.inputIndexes.length;e++){const s=t.inputIndexes[e],i=n.tensorName[s];a.push(new mnn.Argument(i,null,null))}this._inputs.push(new mnn.Parameter("input",!0,a));const s=[];for(let e=0;e<t.outputIndexes.length;e++){const a=t.outputIndexes[e],i=n.tensorName[a];s.push(new mnn.Argument(i,null,null))}this._outputs.push(new mnn.Parameter("output",!0,s));const i=t.main;if(i){const t=new Set;if(i instanceof mnn.schema.Blob){const e=new mnn.TensorType(i.dataType,new mnn.TensorShape(i.dims));let t=null;switch(e.dataType){case"int32":t=i.int32s;break;case"float32":t=i.float32s}this._inputs.push(new mnn.Parameter("value",!0,[new mnn.Argument("",null,new mnn.Tensor("Blob",e,t))]))}else if(i instanceof mnn.schema.Convolution2D){const e=i.common,n=e.outputCount,a=e.inputCount,s=e.kernelX,r=e.kernelY;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"weight",[n,a,s,r],i.weight),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[n],i.bias),t.add("weight"),t.add("bias")}else if(i instanceof mnn.schema.InnerProduct){const e=i.outputCount,n=i.weightSize/e;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"weight",[e,n],i.weight),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[e],i.bias),t.add("weight"),t.add("bias")}else if(i instanceof mnn.schema.Scale){const e=i.channels;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"scale",[e],i.scaleData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[e],i.biasData),t.add("scaleData"),t.add("biasData")}else if(i instanceof mnn.schema.BatchNorm){const e=i.channels;this._buildTensor(mnn.schema.DataType.DT_FLOAT,"mean",[e],i.meanData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"slope",[e],i.slopeData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"variance",[e],i.varData),this._buildTensor(mnn.schema.DataType.DT_FLOAT,"bias",[e],i.biasData),t.add("slopeData"),t.add("meanData"),t.add("varData"),t.add("biasData")}else i instanceof mnn.schema.PRelu?(this._buildTensor(mnn.schema.DataType.DT_FLOAT,"slope",[i.slopeCount],i.slope),t.add("slope")):i instanceof mnn.schema.Normalize&&(this._buildTensor(mnn.schema.DataType.DT_FLOAT,"scale",[i.scale.length],i.scale),t.add("scale"));t.size>0&&this._buildAttributes(e,i,t,this._attributes)}}_buildTensor(e,t,n,a){this._inputs.push(new mnn.Parameter(t,!0,[new mnn.Argument("",null,new mnn.Tensor("Weight",new mnn.TensorType(e,new mnn.TensorShape(n)),a))]))}_buildAttributes(e,t,n,a){if(t)for(const s of Object.keys(t)){if(n&&n.has(s))continue;const i=t[s];if(Object.keys(mnn.schema).find((e=>mnn.schema[e].prototype&&i instanceof mnn.schema[e])))this._buildAttributes(e,i,null,a);else if(i){const t=e.attribute(this.type,s);a.push(new mnn.Attribute(t,s,i))}}}get type(){return this._type}get name(){return this._name}get domain(){return null}get metadata(){return this._metadata.type(this.type)}get group(){return null}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chains}get attributes(){return this._attributes}},mnn.Attribute=class{constructor(e,t,n,a){if(this._type=null,this._value=ArrayBuffer.isView(n)?Array.from(n):n,this._name=t,this._visible=a,e&&e.type){this._type=e.type;const t=mnn.schema[this._type+"Name"];t&&(this._value=t[this._value])}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},mnn.Parameter=class{constructor(e,t,n){this._name=e,this._visible=t,this._arguments=n}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},mnn.Argument=class{constructor(e,t,n){this._name=e,this._type=t||null,this._initializer=n||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},mnn.Tensor=class{constructor(e,t,n){this._kind=e,this._type=t,this._data=n.slice(0)}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state}get value(){const e=this._context();return e.state?null:(e.limit=Number.MAX_SAFE_INTEGER,this._decode(e,0))}toString(){const e=this._context();if(e.state)return"";e.limit=1e4;const t=this._decode(e,0);return JSON.stringify(t,null,4)}_context(){const e={state:null};return this._data&&0!==this._data.length?(e.index=0,e.count=0,e.dataType=this._type.dataType,e.dimensions=this._type.shape.dimensions,e.data=this._data,e):(e.state="Tensor data is empty.",e)}_decode(e,t){let n=e.dimensions;0==n.length&&(n=[1]);const a=[],s=n[t];if(t==n.length-1)for(let t=0;t<s;t++){if(e.count>e.limit)return a.push("..."),a;a.push(e.data[e.index]),e.index++,e.count++}else for(let n=0;n<s;n++){if(e.count>e.limit)return a.push("..."),a;a.push(this._decode(e,t+1))}return 0==e.dimensions.length?a[0]:a}},mnn.TensorType=class{constructor(e,t){switch(e){case mnn.schema.DataType.DT_INVALID:this._dataType="?";break;case mnn.schema.DataType.DT_FLOAT:this._dataType="float32";break;case mnn.schema.DataType.DT_DOUBLE:this._dataType="float64";break;case mnn.schema.DataType.DT_INT32:this._dataType="int32";break;case mnn.schema.DataType.DT_UINT8:this._dataType="uint8";break;case mnn.schema.DataType.DT_INT16:this._dataType="int16";break;case mnn.schema.DataType.DT_INT8:this._dataType="int8";break;case mnn.schema.DataType.DT_STRING:this._dataType="string";break;case mnn.schema.DataType.DT_COMPLEX64:this._dataType="complex64";break;case mnn.schema.DataType.DT_INT64:this._dataType="int64";break;case mnn.schema.DataType.DT_BOOL:this._dataType="boolean";break;case mnn.schema.DataType.DT_QINT8:this._dataType="qint8";break;case mnn.schema.DataType.DT_QUINT8:this._dataType="quint8";break;case mnn.schema.DataType.DT_QINT32:this._dataType="qint32";break;case mnn.schema.DataType.DT_BFLOAT16:this._dataType="bfloat16";break;case mnn.schema.DataType.DT_QINT16:this._dataType="qint16";break;case mnn.schema.DataType.DT_QUINT16:this._dataType="quint16";break;case mnn.schema.DataType.DT_UINT16:this._dataType="uint16";break;case mnn.schema.DataType.DT_COMPLEX128:this._dataType="complex128";break;case mnn.schema.DataType.DT_HALF:this._dataType="float16";break;case mnn.schema.DataType.DT_RESOURCE:this._dataType="resource";break;case mnn.schema.DataType.DT_VARIANT:this._dataType="variant";break;default:throw new mnn.Error("Unknown data type '"+JSON.stringify(e)+"'.")}this._shape=t}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},mnn.TensorShape=class{constructor(e){this._dimensions=Array.from(e)}get dimensions(){return this._dimensions}toString(){return this._dimensions&&this._dimensions.length>0?"["+this._dimensions.map((e=>e?e.toString():"?")).join(",")+"]":""}},mnn.Metadata=class{static open(e){return mnn.Metadata._metadata?Promise.resolve(mnn.Metadata._metadata):e.request(null,"mnn-metadata.json","utf-8").then((e=>(mnn.Metadata._metadata=new mnn.Metadata(e),mnn.Metadata._metadata))).catch((()=>(mnn.Metadata._metadata=new mnn.Metadata(null),mnn.Metadata._metadata)))}constructor(e){if(this._map=new Map,e){const t=JSON.parse(e);if(t)for(const e of t)e.name&&e.schema&&(e.schema.name=e.name,this._map.set(e.name,e.schema))}}type(e){return this._map.has(e)?this._map.get(e):null}attribute(e,t){const n=this.type(e);if(n){let e=n.attributeMap;if(!e){if(e={},n.attributes)for(const t of n.attributes)e[t.name]=t;n.attributeMap=e}const a=e[t];if(a)return a}return null}},mnn.Utility=class{static enum(e,t){const n=e&&mnn.schema?mnn.schema[e]:void 0;if(n){if(mnn.Utility._enumKeyMap=mnn.Utility._enumKeyMap||new Map,!mnn.Utility._enumKeyMap.has(e)){const t=new Map;for(const e of Object.keys(n))t.set(n[e],e);mnn.Utility._enumKeyMap.set(e,t)}const a=mnn.Utility._enumKeyMap.get(e);if(a.has(t))return a.get(t)}return t}},mnn.Error=class extends Error{constructor(e){super(e),this.name="Error loading MNN model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=mnn.ModelFactory);