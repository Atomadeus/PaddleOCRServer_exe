var uff=uff||{},base=base||require("./base"),long=long||{Long:require("long")},protobuf=protobuf||require("./protobuf");uff.ModelFactory=class{match(t){const e=t.identifier,s=e.split(".").pop().toLowerCase();if("uff"===s||"pb"===s){const e=t.tags("pb");if(e.size>0&&e.has(1)&&0===e.get(1)&&e.has(2)&&0===e.get(2)&&e.has(3)&&2===e.get(3)&&e.has(4)&&2===e.get(4)&&e.has(5)&&2===e.get(5))return!0}if("pbtxt"===s||e.toLowerCase().endsWith(".uff.txt")){const e=t.tags("pbtxt");if(e.has("version")&&e.has("descriptors")&&e.has("graphs"))return!0}return!1}open(t,e){return e.require("./uff-proto").then((()=>{let s=null;const a=t.identifier;if("pbtxt"===a.split(".").pop().toLowerCase()||a.toLowerCase().endsWith(".uff.txt"))try{uff.proto=protobuf.get("uff").uff;const e=protobuf.TextReader.create(t.text);s=uff.proto.MetaGraph.decodeText(e)}catch(t){throw new uff.Error("File text format is not uff.MetaGraph ("+t.message+") in '"+a+"'.")}else try{uff.proto=protobuf.get("uff").uff;const e=protobuf.Reader.create(t.buffer);s=uff.proto.MetaGraph.decode(e)}catch(t){throw new uff.Error("File format is not uff.MetaGraph ("+t.message+") in '"+a+"'.")}return uff.Metadata.open(e).then((t=>{try{return new uff.Model(t,s)}catch(t){e.exception(t,!1);const s=t&&t.message?t.message:t.toString();throw new uff.Error(s.replace(/\.$/,"")+" in '"+a+"'.")}}))}))}},uff.Model=class{constructor(t,e){this._version=e.version,this._imports=e.descriptors.map((t=>t.id+" v"+t.version.toString())).join(", ");const s=new Map(e.referenced_data.map((t=>[t.key,t.value])));for(const t of e.graphs)for(const e of t.nodes)for(const t of e.fields)"ref"===t.value.type&&s.has(t.value.ref)&&(t.value=s.get(t.value.ref));this._graphs=e.graphs.map((e=>new uff.Graph(t,e)))}get format(){return"UFF"+(this._version?" v"+this._version.toString():"")}get imports(){return this._imports}get graphs(){return this._graphs}},uff.Graph=class{constructor(t,e){this._name=e.id,this._inputs=[],this._outputs=[],this._nodes=[];const s=new Map,a=new Map;for(const t of e.nodes){for(const e of t.inputs)a.set(e,a.has(e)?a.get(e)+1:1),s.set(e,new uff.Argument(e));s.has(t.id)||s.set(t.id,new uff.Argument(t.id))}for(let t=e.nodes.length-1;t>=0;t--){const n=e.nodes[t];if("Const"===n.operation&&0===n.inputs.length&&1===a.get(n.id)){const a={};for(const t of n.fields)a[t.key]=t.value;if(a.dtype&&a.shape&&a.values){const i=new uff.Tensor(a.dtype,a.shape,a.values);s.set(n.id,new uff.Argument(n.id,i.type,i)),e.nodes.splice(t,1)}}if("Input"===n.operation&&0===n.inputs.length){const t={};for(const e of n.fields)t[e.key]=e.value;const e=t.dtype&&t.shape?new uff.TensorType(t.dtype,t.shape):null;s.set(n.id,new uff.Argument(n.id,e,null))}}for(const a of e.nodes)"Input"!==a.operation?"MarkOutput"!==a.operation||1!==a.inputs.length?this._nodes.push(new uff.Node(t,a,s)):this._outputs.push(new uff.Parameter(a.id,[s.get(a.inputs[0])])):this._inputs.push(new uff.Parameter(a.id,[s.get(a.id)]))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},uff.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},uff.Argument=class{constructor(t,e,s){if("string"!=typeof t)throw new uff.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=s||null}get name(){return this._name}get type(){return this._type}get initializer(){return this._initializer}},uff.Node=class{constructor(t,e,s){this._name=e.id,this._operation=e.operation,this._metadata=t.type(e.operation),this._attributes=[],this._inputs=[],this._outputs=[];const a=t.type(e.operation);if(e.inputs&&e.inputs.length>0){let t=0;if(a&&a.inputs)for(const n of a.inputs)if(t<e.inputs.length||"optional"!=n.option){const a="variadic"==n.option?e.input.length-t:1,i=e.inputs.slice(t,t+a).map((t=>s.get(t)));t+=a,this._inputs.push(new uff.Parameter(n.name,i))}this._inputs=this._inputs.concat(e.inputs.slice(t).map(((e,a)=>{const n=t+a==0?"input":(t+a).toString();return new uff.Parameter(n,[s.get(e)])})))}this._outputs.push(new uff.Parameter("output",[s.get(e.id)]));for(const s of e.fields)this._attributes.push(new uff.Attribute(t.attribute(this._operation,s.key),s.key,s.value))}get name(){return this._name}get type(){return this._operation}get metadata(){return this._metadata}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},uff.Attribute=class{constructor(t,e,s){switch(this._name=e,s.type){case"s":this._value=s.s,this._type="string";break;case"s_list":this._value=s.s_list,this._type="string[]";break;case"d":this._value=s.d,this._type="float64";break;case"d_list":this._value=s.d_list.val,this._type="float64[]";break;case"i":this._value=s.i,this._type="int64";break;case"i_list":this._value=s.i_list.val,this._type="int64[]";break;case"b":this._value=s.b,this._type="boolean";break;case"b_list":this._value=s.b_list,this._type="boolean[]";break;case"blob":this._value=s.blob;break;case"dtype":this._value=new uff.TensorType(s,null).dataType;break;case"dim_orders_list":this._value=s.dim_orders_list.val;break;default:throw new uff.Error("Unknown attribute '"+e+"'format '"+JSON.stringify(s)+"'.")}}get type(){return this._type}get name(){return this._name}get value(){return this._value}},uff.Tensor=class{constructor(t,e,s){switch(this._type=new uff.TensorType(t,e),s.type){case"blob":this._data=s.blob;break;default:throw new uff.Error("Unknown values format '"+JSON.stringify(s.type)+"'.")}}get kind(){return"Const"}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0};return null==this._data||this._data.length>8&&40===this._data[0]&&46===this._data[1]&&46===this._data[2]&&46===this._data[3]&&41===this._data[this._data.length-1]&&46===this._data[this._data.length-2]&&46===this._data[this._data.length-3]&&46===this._data[this._data.length-4]?(t.state="Tensor data is empty.",t):(t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t)}_decode(t,e){const s=0==t.shape.length?[1]:t.shape,a=s[e],n=[];if(e==s.length-1)for(let e=0;e<a;e++){if(t.count>t.limit)return n.push("..."),n;switch(t.dataType){case"int8":n.push(t.data.getInt8(t.index)),t.index+=1,t.count++;break;case"int16":n.push(t.data.getInt16(t.index)),t.index+=2,t.count++;break;case"int32":n.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int64":n.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++;break;case"float16":n.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"float32":n.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++}}else for(let s=0;s<a;s++){if(t.count>t.limit)return n.push("..."),n;n.push(this._decode(t,e+1))}return 0==t.shape.length?n[0]:n}},uff.TensorType=class{constructor(t,e){if("dtype"!==t.type)throw new uff.Error("Unknown data type format '"+JSON.stringify(t.type)+"'.");switch(t.dtype){case uff.proto.DataType.DT_INT8:this._dataType="int8";break;case uff.proto.DataType.DT_INT16:this._dataType="int16";break;case uff.proto.DataType.DT_INT32:this._dataType="int32";break;case uff.proto.DataType.DT_INT64:this._dataType="int64";break;case uff.proto.DataType.DT_FLOAT16:this._dataType="float16";break;case uff.proto.DataType.DT_FLOAT32:this._dataType="float32";break;default:throw new uff.Error("Unknown data type '"+JSON.stringify(t)+"'.")}this._shape=e?new uff.TensorShape(e):null}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},uff.TensorShape=class{constructor(t){if("i_list"!==t.type)throw new uff.Error("Unknown shape format '"+JSON.stringify(t.type)+"'.");this._dimensions=t.i_list.val}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},uff.Metadata=class{static open(t){return uff.Metadata._metadata?Promise.resolve(uff.Metadata._metadata):t.request(null,"uff-metadata.json","utf-8").then((t=>(uff.Metadata._metadata=new uff.Metadata(t),uff.Metadata._metadata))).catch((()=>(uff.Metadata._metadata=new uff.Metadata(null),uff.Metadata._metadata)))}constructor(t){if(this._map=new Map,this._attributeCache=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map.set(t.name,t.schema))}}type(t){return this._map.get(t)}attribute(t,e){const s=t+":"+e;if(!this._attributeCache.has(s)){const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const s of e.attributes)this._attributeCache.set(t+":"+s.name,s);this._attributeCache.has(s)||this._attributeCache.set(s,null)}return this._attributeCache.get(s)}},uff.Error=class extends Error{constructor(t){super(t),this.name="Error loading UFF model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=uff.ModelFactory);