var pickle=pickle||{};pickle.Unpickler=class{constructor(e){this._reader=new pickle.Reader(e,0)}load(e,s){const t=this._reader,p=[];let i=[];const o=new Map;for(;t.position<t.length;){const c=t.byte();switch(c){case pickle.OpCode.PROTO:{const e=t.byte();if(e>5)throw new pickle.Error("Unsupported protocol version '"+e+"'.");break}case pickle.OpCode.GLOBAL:i.push([t.line(),t.line()].join("."));break;case pickle.OpCode.STACK_GLOBAL:i.push([i.pop(),i.pop()].reverse().join("."));break;case pickle.OpCode.PUT:{const e=parseInt(t.line(),10);o.set(e,i[i.length-1]);break}case pickle.OpCode.OBJ:{const s=i;i=p.pop(),i.push(e(s.pop(),s));break}case pickle.OpCode.GET:{const e=parseInt(t.line(),10);i.push(o.get(e));break}case pickle.OpCode.POP:i.pop();break;case pickle.OpCode.POP_MARK:i=p.pop();break;case pickle.OpCode.DUP:i.push(i[i.length-1]);break;case pickle.OpCode.PERSID:i.push(s(t.line()));break;case pickle.OpCode.BINPERSID:i.push(s(i.pop()));break;case pickle.OpCode.REDUCE:{const s=i.pop(),t=i.pop();i.push(e(t,s));break}case pickle.OpCode.NEWOBJ:{const s=i.pop(),t=i.pop();i.push(e(t,s));break}case pickle.OpCode.BINGET:i.push(o.get(t.byte()));break;case pickle.OpCode.LONG_BINGET:i.push(o.get(t.uint32()));break;case pickle.OpCode.BINPUT:o.set(t.byte(),i[i.length-1]);break;case pickle.OpCode.LONG_BINPUT:o.set(t.uint32(),i[i.length-1]);break;case pickle.OpCode.BININT:i.push(t.int32());break;case pickle.OpCode.BININT1:i.push(t.byte());break;case pickle.OpCode.LONG:i.push(parseInt(t.line(),10));break;case pickle.OpCode.BININT2:i.push(t.uint16());break;case pickle.OpCode.BINBYTES:i.push(t.bytes(t.int32()));break;case pickle.OpCode.SHORT_BINBYTES:i.push(t.bytes(t.byte()));break;case pickle.OpCode.FLOAT:i.push(parseFloat(t.line()));break;case pickle.OpCode.BINFLOAT:i.push(t.float64());break;case pickle.OpCode.INT:{const e=t.line();"01"==e?i.push(!0):"00"==e?i.push(!1):i.push(parseInt(e,10));break}case pickle.OpCode.EMPTY_LIST:case pickle.OpCode.EMPTY_TUPLE:case pickle.OpCode.EMPTY_SET:i.push([]);break;case pickle.OpCode.ADDITEMS:{const e=i;i=p.pop();const s=i[i.length-1];for(let t=0;t<e.length;t++)s.push(e[t]);break}case pickle.OpCode.DICT:{const e=i;i=p.pop();const s={};for(let t=0;t<e.length;t+=2)s[e[t]]=e[t+1];i.push(s);break}case pickle.OpCode.LIST:{const e=i;i=p.pop(),i.push(e);break}case pickle.OpCode.TUPLE:{const e=i;i=p.pop(),i.push(e);break}case pickle.OpCode.SETITEM:{const e=i.pop(),s=i.pop(),t=i[i.length-1];t.__setitem__?t.__setitem__(s,e):t[s]=e;break}case pickle.OpCode.SETITEMS:{const e=i;i=p.pop();const s=i[i.length-1];for(let t=0;t<e.length;t+=2)s.__setitem__?s.__setitem__(e[t],e[t+1]):s[e[t]]=e[t+1];break}case pickle.OpCode.EMPTY_DICT:i.push({});break;case pickle.OpCode.APPEND:{const e=i.pop();i[i.length-1].push(e);break}case pickle.OpCode.APPENDS:{const e=i;i=p.pop();const s=i[i.length-1];s.push.apply(s,e);break}case pickle.OpCode.STRING:{const e=t.line();i.push(e.substr(1,e.length-2));break}case pickle.OpCode.BINSTRING:i.push(t.string(t.uint32()));break;case pickle.OpCode.SHORT_BINSTRING:i.push(t.string(t.byte()));break;case pickle.OpCode.UNICODE:i.push(t.line());break;case pickle.OpCode.BINUNICODE:i.push(t.string(t.uint32(),"utf-8"));break;case pickle.OpCode.SHORT_BINUNICODE:i.push(t.string(t.byte(),"utf-8"));break;case pickle.OpCode.BUILD:{const e=i.pop();let s=i.pop();if(s.__setstate__)s.__setstate__.__call__?s.__setstate__.__call__([s,e]):s.__setstate__(e);else for(const t in e)s[t]=e[t];s.__read__&&(s=s.__read__(this)),i.push(s);break}case pickle.OpCode.MARK:p.push(i),i=[];break;case pickle.OpCode.NEWTRUE:i.push(!0);break;case pickle.OpCode.NEWFALSE:i.push(!1);break;case pickle.OpCode.LONG1:{const e=t.bytes(t.byte());let s=0;switch(e.length){case 0:s=0;break;case 1:s=e[0];break;case 2:s=e[1]<<8|e[0];break;case 3:s=e[2]<<16|e[1]<<8|e[0];break;case 4:s=e[3]<<24|e[2]<<16|e[1]<<8|e[0];break;default:s=Array.prototype.slice.call(e,0)}i.push(s);break}case pickle.OpCode.LONG4:i.push(t.bytes(t.uint32()));break;case pickle.OpCode.TUPLE1:i.push([i.pop()]);break;case pickle.OpCode.TUPLE2:{const e=i.pop(),s=i.pop();i.push([s,e]);break}case pickle.OpCode.TUPLE3:{const e=i.pop(),s=i.pop(),t=i.pop();i.push([t,s,e]);break}case pickle.OpCode.MEMOIZE:o.set(o.size,i[i.length-1]);break;case pickle.OpCode.FRAME:t.bytes(8);break;case pickle.OpCode.NONE:i.push(null);break;case pickle.OpCode.STOP:return i.pop();default:throw new pickle.Error("Unknown opcode '"+c+"'.")}}throw new pickle.Error("Unexpected end of file.")}read(e){return this._reader.bytes(e)}unescape(e,s){const t=e.length,p=new Uint8Array(t);if(s&&s==t){for(let t=0;t<s;t++)p[t]=e.charCodeAt(t);return p}let i=0,o=0;for(;i<t;){let s=e.charCodeAt(i++);if(92!==s||i>=t)p[o++]=s;else switch(s=e.charCodeAt(i++),s){case 39:p[o++]=39;break;case 92:p[o++]=92;break;case 34:p[o++]=34;break;case 114:p[o++]=13;break;case 110:p[o++]=10;break;case 116:p[o++]=9;break;case 98:p[o++]=8;break;case 88:case 120:{const s=i-1,c=o;for(let a=0;a<2;a++){if(i>=t){i=s,o=c,p[o]=92;break}let a=e.charCodeAt(i++);if(a=a>=65&&a<=70?a-55:a>=97&&a<=102?a-87:a>=48&&a<=57?a-48:-1,-1===a){i=s,o=c,p[o]=92;break}p[o]=p[o]<<4|a}o++;break}default:if(s<48||s>57)p[o++]=92,p[o++]=s;else{i--;const s=i,c=o;for(let a=0;a<3;a++){if(i>=t){i=s,o=c,p[o]=92;break}const a=e.charCodeAt(i++);if(a<48||a>57){i=s,o=c,p[o]=92;break}p[o]=p[o]<<3|a-48}o++}}}return p.slice(0,o)}},pickle.OpCode={MARK:40,EMPTY_TUPLE:41,STOP:46,POP:48,POP_MARK:49,DUP:50,BINBYTES:66,SHORT_BINBYTES:67,FLOAT:70,BINFLOAT:71,INT:73,BININT:74,BININT1:75,LONG:76,BININT2:77,NONE:78,PERSID:80,BINPERSID:81,REDUCE:82,STRING:83,BINSTRING:84,SHORT_BINSTRING:85,UNICODE:86,BINUNICODE:88,EMPTY_LIST:93,APPEND:97,BUILD:98,GLOBAL:99,DICT:100,APPENDS:101,GET:103,BINGET:104,LONG_BINGET:106,LIST:108,OBJ:111,PUT:112,BINPUT:113,LONG_BINPUT:114,SETITEM:115,TUPLE:116,SETITEMS:117,EMPTY_DICT:125,PROTO:128,NEWOBJ:129,TUPLE1:133,TUPLE2:134,TUPLE3:135,NEWTRUE:136,NEWFALSE:137,LONG1:138,LONG4:139,SHORT_BINUNICODE:140,BINUNICODE8:141,BINBYTES8:142,EMPTY_SET:143,ADDITEMS:144,FROZENSET:145,NEWOBJ_EX:146,STACK_GLOBAL:147,MEMOIZE:148,FRAME:149},pickle.Reader=class{constructor(e){e&&(this._buffer=e,this._dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),this._position=0),pickle.Reader._utf8Decoder=pickle.Reader._utf8Decoder||new TextDecoder("utf-8"),pickle.Reader._asciiDecoder=pickle.Reader._asciiDecoder||new TextDecoder("ascii")}get length(){return this._buffer.byteLength}get position(){return this._position}byte(){const e=this._position;return this.skip(1),this._dataView.getUint8(e)}bytes(e){const s=this._position;return this.skip(e),this._buffer.subarray(s,this._position)}uint16(){const e=this.position;return this.skip(2),this._dataView.getUint16(e,!0)}int32(){const e=this.position;return this.skip(4),this._dataView.getInt32(e,!0)}uint32(){const e=this.position;return this.skip(4),this._dataView.getUint32(e,!0)}float32(){const e=this.position;return this.skip(4),this._dataView.getFloat32(e,!0)}float64(){const e=this.position;return this.skip(8),this._dataView.getFloat64(e,!0)}skip(e){if(this._position+=e,this._position>this._buffer.length)throw new pickle.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}string(e,s){const t=this.bytes(e);return"utf-8"==s?pickle.Reader._utf8Decoder.decode(t):pickle.Reader._asciiDecoder.decode(t)}line(){const e=this._buffer.indexOf(10,this._position);if(-1==e)throw new pickle.Error("Could not find end of line.");const s=e-this._position,t=this.string(s,"ascii");return this.skip(1),t}},pickle.Error=class extends Error{constructor(e){super(e),this.name="Unpickle Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.Unpickler=pickle.Unpickler);