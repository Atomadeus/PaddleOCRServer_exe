var mxnet=mxnet||{},long=long||{Long:require("long")},zip=zip||require("./zip"),ndarray=ndarray||{};mxnet.ModelFactory=class{match(t){const e=t.identifier.split(".").pop().toLowerCase();if("model"===e||"mar"===e){if(t.entries("zip").length>0)return!0}else if("json"==e){const e=t.text;if(-1!=e.indexOf('"nodes":',0))try{const t=JSON.parse(e);if(t&&t.nodes&&t.arg_nodes&&t.heads)return!0}catch(t){}}else if("params"==e){const e=t.buffer,n=[18,1,0,0,0,0,0,0];if(e&&e.length>n.length&&n.every(((t,n)=>t==e[n])))return!0}return!1}open(t,e){const n=t.identifier,s=t.identifier.split(".").pop().toLowerCase();let r=null,a=null,i=null,o=null;switch(s){case"json":try{return r=JSON.parse(t.text),r&&r.nodes&&r.nodes.some((t=>t&&"tvm_op"==t.op))&&(i="TVM"),o=mxnet.ModelFactory._basename(n,"json","symbol"),o?t.request(o+"-0000.params",null).then((t=>this._openModel(n,i,null,r,null,t,e))).catch((()=>this._openModel(n,i,null,r,null,a,e))):this._openModel(n,i,null,r,null,null,e)}catch(t){throw e.exception(t,!1),new mxnet.Error(t.message),null}case"params":return a=t.buffer,o=mxnet.ModelFactory._basename(t.identifier,"params"),o?t.request(o+"-symbol.json","utf-8").then((t=>(r=JSON.parse(t),r&&r.nodes&&r.nodes.some((t=>t&&"tvm_op"==t.op))&&(i="TVM"),this._openModel(n,i,null,r,null,a,e)))).catch((()=>this._openModel(n,i,null,null,null,a,e))):this._openModel(n,i,null,null,null,a,e);case"mar":case"model":{const s=new Map;try{for(const e of t.entries("zip"))s.set(e.name,e)}catch(t){throw new mxnet.Error("Failed to decompress Zip archive. "+t.message)}let o=s.get(s.has("MANIFEST.json")?"MANIFEST.json":"MAR-INF/MANIFEST.json"),h="";if(!o){const e=Array.from(s.keys()).filter((t=>t.endsWith("/"))).filter((t=>s.get(t+"MANIFEST.json")));if(1!=e.length)throw new mxnet.Error("Manifest not found in '"+t.identifier+"'.");h=e[0],o=s.get(h+"MANIFEST.json")}const l=new TextDecoder("utf-8");let u=null;try{u=JSON.parse(l.decode(o.data))}catch(t){throw new mxnet.Error("Failed to read manifest. "+t.message)}let p=null,d=null,c=null,m=null;if(u.Model){if(p=u.Model["Model-Format"],p&&"MXNet-Symbolic"!=p)throw new mxnet.Error("Model format '"+p+"' not supported.");if(i="MXNet Model Server",u["Model-Archive-Version"]&&(i+=" v"+u["Model-Archive-Version"].toString()),!u.Model.Symbol)throw new mxnet.Error("Manifest does not contain symbol entry.");d=s.get(h+u.Model.Symbol),u.Model.Signature&&(c=s.get(h+u.Model.Signature)),u.Model.Parameters&&(m=s.get(h+u.Model.Parameters))}else{if(!u.model)throw new mxnet.Error("Manifest does not contain model.");if(i="MXNet Model Archive",u.specificationVersion&&(i+=" v"+u.specificationVersion.toString()),u.model.modelName){d=s.get(h+u.model.modelName+"-symbol.json");let t=null;for(t of Array.from(s.keys()))if(t=t.substring(h.length),t.endsWith(".params")&&t.startsWith(u.model.modelName)){m=s.get(t);break}if(!d&&!m)for(t of Object.keys(s))if(t=t.substring(h.length),t.endsWith(".params")){m=s.get(t);break}}}if(!d&&!m)throw new mxnet.Error("Model does not contain symbol entry.");try{d&&(r=JSON.parse(l.decode(d.data)))}catch(t){throw new mxnet.Error("Failed to load symbol entry."+t.message)}m&&(a=m.data);let _=null;try{c&&(_=JSON.parse(l.decode(c.data)))}catch(t){}try{return this._openModel(n,i,u,r,_,a,e)}catch(t){const e=t&&t.message?t.message:t.toString();throw new mxnet.Error(e.replace(/\.$/,"")+" in '"+n+"'.")}}default:throw new mxnet.Error("Unsupported file extension.")}}_openModel(t,e,n,s,r,a,i){return mxnet.Metadata.open(i).then((o=>{const h=new Map;if(a)try{const t=new ndarray.Stream(a);for(const e of Object.keys(t.arrays)){const n=e.startsWith("arg:")||e.startsWith("aux:")?e.substring(4):e;h.set(n,t.arrays[e])}}catch(t){}try{return new mxnet.Model(o,e,n,s,r,h)}catch(e){i.exception(e,!1);const n=e&&e.message?e.message:e.toString();throw new mxnet.Error(n.replace(/\.$/,"")+" in '"+t+"'.")}}))}static _basename(t,e,n){const s=t.split(".");if(s.length>=2&&s.pop().toLowerCase()===e){const t=s.join(".").split("-");if(t.length>=2){const e=t.pop();if(n){if(e!=n)return null}else for(let t=0;t<e.length;t++){const n=e.charAt(t);if(!(n>="0"&&n<="9"||n>="A"&&n<="Z"||n>="a"&&n<="z"))return null}return t.join("-")}}return null}},mxnet.Model=class{constructor(t,e,n,s,r,a){if(!s&&!a)throw new mxnet.Error("JSON symbol data not available.");if(s){if(!Object.prototype.hasOwnProperty.call(s,"nodes"))throw new mxnet.Error("JSON file does not contain an MXNet 'nodes' property.");if(!Object.prototype.hasOwnProperty.call(s,"arg_nodes"))throw new mxnet.Error("JSON file does not contain an MXNet 'arg_nodes' property.");if(!Object.prototype.hasOwnProperty.call(s,"heads"))throw new mxnet.Error("JSON file does not contain an MXNet 'heads' property.")}if(n){if(n.Model&&n.Model["Model-Name"]&&(this._name=n.Model["Model-Name"]),n.Model&&n.Model.Description&&this._name!=n.Model.Description&&(this._description=n.Model.Description),n.Engine&&n.Engine.MXNet){const t=mxnet.Model._convert_version(n.Engine.MXNet);this._runtime="MXNet v"+(t||n.Engine.MXNet.toString())}if(n.License&&(this._license=n.License),n.model&&n.model.modelName&&(this._name=n.model.modelName),n.model&&n.model.modelVersion&&(this._version=n.model.modelVersion),n.model&&n.model.modelName&&this._name!=n.model.description&&(this._description=n.model.description),n.runtime&&(this._runtime=n.runtime),n.engine&&n.engine.engineName){const t=n.engine.engineVersion?n.engine.engineName+" "+n.engine.engineVersion:n.engine.engineName;this._runtime=this._runtime?this._runtime+" ("+t+")":t}n.publisher&&n.publisher.author&&(this._author=n.publisher.author,n.publisher.email&&(this._author=this._author+" <"+n.publisher.email+">")),n.license&&(this._license=n.license)}if(this._format=e,!this._format&&s&&s.attrs&&s.attrs.mxnet_version){const t=mxnet.Model._convert_version(s.attrs.mxnet_version);t&&(this._format="MXNet v"+t)}this._format||(this._format="MXNet"),this._graphs=[],this._graphs.push(new mxnet.Graph(t,n,s,r,a))}get format(){return this._format}get name(){return this._name}get version(){return this._version}get description(){return this._description}get author(){return this._author}get license(){return this._license}get runtime(){return this._runtime}get graphs(){return this._graphs}static _convert_version(t){if(Array.isArray(t)&&2==t.length&&"int"==t[0]){const e=Math.floor(t[1]/1e4)%100,n=Math.floor(t[1]/100)%100,s=Math.floor(t[1])%100;return[e.toString(),n.toString(),s.toString()].join(".")}return null}},mxnet.Graph=class{constructor(t,e,n,s,r){this._metadata=t,this._nodes=[],this._inputs=[],this._outputs=[];const a=new Map;if(r)for(const t of r){const e=t[0],n=t[1];a.set(e,new mxnet.Tensor("Initializer",e,new mxnet.TensorType(n.dataType,new mxnet.TensorShape(n.shape.dimensions)),n.data))}if(n){const t=n.nodes,e={};if(s&&s.inputs)for(const t of s.inputs)e[t.data_name]=t;const r={};if(s&&s.outputs)for(const t of s.outputs)r[t.data_name]=t;for(const e of t)e.outputs=[];for(const e of t)e.inputs=e.inputs.map((e=>mxnet.Graph._updateOutput(t,e)));const i={};for(const e of t)for(const t of e.outputs)i[t]=(i[t]||0)+1;const o={};for(const e of n.arg_nodes)o[e]=e<t.length?t[e]:null;for(let e=0;e<n.heads.length;e++){const s=n.heads[e],a=mxnet.Graph._updateOutput(t,s),i=t[a[0]]?t[a[0]].name:"output"+(0==e?"":(e+1).toString());let o=null;const h=r[i];h&&h.data_shape&&(o=new mxnet.TensorType(-1,new mxnet.TensorShape(h.data_shape))),this._outputs.push(new mxnet.Parameter(i,[new mxnet.Argument("["+a.join(",")+"]",o,null)]))}const h={};for(const e of t.filter(((t,e)=>!o[e])))this._nodes.push(new mxnet.Node(this._metadata,e,o,h,a));for(const t of Object.keys(o)){const n=o[t];if(n&&(!n.inputs||0==n.inputs.length)&&n.outputs&&1==n.outputs.length){const t=n.outputs[0],s=n.name;let r=null;const a=e[s];a&&a.data_shape&&(r=new mxnet.TensorType(-1,new mxnet.TensorShape(a.data_shape))),this._inputs.push(new mxnet.Parameter(s,[new mxnet.Argument("["+t.join(",")+"]",r)]))}}}else if(r){let e=null;const n=[];let s=Object.keys(r).every((t=>-1!=t.indexOf("_")))?"_":"";if(0==s.length&&(s=Object.keys(r).every((t=>-1!=t.indexOf(".")))?".":""),!(s.length>0))throw new mxnet.Error("Unsupported key format in params.");{const t={};for(const a of Object.keys(r)){const r=a.split(s);let i=r.pop();(a.endsWith("moving_mean")||a.endsWith("moving_var"))&&(i=[r.pop(),i].join(s));const o=r.join(s);e=t[o],e||(e={name:o,op:"Weights",params:[]},t[o]=e,n.push(e)),t[o].params.push({name:i,id:a})}}for(e of n)this._nodes.push(new mxnet.Node(t,e,{},{},r))}}get name(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}static _updateOutput(t,e){const n=e[0],s=t[n],r=e[1];if(s)for(;r>=s.outputs.length;)s.outputs.push([n,s.outputs.length]);return[n,r]}},mxnet.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},mxnet.Argument=class{constructor(t,e,n){if("string"!=typeof t)throw new mxnet.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=n||null}get name(){return this._initializer?this._initializer.name:this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},mxnet.Node=class{constructor(t,e,n,s,r){this._metadata=t,this._type=e.op,this._name=e.name,this._attributes=[],this._inputs=[],this._outputs=[];const a=e.attrs||e.attr||e.param;if(a){"tvm_op"==this._type&&a.func_name&&(this._type=a.func_name);for(const t of Object.keys(a))"tvm_op"!=this._type&&"func_name"!=t&&this._attributes.push(new mxnet.Attribute(this._metadata,this.type,t,a[t]))}let i=null;const o=t.type(this.type);if(e.inputs){let a=e.inputs;"RNN"==this._type&&(a=a.map((t=>{const e=t[0],s=n[e];return s&&"null"==s.op&&s.name&&s.name.endsWith("_parameters")&&s.attr&&s.attr.__init__?(this._attributes.push(new mxnet.Attribute(this._metadata,this.type,s.name,s.attr.__init__)),delete n[e],null):t})),a=a.filter((t=>null!=t)));const h={};for(const e of a){const a="["+e.join(",")+"]";if(i=s[a],!i){const s=e[0],a=n[s];if(a&&a.name&&(!a.inputs||0==a.inputs.length)&&a.outputs&&1==a.outputs.length)if(i=r.get(a.name)||null,i)delete n[s];else{let e=this._name;if(e.endsWith("_fwd")&&(e=e.slice(0,-3)),a.name&&(a.name.startsWith(e+"_")||a.name.startsWith(e+"."))){let e=-1,r=[];if(a.attrs&&a.attrs.__dtype__&&a.attrs.__shape__)try{e=parseInt(a.attrs.__dtype__),r=JSON.parse("["+a.attrs.__shape__.replace("(","").replace(")","").split(" ").join("").split(",").map((t=>t||'"?"')).join(",")+"]")}catch(t){}let o=null;o=-1!==e||r.length>0?new mxnet.TensorType(e,new mxnet.TensorShape(r)):new mxnet.TensorType(-1,new mxnet.TensorShape(null)),i=new mxnet.Tensor("Initializer",a.name,o,null),delete n[s]}}}i&&(h[a]=i,s[a]=i)}let l=0;if(o&&o.inputs)for(const t of o.inputs)if(l<a.length||"optional"!=t.option){const e="variadic"==t.option?a.length-l:1,n=[];for(const s of a.slice(l,l+e)){const e="["+s.join(",")+"]";""==e&&"optional"==t.option||n.push(new mxnet.Argument(e,t.type,h[e]))}this._inputs.push(new mxnet.Parameter(t.name,n)),l+=e}l<a.length&&(this._inputs=this._inputs.concat(a.slice(l).map(((t,e)=>{const n="["+t.join(",")+"]";return new mxnet.Parameter((l+e).toString(),[new mxnet.Argument(n,null,h[n])])}))))}if(e.outputs){const t=e.outputs;let n=0;if(o&&o.outputs)for(const e of o.outputs)if(n<t.length||"optional"!=e.option){const s=[],r="variadic"==e.option?t.length-n:1;for(const e of t.slice(n,n+r))s.push(new mxnet.Argument("["+e.join(",")+"]",null,null));this._outputs.push(new mxnet.Parameter(e.name,s)),n+=r}n<t.length&&(this._outputs=this._outputs.concat(t.slice(n).map(((t,e)=>new mxnet.Parameter((n+e).toString(),[new mxnet.Argument("["+t.join(",")+"]",null,null)])))))}if(e.params)for(const t of e.params)this._inputs.push(new mxnet.Parameter(t.name,[new mxnet.Argument(t.id,null,r.get(t.id)||null)]))}get type(){return this._type}get metadata(){return this._metadata.type(this._type)}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},mxnet.Attribute=class{constructor(t,e,n,s){let r;this._name=n,this._value=s;const a=t.attribute(e,n);if(a&&a.type)switch(a.type){case"boolean":switch(s){case"True":this._value=!0;break;case"False":this._value=!1}break;case"int32":r=Number.parseInt(this._value,10),this._value=Number.isNaN(this._value-r)?s:r;break;case"float32":case"float64":r=Number.parseFloat(this._value),this._value=Number.isNaN(this._value-r)?s:r;break;case"int32[]":if(this._value.length>2&&this._value.startsWith("(")&&this._value.endsWith(")")){let t=[];const e=this._value.substring(1,this._value.length-1).split(",").map((t=>t.trim())).map((t=>t.endsWith("L")?t.substring(0,t.length-1):t));for(const n of e)r=Number.parseInt(n,10),Number.isNaN(n-r)?t=null:null!=t&&t.push(r);null!=t&&(this._value=t)}}if(a)if(Object.prototype.hasOwnProperty.call(a,"visible")&&!a.visible)this._visible=!1;else if(Object.prototype.hasOwnProperty.call(a,"default")){let t=a.default;if(this._value==t)this._visible=!1;else if(Array.isArray(this._value)&&Array.isArray(t)){if(t=t.slice(0,t.length),t.length>1&&null==t[t.length-1])for(t.pop();t.length<this._value.length;)t.push(t[t.length-1]);this._value.every(((e,n)=>e==t[n]))&&(this._visible=!1)}}}get name(){return this._name}get type(){return this._type}get value(){return this._value}get visible(){return 0!=this._visible}},mxnet.Tensor=class{constructor(t,e,n,s){this._kind=t,this._name=e,this._type=n,this._data=s}get kind(){return"Initializer"}get name(){return this._name}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={state:null,index:0,count:0};return this._data?this._type||"?"!==this._type.dataType?this._type.shape.length<1?(t.state="Tensor has unknown shape.",t):(t.dataType=this._type.dataType,t.dimensions=this._type.shape.dimensions,t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t):(t.state="Tensor has no data type.",t):(t.state="Tensor data is empty.",t)}_decode(t,e){const n=[],s=t.dimensions[e];if(e==t.dimensions.length-1)for(let e=0;e<s;e++){if(t.count>t.limit)return n.push("..."),n;switch(t.dataType){case"float32":n.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float64":n.push(t.data.getFloat64(t.index,!0)),t.index+=8,t.count++;break;case"float16":n.push(mxnet.Tensor._decodeNumberFromFloat16(t.data.getUint16(t.index,!0))),t.index+=2,t.count++;break;case"uint8":n.push(t.data.getUint8(t.index,!0)),t.index+=1,t.count++;break;case"int32":n.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int8":n.push(t.data.getInt8(t.index,!0)),t.index+=1,t.count++;break;case"int64":n.push(new long.Long(t.data.getUint32(t.index,!0),t.data.getUint32(t.index+4,!0),!1)),t.index+=8,t.count++}}else for(let r=0;r<s;r++){if(t.count>t.limit)return n.push("..."),n;n.push(this._decode(t,e+1))}return n}static _decodeNumberFromFloat16(t){const e=(32768&t)>>15,n=(31744&t)>>10,s=1023&t;return 0==n?(e?-1:1)*Math.pow(2,-14)*(s/Math.pow(2,10)):31==n?s?NaN:1/0*(e?-1:1):(e?-1:1)*Math.pow(2,n-15)*(1+s/Math.pow(2,10))}},mxnet.TensorType=class{constructor(t,e){switch(t){case 0:this._dataType="float32";break;case 1:this._dataType="float64";break;case 2:this._dataType="float16";break;case 3:this._dataType="uint8";break;case 4:this._dataType="int32";break;case 5:this._dataType="int8";break;case 6:this._dataType="int64";break;case-1:this._dataType="?";break;default:throw new mxnet.Error("Unknown type '"+t+"'.")}this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},mxnet.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?0==this._dimensions.length?"":"["+this._dimensions.map((t=>t.toString())).join(",")+"]":""}},mxnet.Metadata=class{static open(t){return mxnet.Metadata._metadata?Promise.resolve(mxnet.Metadata._metadata):t.request(null,"mxnet-metadata.json","utf-8").then((t=>(mxnet.Metadata._metadata=new mxnet.Metadata(t),mxnet.Metadata._metadata))).catch((()=>(mxnet.Metadata._metadata=new mxnet.Metadata(null),mxnet.Metadata._metadata)))}constructor(t){if(this._map={},this._attributeCache={},t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map[t.name]=t.schema)}}type(t){return this._map[t]||null}attribute(t,e){let n=this._attributeCache[t];if(!n){n={};const e=this.type(t);if(e&&e.attributes)for(const t of e.attributes)n[t.name]=t;this._attributeCache[t]=n}return n[e]||null}},mxnet.Error=class extends Error{constructor(t){super(t),this.name="Error loading MXNet model."}},ndarray.Stream=class{constructor(t){this._arrays={};const e=new ndarray.Reader(t);if(!e.checkSignature([18,1,0,0,0,0,0,0]))throw new ndarray.Error("Invalid signature.");if(!e.checkSignature([0,0,0,0,0,0,0,0]))throw new ndarray.Error("Invalid reserved block.");const n=[];for(let t=e.uint64();t>0;t--)n.push(new ndarray.Array(e));const s=new TextDecoder("ascii"),r=[];for(let t=e.uint64();t>0;t--){const t=s.decode(e.read(e.uint64()));r.push(t)}if(r.length!=n.length)throw new ndarray.Error("Label count mismatch.");for(let t=0;t<r.length;t++)this._arrays[r[t]]=n[t]}get arrays(){return this._arrays}},ndarray.Array=class{constructor(t){ndarray.Array._dataTypeSizeTable=[4,8,2,1,4,1,8],t.checkSignature([201,250,147,249])?this._loadV2(t):t.checkSignature([200,250,147,249])?this._loadV1(t):this._loadV0(t)}_loadV2(t){let e=0;switch(t.uint32()){case 0:e=0;break;case 1:e=1;break;case 2:e=2}if(this.sshape=null,e>0&&(this.sshape=new ndarray.Shape(t,!0)),this._shape=new ndarray.Shape(t,!0),0==this._shape.dimensions.length)return;if(this._context=new ndarray.Context(t),this._dataType=t.uint32(),e>0)throw new ndarray.Error("Not implemented.");const n=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(n)}_loadV1(t){if(this._shape=new ndarray.Shape(t,!0),0==this._shape.dimensions.length)return;this._context=new ndarray.Context(t),this._dataType=t.uint32();const e=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(e)}_loadV0(t){this._shape=new ndarray.Shape(t,!1),this._context=new ndarray.Context(t),this._dataType=t.uint32();const e=(this._dataType<ndarray.Array._dataTypeSizeTable.length?ndarray.Array._dataTypeSizeTable[this._dataType]:0)*this._shape.size();this._data=t.read(e)}get dataType(){return this._dataType}get shape(){return this._shape}get data(){return this._data}},ndarray.Shape=class{constructor(t,e){const n=t.uint32();this._dimensions=[];for(let s=0;s<n;s++)this._dimensions.push(e?t.uint64():t.uint32())}get dimensions(){return this._dimensions}size(){return this._dimensions.reduce(((t,e)=>t*e))}},ndarray.Context=class{constructor(t){this._deviceType=t.uint32(),this._deviceId=t.uint32()}},ndarray.Reader=class{constructor(t){this._buffer=t,this._position=0,this._end=t.length}checkSignature(t){if(this._position+t.length<=this._end)for(let e=0;e<t.length;e++)if(this._buffer[this._position+e]!=t[e])return!1;return this._position+=t.length,!0}read(t){if(this._position+t>this._end)throw new ndarray.Error("Data not available.");const e=this._buffer.subarray(this._position,this._position+t);return this._position+=t,e}uint16(){if(this._position+2>this._end)throw new ndarray.Error("Data not available.");const t=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,t}uint32(){return this.uint16()|this.uint16()<<16}uint64(){const t=this.uint32();if(0!=this.uint32())throw new ndarray.Error("Large int64 value.");return t}},ndarray.Error=class extends Error{constructor(t){super(t),this.name="NDArray Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=mxnet.ModelFactory);