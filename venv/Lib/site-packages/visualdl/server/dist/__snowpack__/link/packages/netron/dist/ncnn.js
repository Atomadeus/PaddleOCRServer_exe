var ncnn=ncnn||{},base=base||require("./base");ncnn.ModelFactory=class{match(t){const e=t.identifier.toLowerCase();if(e.endsWith(".param")||e.endsWith(".cfg.ncnn")){let e=t.text;if(e=e.substring(0,Math.min(e.length,32)),"7767517"===e.split("\n").shift().trim())return!0}if(e.endsWith(".param.bin")){const e=t.buffer;if(e.length>4&&7767517==(e[0]|e[1]<<8|e[2]<<16|e[3]<<24)>>>0)return!0}if(e.endsWith(".bin")||e.endsWith(".weights.ncnn")){if("snapshot_blob.bin"==e||"v8_context_snapshot.bin"===e)return!1;const n=t.buffer;if(n.length>4){const t=(n[0]|n[1]<<8|n[2]<<16|n[3]<<24)>>>0;if(0===t||1===t||19950407===t||871224===t||180310===t)return!0}}return!1}open(t,e){return ncnn.Metadata.open(e).then((e=>{const n=t.identifier.toLowerCase(),s=(t,s)=>{try{return new ncnn.Model(e,t,s)}catch(t){const e=t&&t.message?t.message:t.toString();throw new ncnn.Error(e.replace(/\.$/,"")+" in '"+n+"'.")}};let i=null;if(n.endsWith(".param")||n.endsWith(".cfg.ncnn"))return n.endsWith(".param")?i=t.identifier.substring(0,t.identifier.length-6)+".bin":n.endsWith(".cfg.ncnn")&&(i=t.identifier.substring(0,t.identifier.length-9)+".weights.ncnn"),t.request(i,null).then((e=>s(t.text,e))).catch((()=>s(t.text,null)));if(n.endsWith(".param.bin"))return i=t.identifier.substring(0,t.identifier.length-10)+".bin",t.request(i,null).then((e=>s(t.buffer,e))).catch((()=>s(t.buffer,null)));if(n.endsWith(".bin")||n.endsWith(".weights.ncnn")){let e=null;return n.endsWith("bin")?e=t.identifier.substring(0,t.identifier.length-4)+".param":n.endsWith(".weights.ncnn")&&(e=t.identifier.substring(0,t.identifier.length-13)+".cfg.ncnn"),t.request(e,"utf-8").then((e=>s(e,t.buffer))).catch((t=>{const e=t&&t.message?t.message:t.toString();throw new ncnn.Error(e.replace(/\.$/,"")+" in '"+n+"'.")}))}}))}},ncnn.Model=class{constructor(t,e,n){this._graphs=[],this._graphs.push(new ncnn.Graph(t,e,n))}get format(){return"ncnn"}get graphs(){return this._graphs}},ncnn.Graph=class{constructor(t,e,n){this._inputs=[],this._outputs=[],this._nodes=[];const s=new ncnn.BlobReader(n),i=("string"==typeof e?new ncnn.TextParamReader(e):new ncnn.BinaryParamReader(t,e)).layers;for(const e of i)if("Input"==e.type){const t=e.attributes.map((t=>isNaN(parseInt(t.value,10))?t.value:parseInt(t.value,10))),n=new ncnn.TensorShape(t),s=new ncnn.TensorType("float32",n);this._inputs.push(new ncnn.Parameter(e.name,!0,e.outputs.map((t=>new ncnn.Argument(t,s,null)))))}else this._nodes.push(new ncnn.Node(t,s,e))}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},ncnn.Parameter=class{constructor(t,e,n){this._name=t,this._visible=e,this._arguments=n}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},ncnn.Argument=class{constructor(t,e,n){if("string"!=typeof t)throw new ncnn.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._type=e||null,this._initializer=n||null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get initializer(){return this._initializer}},ncnn.Node=class{constructor(t,e,n){this._metadata=t,this._inputs=[],this._outputs=[],this._attributes=[],this._type=n.type,this._name=n.name;const s=t.operator(this._type);s&&(this._type=s);const i=t.type(this._type),a=i&&i.attributes?i&&i.attributes:[];for(const t of n.attributes){const e=a[t.key];this._attributes.push(new ncnn.Attribute(e,t.key,t.value))}const r=n.inputs;let o=0;if(i&&i.inputs)for(const t of i.inputs)if(o<r.length||"optional"!=t.option){const e="variadic"==t.option?r.length-o:1,n=r.slice(o,o+e).filter((e=>""!=e||"optional"!=t.option)).map((t=>new ncnn.Argument(t,null,null)));this._inputs.push(new ncnn.Parameter(t.name,!0,n)),o+=e}this._inputs=this._inputs.concat(r.slice(o).map(((t,e)=>{const n=o+e==0?"input":(o+e).toString();return new ncnn.Parameter(n,!0,[new ncnn.Argument(t,null,null)])})));const h=n.outputs;let u=0;if(i&&i.outputs)for(const t of i.outputs)if(u<h.length||"optional"!=t.option){const e="variadic"==t.option?h.length-u:1,n=h.slice(u,u+e).map((t=>new ncnn.Argument(t,null,null)));this._outputs.push(new ncnn.Parameter(t.name,!0,n)),u+=e}switch(this._outputs=this._outputs.concat(h.slice(u).map(((t,e)=>{const n=u+e==0?"output":(u+e).toString();return new ncnn.Parameter(n,!0,[new ncnn.Argument(t,null,null)])}))),this._type){case"BatchNorm":{const t=parseInt(n.attr[0]||0,10);this._weight(e,"slope",[t],"float32"),this._weight(e,"mean",[t],"float32"),this._weight(e,"variance",[t],"float32"),this._weight(e,"bias",[t],"float32");break}case"InnerProduct":{const t=parseInt(n.attr[0]||0,10),s=parseInt(n.attr[2]||0,10);this._weight(e,"weight",[t,s/t]),"1"==n.attr[1]&&this._weight(e,"bias",[t],"float32");break}case"Bias":{const t=parseInt(n.attr[0]||0,10);this._weight(e,"bias",[t],"float32");break}case"Embed":{const t=parseInt(n.attr[0]||0,10),s=parseInt(n.attr[3]||0,10);this._weight(e,"weight",[s]),"1"==n.attr[2]&&this._weight(e,"bias",[t],"float32");break}case"Convolution":case"ConvolutionDepthWise":case"Deconvolution":case"DeconvolutionDepthWise":{const t=parseInt(n.attr[0]||0,10),s=parseInt(n.attr[1]||0,10),i=parseInt(n.attr[11]||s,10),a=parseInt(n.attr[6]||0,10);this._weight(e,"weight",[t,a/(t*s*i),s,i]),"1"==n.attr[5]&&this._weight(e,"bias",[t],"float32");break}case"Dequantize":if("1"==n.attr[1]){const t=parseInt(n.attr[2]||0,10);this._weight(e,"bias",[t],"float32")}break;case"Requantize":if("1"==n.attr[2]){const t=parseInt(n.attr[3]||0,10);this._weight(e,"bias",[t],"float32")}break;case"InstanceNorm":{const t=parseInt(n.attr[0]||0,10);this._weight(e,"gamma",[t],"float32"),this._weight(e,"beta",[t],"float32");break}case"Scale":{const t=parseInt(n.attr[0]||0,10);-233!=t&&(this._weight(e,"scale",[t],"float32"),"1"==n.attr[1]&&this._weight(e,"bias",[t],"float32"));break}case"Normalize":{const t=parseInt(n.attr[3]||0,10);this._weight(e,"scale",[t],"float32");break}case"PReLU":{const t=parseInt(n.attr[0]||0,10);this._weight(e,"slope",[t],"float32");break}}}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}_weight(t,e,n,s){const i=t.read(n,s);s=i?i.dataType||"?":s||"?";const a=i?i.data:null;this._inputs.push(new ncnn.Parameter(e,!0,[new ncnn.Argument("",null,new ncnn.Tensor(new ncnn.TensorType(s,new ncnn.TensorShape(n)),a))]))}},ncnn.Attribute=class{constructor(t,e,n){if(this._type="",this._name=e,this._value=n,t){switch(this._name=t.name,t.type&&(this._type=t.type),this._type){case"int32":this._value=parseInt(this._value,10);break;case"float32":this._value=parseFloat(this._value);break;case"float32[]":this._value=this._value.map((t=>parseFloat(t)))}(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&(this._value==t.default||this._value&&this._value.toString()==t.default.toString()))&&(this._visible=!1)}}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return 0!=this._visible}},ncnn.Tensor=class{constructor(t,e){this._type=t,this._data=e}get kind(){return"Weight"}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={index:0,count:0,state:null};if("?"==this._type.dataType)return t.state="Tensor has unknown data type.",t;if(!this._type.shape)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"float16":case"float32":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,e){const n=0!==t.shape.length?t.shape:[1],s=[],i=n[e];if(e==n.length-1)for(let e=0;e<i;e++){if(t.count>t.limit)return s.push("..."),s;switch(this._type.dataType){case"float32":s.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":s.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++}}else for(let n=0;n<i;n++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return 0==t.shape.length?s[0]:s}},ncnn.TensorType=class{constructor(t,e){this._dataType=t||"?",this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},ncnn.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map((t=>t?t.toString():"?")).join(",")+"]":""}},ncnn.Metadata=class{static open(t){return ncnn.Metadata._metadata?Promise.resolve(ncnn.Metadata._metadata):t.request(null,"ncnn-metadata.json","utf-8").then((t=>(ncnn.Metadata._metadata=new ncnn.Metadata(t),ncnn.Metadata._metadata))).catch((()=>(ncnn.Metadata._metadata=new ncnn.Metadata(null),ncnn.Metadata._metadatas)))}constructor(t){if(this._operatorMap=new Map,this._map=new Map,this._attributeCache=new Map,t){const e=JSON.parse(t);if(e)for(const t of e)t.name&&t.schema&&(t.schema.name=t.name,this._map.set(t.name,t.schema),Object.prototype.hasOwnProperty.call(t.schema,"operator")&&this._operatorMap.set(t.schema.operator,t.name))}}operator(t){return this._operatorMap.get(t)}type(t){return this._map.get(t)}attribute(t,e){const n=t+":"+e;if(!this._attributeCache.has(n)){const e=this.type(t);if(e&&e.attributes&&e.attributes.length>0)for(const n of e.attributes)this._attributeCache.set(t+":"+n.name,n);this._attributeCache.has(n)||this._attributeCache.set(n,null)}return this._attributeCache.get(n)}},ncnn.TextParamReader=class{constructor(t){const e=t.split(/\r?\n/);if("7767517"!==e.shift())throw new ncnn.Error("Invalid signature.");if(2!==e.shift().split(" ").length)throw new ncnn.Error("Invalid header count.");const n=[];for(;e.length>0;){const t=e.shift().trim();if(t.length>0){const e=t.split(" ").filter((t=>0!=t.length)),s={};s.type=e.shift(),s.name=e.shift();const i=parseInt(e.shift(),10),a=parseInt(e.shift(),10);s.inputs=e.splice(0,i),s.outputs=e.splice(0,a),s.attr={},s.attributes=[];for(const t of e){const e=t.split("=");if(2===e.length){let t=e[0].trim(),n=e[1].trim();const i=parseInt(t,10);i<0&&(n=n.split(",").map((t=>t.trim())),n.shift(),t=(-(i+23300)).toString()),s.attr[t]=n,s.attributes.push({key:t,value:n})}}n.push(s)}}this._layers=n}get layers(){return this._layers}},ncnn.BinaryParamReader=class{constructor(t,e){const n=new ncnn.BinaryReader(e);if(7767517!==n.int32())throw new ncnn.Error("Invalid signature.");const s=n.int32();n.int32();const i=[];for(let e=0;e<s;e++){const s=n.int32(),a={type:t.operator(s)||s.toString(),name:e.toString(),inputs:[],outputs:[],attr:{},attributes:[]},r=n.int32(),o=n.int32();for(let t=0;t<r;t++)a.inputs.push(n.int32().toString());for(let t=0;t<o;t++)a.outputs.push(n.int32().toString());let h=n.int32();for(;-233!=h;){const t=h<=-23300;if(t&&(h=-h-23300),t){const t=n.int32(),e=[];for(let s=0;s<t;s++)e.push(n.int32());a.attributes.push({key:h.toString(),value:e.toString()}),a.attr[h.toString()]=e}else{const t=n.int32();a.attributes.push({key:h.toString(),value:t.toString()}),a.attr[h.toString()]=t.toString()}h=n.int32()}i.push(a)}this._layers=i}get layers(){return this._layers}},ncnn.BlobReader=class{constructor(t){this._buffer=t,this._position=0}read(t,e){if(this._buffer){if(!e)if(this._buffer&&this._position+4<this._buffer.length){const t=this._buffer[this._position++]|this._buffer[this._position++]<<8|this._buffer[this._position++]<<16|this._buffer[this._position++]<<24;switch(t){case 0:e="float32";break;case 19950407:e="float16";break;case 871224:e="int8";break;case 1:e="qint8";break;case 180310:default:throw new ncnn.Error("Unknown weight type '"+t+"'.")}}else this._buffer=null;let n=null,s=1;if(t)for(const e of t)s*=e;else this._buffer=null;if(this._buffer&&e){const t=this._position;switch(e){case"float32":s*=4,this._position+=s,n=this._buffer.subarray(t,this._position);break;case"float16":s*=2,this._position+=s,n=this._buffer.subarray(t,this._position);break;case"int8":this._position+=s,n=this._buffer.subarray(t,this._position);break;case"qint8":this._position+=s+1024,n=null;break;default:throw new ncnn.Error("Unknown weight type '"+e+"'.")}}return{dataType:e,data:n}}return null}},ncnn.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new ncnn.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}},ncnn.Error=class extends Error{constructor(t){super(t),this.name="Error loading ncnn model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=ncnn.ModelFactory);