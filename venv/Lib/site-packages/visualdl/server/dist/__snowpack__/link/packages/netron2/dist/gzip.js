var gzip=gzip||{};gzip.Archive=class{constructor(t){if(this._entries=[],t.length<18||31!=t[0]||139!=t[1])throw new gzip.Error("Invalid gzip archive.");const i=new gzip.Reader(t,0,t.length);this._entries.push(new gzip.Entry(i))}get entries(){return this._entries}},gzip.Entry=class{constructor(t){if(!t.match([31,139]))throw new gzip.Error("Invalid gzip signature.");const i=t.byte();if(8!=i)throw new gzip.Error("Invalid compression method '"+i.toString()+"'.");const s=t.byte();if(t.uint32(),t.byte(),t.byte(),0!=(4&s)){const i=t.uint16();t.skip(i)}0!=(8&s)&&(this._name=t.string()),0!=(16&s)&&t.string(),0!=(1&s)&&t.uint16();const n=t.bytes();if("object"==typeof process&&"object"==typeof process.versions&&void 0!==process.versions.node?this._data=require("zlib").inflateRawSync(n):"undefined"!=typeof pako?this._data=pako.inflateRaw(n):this._data=new require("./zip").Inflater().inflateRaw(n),t.position=-8,t.uint32(),t.uint32()!=this._data.length)throw new gzip.Error("Invalid size.")}get name(){return this._name}get data(){return this._data}},gzip.Reader=class{constructor(t,i,s){this._buffer=t,this._position=i,this._end=s}match(t){if(this._position+t.length<=this._end)for(let i=0;i<t.length;i++)if(this._buffer[this._position+i]!=t[i])return!1;return this._position+=t.length,!0}get position(){return this._position}set position(t){this._position=t>=0?t:this._end+t}skip(t){if(this._position+t>this._end)throw new gzip.Error("Data not available.");this._position+=t}bytes(t){if(this._position+t>this._end)throw new gzip.Error("Data not available.");t=void 0===t?this._end:t;const i=this._buffer.subarray(this._position,this._position+t);return this._position+=t,i}byte(){if(this._position+1>this._end)throw new gzip.Error("Data not available.");const t=this._buffer[this._position];return this._position++,t}uint16(){if(this._position+2>this._end)throw new gzip.Error("Data not available.");const t=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,t}uint32(){return this.uint16()|this.uint16()<<16}string(){let t="";const i=this._buffer.indexOf(0,this._position);if(i<0)throw new gzip.Error("End of string not found.");for(;this._position<i;)t+=String.fromCharCode(this._buffer[this._position++]);return this._position++,t}},gzip.Error=class extends Error{constructor(t){super(t),this.name="Gzip Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.Archive=gzip.Archive);