var mlnet=mlnet||{},zip=zip||require("./zip");mlnet.ModelFactory=class{match(e){if("zip"===e.identifier.split(".").pop().toLowerCase()){const t=e.entries("zip");if(t.length>0){const e=new Set(["TransformerChain","Predictor"]);if(t.some((t=>e.has(t.name.split("\\").shift().split("/").shift()))))return!0}}return!1}open(e,t){const s=e.identifier;return mlnet.Metadata.open(t).then((t=>{try{const s=new mlnet.ModelReader(e.entries("zip"));return new mlnet.Model(t,s)}catch(e){const t=e&&e.message?e.message:e.toString();throw new mlnet.Error(t.replace(/\.$/,"")+" in '"+s+"'.")}}))}},mlnet.Model=class{constructor(e,t){this._format="ML.NET",t.version&&t.version.length>0&&(this._format+=" v"+t.version),this._graphs=[],this._graphs.push(new mlnet.Graph(e,t))}get format(){return this._format}get graphs(){return this._graphs}},mlnet.Graph=class{constructor(e,t){if(this._inputs=[],this._outputs=[],this._nodes=[],this._groups=!1,t.schema&&t.schema.inputs)for(const e of t.schema.inputs)this._inputs.push(new mlnet.Parameter(e.name,[new mlnet.Argument(e.name,new mlnet.TensorType(e.type))]));const s=new Map;t.dataLoaderModel&&this._loadTransformer(e,s,"",t.dataLoaderModel),t.predictor&&this._loadTransformer(e,s,"",t.predictor),t.transformerChain&&this._loadTransformer(e,s,"",t.transformerChain)}_loadTransformer(e,t,s,r){switch(r.__type__){case"TransformerChain":case"Text":this._loadChain(e,t,r.__name__,r.chain);break;default:this._createNode(e,t,s,r)}}_loadChain(e,t,s,r){this._groups=!0;const n=s.split("/").splice(1).join("/");for(const s of r)this._loadTransformer(e,t,n,s)}_createNode(e,t,s,r){if(r.inputs&&r.outputs){for(const e of r.inputs)e.name=t[e.name]?t[e.name].argument:e.name;for(const e of r.outputs)if(t[e.name]){t[e.name].counter++;const s=e.name+"\n"+t[e.name].counter.toString();t[e.name].argument=s,e.name=s}else t[e.name]={argument:e.name,counter:0}}this._nodes.push(new mlnet.Node(e,s,r))}get groups(){return this._groups}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},mlnet.Parameter=class{constructor(e,t){this._name=e,this._arguments=t}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},mlnet.Argument=class{constructor(e,t){if("string"!=typeof e)throw new mlnet.Error("Invalid argument identifier '"+JSON.stringify(e)+"'.");this._name=e,this._type=t}get name(){return this._name}get type(){return this._type}},mlnet.Node=class{constructor(e,t,s){if(this._metadata=e,this._group=t,this._name=s.__name__,this._type=s.__type__,this._inputs=[],this._outputs=[],this._attributes=[],s.inputs){let e=0;for(const t of s.inputs)this._inputs.push(new mlnet.Parameter(e.toString(),[new mlnet.Argument(t.name)])),e++}if(s.outputs){let e=0;for(const t of s.outputs)this._outputs.push(new mlnet.Parameter(e.toString(),[new mlnet.Argument(t.name)])),e++}for(const t of Object.keys(s).filter((e=>!e.startsWith("_")&&"inputs"!==e&&"outputs"!==e))){const r=e.attribute(this._type,this._name);this._attributes.push(new mlnet.Attribute(r,t,s[t]))}}get group(){return this._group}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get inputs(){return this._inputs}get outputs(){return this._outputs}get attributes(){return this._attributes}},mlnet.Attribute=class{constructor(e,t,s){if(this._name=t,this._value=s,e&&(e.type&&(this._type=e.type),this._type)){let e=mlnet;const t=this._type.split(".");for(;e&&t.length>0;)e=e[t.shift()];if(e){mlnet.Attribute._reverseMap=mlnet.Attribute._reverseMap||{};let t=mlnet.Attribute._reverseMap[this._type];if(!t){t={};for(const s of Object.keys(e))t[e[s.toString()]]=s;mlnet.Attribute._reverseMap[this._type]=t}Object.prototype.hasOwnProperty.call(t,this._value)&&(this._value=t[this._value])}}}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return!0}},mlnet.TensorType=class{constructor(e){if(mlnet.TensorType._map=mlnet.TensorType._map||new Map([["Byte","uint8"],["Boolean","boolean"],["Single","float32"],["Double","float64"],["UInt32","uint32"],["TextSpan","string"]]),this._dataType="?",this._shape=new mlnet.TensorShape(null),mlnet.TensorType._map.has(e.name))this._dataType=mlnet.TensorType._map.get(e.name);else if("VBuffer"==e.name){if(!mlnet.TensorType._map.has(e.itemType.name))throw new mlnet.Error("Unknown data type '"+e.itemType.name+"'.");this._dataType=mlnet.TensorType._map.get(e.itemType.name),this._shape=new mlnet.TensorShape(e.dims)}else{if("Key2"!=e.name)throw new mlnet.Error("Unknown data type '"+e.name+"'.");this._dataType="key2"}}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},mlnet.TensorShape=class{constructor(e){this._dimensions=e}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},mlnet.Metadata=class{static open(e){return mlnet.Metadata._metadata?Promise.resolve(mlnet.Metadata._metadata):e.request(null,"mlnet-metadata.json","utf-8").then((e=>(mlnet.Metadata._metadata=new mlnet.Metadata(e),mlnet.Metadata._metadata))).catch((()=>(mlnet.Metadata._metadata=new mlnet.Metadata(null),mlnet.Metadata._metadatas)))}constructor(e){if(this._map={},this._attributeCache={},e){const t=JSON.parse(e);if(t)for(const e of t)e.name&&e.schema&&(e.schema.name=e.name,this._map[e.name]=e.schema)}}type(e){return this._map[e]||null}attribute(e,t){let s=this._attributeCache[e];if(!s){s={};const t=this.type(e);if(t&&t.attributes&&t.attributes.length>0)for(const e of t.attributes)s[e.name]=e;this._attributeCache[e]=s}return s[t]||null}},mlnet.ModelReader=class{constructor(e){const t=new mlnet.ComponentCatalog;t.register("AffineNormExec",mlnet.AffineNormSerializationUtils),t.register("AnomalyPredXfer",mlnet.AnomalyPredictionTransformer),t.register("BinaryPredXfer",mlnet.BinaryPredictionTransformer),t.register("BinaryLoader",mlnet.BinaryLoader),t.register("CaliPredExec",mlnet.CalibratedPredictor),t.register("CdfNormalizeFunction",mlnet.CdfColumnFunction),t.register("CharToken",mlnet.TokenizingByCharactersTransformer),t.register("ChooseColumnsTransform",mlnet.ColumnSelectingTransformer),t.register("ClusteringPredXfer",mlnet.ClusteringPredictionTransformer),t.register("ConcatTransform",mlnet.ColumnConcatenatingTransformer),t.register("CopyTransform",mlnet.ColumnCopyingTransformer),t.register("ConvertTransform",mlnet.TypeConvertingTransformer),t.register("CSharpTransform",mlnet.CSharpTransform),t.register("DropColumnsTransform",mlnet.DropColumnsTransform),t.register("FAFMPredXfer",mlnet.FieldAwareFactorizationMachinePredictionTransformer),t.register("FastForestBinaryExec",mlnet.FastForestClassificationPredictor),t.register("FastTreeBinaryExec",mlnet.FastTreeBinaryModelParameters),t.register("FastTreeTweedieExec",mlnet.FastTreeTweedieModelParameters),t.register("FastTreeRankerExec",mlnet.FastTreeRankingModelParameters),t.register("FastTreeRegressionExec",mlnet.FastTreeRegressionModelParameters),t.register("FeatWCaliPredExec",mlnet.FeatureWeightsCalibratedModelParameters),t.register("FieldAwareFactMacPredict",mlnet.FieldAwareFactorizationMachineModelParameters),t.register("GcnTransform",mlnet.LpNormNormalizingTransformer),t.register("GenericScoreTransform",mlnet.GenericScoreTransform),t.register("IidChangePointDetector",mlnet.IidChangePointDetector),t.register("IidSpikeDetector",mlnet.IidSpikeDetector),t.register("ImageClassificationTrans",mlnet.ImageClassificationTransformer),t.register("ImageClassificationPred",mlnet.ImageClassificationModelParameters),t.register("ImageLoaderTransform",mlnet.ImageLoadingTransformer),t.register("ImageScalerTransform",mlnet.ImageResizingTransformer),t.register("ImagePixelExtractor",mlnet.ImagePixelExtractingTransformer),t.register("KeyToValueTransform",mlnet.KeyToValueMappingTransformer),t.register("KeyToVectorTransform",mlnet.KeyToVectorMappingTransformer),t.register("KMeansPredictor",mlnet.KMeansModelParameters),t.register("LinearRegressionExec",mlnet.LinearRegressionModelParameters),t.register("LightGBMRegressionExec",mlnet.LightGbmRegressionModelParameters),t.register("LightGBMBinaryExec",mlnet.LightGbmBinaryModelParameters),t.register("Linear2CExec",mlnet.LinearBinaryModelParameters),t.register("LinearModelStats",mlnet.LinearModelParameterStatistics),t.register("MaFactPredXf",mlnet.MatrixFactorizationPredictionTransformer),t.register("MFPredictor",mlnet.MatrixFactorizationModelParameters),t.register("MulticlassLinear",mlnet.LinearMulticlassModelParameters),t.register("MultiClassLRExec",mlnet.MaximumEntropyModelParameters),t.register("MultiClassNaiveBayesPred",mlnet.NaiveBayesMulticlassModelParameters),t.register("MultiClassNetPredictor",mlnet.MultiClassNetPredictor),t.register("MulticlassPredXfer",mlnet.MulticlassPredictionTransformer),t.register("NgramTransform",mlnet.NgramExtractingTransformer),t.register("NgramHashTransform",mlnet.NgramHashingTransformer),t.register("NltTokenizeTransform",mlnet.NltTokenizeTransform),t.register("Normalizer",mlnet.NormalizingTransformer),t.register("NormalizeTransform",mlnet.NormalizeTransform),t.register("OnnxTransform",mlnet.OnnxTransformer),t.register("OptColTransform",mlnet.OptionalColumnTransform),t.register("OVAExec",mlnet.OneVersusAllModelParameters),t.register("pcaAnomExec",mlnet.PcaModelParameters),t.register("PcaTransform",mlnet.PrincipalComponentAnalysisTransformer),t.register("PipeDataLoader",mlnet.CompositeDataLoader),t.register("PlattCaliExec",mlnet.PlattCalibrator),t.register("PMixCaliPredExec",mlnet.ParameterMixingCalibratedModelParameters),t.register("PoissonRegressionExec",mlnet.PoissonRegressionModelParameters),t.register("ProtonNNMCPred",mlnet.ProtonNNMCPred),t.register("RegressionPredXfer",mlnet.RegressionPredictionTransformer),t.register("RowToRowMapper",mlnet.RowToRowMapperTransform),t.register("SsaForecasting",mlnet.SsaForecastingTransformer),t.register("SSAModel",mlnet.AdaptiveSingularSpectrumSequenceModelerInternal),t.register("SelectColumnsTransform",mlnet.ColumnSelectingTransformer),t.register("StopWordsTransform",mlnet.StopWordsTransform),t.register("TensorFlowTransform",mlnet.TensorFlowTransformer),t.register("TermLookupTransform",mlnet.ValueMappingTransformer),t.register("TermTransform",mlnet.ValueToKeyMappingTransformer),t.register("TermManager",mlnet.TermManager),t.register("Text",mlnet.TextFeaturizingEstimator),t.register("TextLoader",mlnet.TextLoader),t.register("TextNormalizerTransform",mlnet.TextNormalizingTransformer),t.register("TokenizeTextTransform",mlnet.WordTokenizingTransformer),t.register("TransformerChain",mlnet.TransformerChain),t.register("ValueMappingTransformer",mlnet.ValueMappingTransformer),t.register("XGBoostMulticlass",mlnet.XGBoostMulticlass);const s=new mlnet.ModelHeader(t,e,"",null),r=s.openText("TrainingInfo/Version.txt");r&&(this.version=r.split(" ").shift().split("\r").shift());const n=s.openBinary("Schema");n&&(this.schema=new mlnet.BinaryLoader(null,n).schema);const i=s.open("TransformerChain");i&&(this.transformerChain=i);const o=s.open("DataLoaderModel");o&&(this.dataLoaderModel=o);const a=s.open("Predictor");a&&(this.predictor=a)}},mlnet.ComponentCatalog=class{constructor(){this._map=new Map}register(e,t){this._map.set(e,t)}create(e,t){if(!this._map.has(e))throw new mlnet.Error("Unknown loader signature '"+e+"'.");const s=this._map.get(e);return Reflect.construct(s,[t])}},mlnet.ModelHeader=class{constructor(e,t,s,r){if(this._entries=t,this._catalog=e,this._directory=s,r){const e=new mlnet.Reader(r),t=new TextDecoder("ascii");e.assert("ML\0MODEL"),this.versionWritten=e.uint32(),this.versionReadable=e.uint32();const s=e.uint64();e.uint64();const n=e.uint64(),i=e.uint64(),o=e.uint64();e.uint64(),this.modelSignature=t.decode(e.bytes(8)),this.modelVersionWritten=e.uint32(),this.modelVersionReadable=e.uint32(),this.loaderSignature=t.decode(e.bytes(24).filter((e=>0!=e))),this.loaderSignatureAlt=t.decode(e.bytes(24).filter((e=>0!=e)));const a=e.uint64();e.uint64();const l=e.uint64(),m=e.uint32();if(0!=n&&0!=o){e.position=n;const t=i>>3,s=[];let r=0;for(let n=0;n<t;n++){const t=e.uint64();s.push(t-r),r=t}e.position=o,this.strings=[];for(let r=0;r<t;r++){const t=s[r]>>1;let n="";for(let s=0;s<t;s++)n+=String.fromCharCode(e.uint16());this.strings.push(n)}}0!=l&&(e.position=l,this.assemblyName=t.decode(e.bytes(m))),e.position=a,e.assert("LEDOM\0LM"),this._reader=e,this._reader.position=s}}get reader(){return this._reader}string(e){const t=this.reader.int32();return null===e&&t<0?null:this.strings[t]}open(e){const t=(e=(this._directory.length>0?this._directory+"/":this._directory)+e)+"/Model.key",s=this._entries.find((e=>e.name==t||e.name==t.replace(/\//g,"\\")));if(s){const t=new mlnet.ModelHeader(this._catalog,this._entries,e,s.data),r=this._catalog.create(t.loaderSignature,t);return r.__type__=r.__type__||t.loaderSignature,r.__name__=e,r}return null}openBinary(e){const t=this._directory.length>0?this._directory+"/":this._directory;e=t+e;const s=this._entries.find((t=>t.name==e||t.name==e.replace(/\//g,"\\")));return s?new mlnet.Reader(s.data):null}openText(e){const t=this._directory.length>0?this._directory+"/":this._directory;e=t+e;const s=this._entries.find((t=>t.name.split("\\").join("/")==e));return s?(new TextDecoder).decode(s.data):null}check(e,t,s){return e===this.modelSignature&&t>=this.modelVersionReadable&&s<=this.modelVersionWritten}},mlnet.Reader=class{constructor(e){this._buffer=e,this._dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),this._position=0}set position(e){this._position=e}get position(){return this._position}skip(e){if(this._position+=e,this._position>this._buffer.length)throw new mlnet.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}match(e){const t=this._position;for(let s=0;s<e.length;s++)if(this.byte()!=e.charCodeAt(s))return this._position=t,!1;return!0}assert(e){if(!this.match(e))throw new mlnet.Error("Invalid '"+e.split("\0").join("")+"' signature.")}boolean(){return 0!=this.byte()}booleans(e){const t=[];for(let s=0;s<e;s++)t.push(this.boolean());return t}byte(){const e=this._position;return this.skip(1),this._dataView.getUint8(e)}bytes(e){const t=this._position;return this.skip(e),this._buffer.subarray(t,this._position)}int16(){const e=this._position;return this.skip(2),this._dataView.getInt16(e,!0)}uint16(){const e=this._position;return this.skip(2),this._dataView.getUint16(e,!0)}int32(){const e=this._position;return this.skip(4),this._dataView.getInt32(e,!0)}int32s(e){const t=[];for(let s=0;s<e;s++)t.push(this.int32());return t}uint32(){const e=this._position;return this.skip(4),this._dataView.getUint32(e,!0)}uint32s(e){const t=[];for(let s=0;s<e;s++)t.push(this.uint32());return t}int64(){const e=this.uint32(),t=this.uint32();if(4294967295==e&&2147483647==t)return Number.MAX_SAFE_INTEGER;if(-1==t)return-e;if(0!=t)throw new mlnet.Error("Value not in 48-bit range.");return t<<32|e}uint64(){const e=this.uint32(),t=this.uint32();if(0==t)return e;if(t>1048576)throw new mlnet.Error("Value not in 48-bit range.");return 4294967296*t+e}float32(){const e=this._position;return this.skip(4),this._dataView.getFloat32(e,!0)}float32s(e){const t=[];for(let s=0;s<e;s++)t.push(this.float32());return t}float64(){const e=this._position;return this.skip(8),this._dataView.getFloat64(e,!0)}float64s(e){const t=[];for(let s=0;s<e;s++)t.push(this.float64());return t}string(){const e=this.leb128(),t=this.bytes(e);return new TextDecoder("utf-8").decode(t)}leb128(){let e,t=0,s=0;do{e=this.byte(),t|=(127&e)<<s,s+=7}while(0!=(128&e));return t}},mlnet.BinaryLoader=class{constructor(e,t){e&&(e.modelVersionWritten>=65538&&(this.Threads=e.reader.int32(),this.GeneratedRowIndexName=e.string(null)),this.ShuffleBlocks=e.modelVersionWritten>=65539?e.reader.float64():4,t=e.openBinary("Schema.idv")),t.assert("CML\0DVB\0"),t.bytes(8),t.bytes(8);const s=t.uint64(),r=t.int64();t.int64();const n=t.int32();t.position=r,t.assert("\0BVD\0LMC"),t.position=s,this.schema={},this.schema.inputs=[];for(let e=0;e<n;e++){const e={};e.name=t.string(),e.type=new mlnet.Codec(t),e.compression=t.byte(),e.rowsPerBlock=t.leb128(),e.lookupOffset=t.int64(),e.metadataTocOffset=t.int64(),this.schema.inputs.push(e)}}},mlnet.TransformerChain=class{constructor(e){const t=e.reader,s=t.int32();this.scopes=[],this.chain=[];for(let r=0;r<s;r++){this.scopes.push(t.int32());const s="Transform_"+("00"+r).slice(-3),n=e.open(s);this.chain.push(n)}}},mlnet.TransformBase=class{constructor(){}},mlnet.RowToRowTransformBase=class extends mlnet.TransformBase{constructor(e){super(e)}},mlnet.RowToRowTransformerBase=class{constructor(){}},mlnet.RowToRowMapperTransformBase=class extends mlnet.RowToRowTransformBase{constructor(e){super(e)}},mlnet.OneToOneTransformerBase=class{constructor(e){const t=e.reader.int32();this.inputs=[],this.outputs=[];for(let s=0;s<t;s++){const t=e.string(),s=e.string();this.outputs.push({name:t}),this.inputs.push({name:s})}}},mlnet.ColumnCopyingTransformer=class{constructor(e){const t=e.reader.uint32();this.inputs=[],this.outputs=[];for(let s=0;s<t;s++)this.outputs.push({name:e.string()}),this.inputs.push({name:e.string()})}},mlnet.ColumnConcatenatingTransformer=class{constructor(e){const t=e.reader;if(e.modelVersionReadable>=65539){const s=t.int32();for(let r=0;r<s;r++){this.outputs=[],this.outputs.push({name:e.string()});const s=t.int32();this.inputs=[];for(let t=0;t<s;t++){const t={name:e.string()},s=e.string(null);s&&(t.alias=s),this.inputs.push(t)}}}else{this.precision=t.int32();const s=t.int32(),r=[],n=[];for(let i=0;i<s;i++){r.push(e.string());const s=t.int32(),i=[];for(let t=0;t<s;t++)i.push(e.string());n.push(i)}const i=[];if(e.modelVersionReadable>=65538)for(let r=0;r<s;r++){n[r].length;const s={};if(i.push(s),e.modelVersionReadable>=65538)for(;;){const r=t.int32();if(-1==r)break;s[r]=e.string()}}if(s>1)throw new mlnet.Error("");this.outputs=[];for(let e=0;e<s;e++)this.outputs.push({name:r[e]}),this.inputs=n[e]}}},mlnet.PredictionTransformerBase=class{constructor(e){this.Model=e.open("Model");const t=e.openBinary("TrainSchema");t&&new mlnet.BinaryLoader(null,t).schema}},mlnet.MatrixFactorizationModelParameters=class{constructor(e){const t=e.reader;this.NumberOfRows=t.int32(),e.modelVersionWritten<65538&&t.uint64(),this.NumberOfColumns=t.int32(),e.modelVersionWritten<65538&&t.uint64(),this.ApproximationRank=t.int32(),this._leftFactorMatrix=t.float32s(this.NumberOfRows*this.ApproximationRank),this._rightFactorMatrix=t.float32s(this.NumberOfColumns*this.ApproximationRank)}},mlnet.MatrixFactorizationPredictionTransformer=class extends mlnet.PredictionTransformerBase{constructor(e){super(e),this.MatrixColumnIndexColumnName=e.string(),this.MatrixRowIndexColumnName=e.string()}},mlnet.FieldAwareFactorizationMachinePredictionTransformer=class extends mlnet.PredictionTransformerBase{constructor(e){super(e);const t=e.reader;this.inputs=[];for(let t=0;t<this.FieldCount;t++)this.inputs.push({name:e.string()});this.Threshold=t.float32(),this.ThresholdColumn=e.string(),this.inputs.push({name:this.ThresholdColumn})}},mlnet.SingleFeaturePredictionTransformerBase=class extends mlnet.PredictionTransformerBase{constructor(e){super(e);const t=e.string(null);this.inputs=[],this.inputs.push({name:t}),this.outputs=[],this.outputs.push({name:t})}},mlnet.ClusteringPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(e){super(e)}},mlnet.AnomalyPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(e){super(e);const t=e.reader;this.Threshold=t.float32(),this.ThresholdColumn=e.string()}},mlnet.AffineNormSerializationUtils=class{constructor(e){const t=e.reader;t.int32(),this.NumFeatures=t.int32(),-1==t.int32()&&(this.ScalesSparse=t.float32s(t.int32()),this.OffsetsSparse=t.float32s(t.int32()))}},mlnet.RegressionPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(e){super(e)}},mlnet.BinaryPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(e){super(e);const t=e.reader;this.Threshold=t.float32(),this.ThresholdColumn=e.string()}},mlnet.MulticlassPredictionTransformer=class extends mlnet.SingleFeaturePredictionTransformerBase{constructor(e){super(e),this.TrainLabelColumn=e.string(null),this.inputs.push({name:this.TrainLabelColumn})}},mlnet.PredictorBase=class{constructor(e){if(4!=e.reader.int32())throw new mlnet.Error("Invalid float type size.")}},mlnet.ModelParametersBase=class{constructor(e){if(4!==e.reader.int32())throw new mlnet.Error("This file was saved by an incompatible version.")}},mlnet.ImageClassificationModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this.classCount=t.int32(),this.imagePreprocessorTensorInput=t.string(),this.imagePreprocessorTensorOutput=t.string(),this.graphInputTensor=t.string(),this.graphOutputTensor=t.string(),this.modelFile="TFModel"}},mlnet.NaiveBayesMulticlassModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this._labelHistogram=t.int32s(t.int32()),this._featureCount=t.int32(),this._featureHistogram=[];for(let e=0;e<this._labelHistogram.length;e++)this._labelHistogram[e]>0&&this._featureHistogram.push(t.int32s(this._featureCount));this._absentFeaturesLogProb=t.float64s(this._labelHistogram.length)}},mlnet.LinearModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this.Bias=t.float32(),t.int32(),this.Indices=t.int32s(t.int32()),this.Weights=t.float32s(t.int32())}},mlnet.LinearBinaryModelParameters=class extends mlnet.LinearModelParameters{constructor(e){super(e),e.modelVersionWritten>131073&&(this.Statistics=e.open("ModelStats"))}},mlnet.ModelStatisticsBase=class{constructor(e){const t=e.reader;this.ParametersCount=t.int32(),this.TrainingExampleCount=t.int64(),this.Deviance=t.float32(),this.NullDeviance=t.float32()}},mlnet.LinearModelParameterStatistics=class extends mlnet.ModelStatisticsBase{constructor(e){super(e);const t=e.reader;if(e.modelVersionWritten<65538&&!t.boolean())return;const s=t.float32s(this.ParametersCount);t.int32()==this.ParametersCount||(this.stdErrorIndices=t.int32s(this.ParametersCount)),this._coeffStdError=s,this._bias=t.float32();const r=t.byte(),n=t.int32(),i=t.float32s(n);r?this._weights=i:this.weightsIndices=t.int32s(n)}},mlnet.LinearMulticlassModelParametersBase=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader,s=t.int32(),r=t.int32();if(this.Biases=t.float32s(r),0==t.int32()){t.int32(),t.int32(),this.Weights=[];for(let e=0;e<r;e++){const e=t.float32s(s);this.Weights.push(e)}}else{const e=t.int32s(t.int32());t.int32();const s=[];for(let n=0;n<r;n++)s.push(t.int32s(e[n+1]-e[n]));t.int32(),this.Weights=[];for(let s=0;s<r;s++){const r=t.float32s(e[s+1]-e[s]);this.Weights.push(r)}}const n=e.openBinary("LabelNames");if(n){this.LabelNames=[];for(let t=0;t<r;t++){const t=n.int32();this.LabelNames.push(e.strings[t])}}const i=e.open("ModelStats");i&&(this.Statistics=i)}},mlnet.LinearMulticlassModelParameters=class extends mlnet.LinearMulticlassModelParametersBase{constructor(e){super(e)}},mlnet.RegressionModelParameters=class extends mlnet.LinearModelParameters{constructor(e){super(e)}},mlnet.PoissonRegressionModelParameters=class extends mlnet.RegressionModelParameters{constructor(e){super(e)}},mlnet.LinearRegressionModelParameters=class extends mlnet.RegressionModelParameters{constructor(e){super(e)}},mlnet.MaximumEntropyModelParameters=class extends mlnet.LinearMulticlassModelParametersBase{constructor(e){super(e)}},mlnet.TokenizingByCharactersTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;this.UseMarkerChars=t.boolean(),this.IsSeparatorStartEnd=e.modelVersionReadable<65538||t.boolean()}},mlnet.SequencePool=class{constructor(e){this.idLim=e.int32(),this.start=e.int32s(this.idLim+1),this.bytes=e.bytes(this.start[this.idLim])}},mlnet.NgramExtractingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;1==this.inputs.length&&this._option(e,t,this)}_option(e,t,s){const r=e.modelVersionReadable>=65538;s.NgramLength=t.int32(),s.SkipLength=t.int32(),r&&(s.Weighting=t.int32()),s.NonEmptyLevels=t.booleans(s.NgramLength),s.NgramMap=new mlnet.SequencePool(t),r&&(s.InvDocFreqs=t.float64s(t.int32()))}},mlnet.NgramHashingTransformer=class extends mlnet.RowToRowTransformerBase{constructor(e){super(e);const t=e.modelVersionWritten<65539,s=e.reader;t&&s.int32(),this.inputs=[],this.outputs=[];const r=s.int32();if(t);else for(let t=0;t<r;t++){this.outputs.push(e.string());const t=s.int32();for(let s=0;s<t;s++){const t=e.string();this.inputs.push(t)}}}},mlnet.WordTokenizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;if(1==this.inputs.length){this.Separators=[];const e=t.int32();for(let s=0;s<e;s++)this.Separators.push(String.fromCharCode(t.int16()))}}},mlnet.TextNormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;this.CaseMode=t.byte(),this.KeepDiacritics=t.boolean(),this.KeepPunctuations=t.boolean(),this.KeepNumbers=t.boolean()}},mlnet.TextNormalizingTransformer.CaseMode={Lower:0,Upper:1,None:2},mlnet.PrincipalComponentAnalysisTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;if(65537===e.modelVersionReadable&&4!==t.int32())throw new mlnet.Error("This file was saved by an incompatible version.");this.TransformInfos=[];for(let e=0;e<this.inputs.length;e++){const e={};e.Dimension=t.int32(),e.Rank=t.int32(),e.Eigenvectors=[];for(let s=0;s<e.Rank;s++)e.Eigenvectors.push(t.float32s(e.Dimension));e.MeanProjected=t.float32s(t.int32()),this.TransformInfos.push(e)}}},mlnet.LpNormNormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;e.modelVersionWritten<=65538&&t.int32(),1==this.inputs.length&&(this.EnsureZeroMean=t.boolean(),this.Norm=t.byte(),this.Scale=t.float32())}},mlnet.KeyToVectorMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;65537==e.modelVersionWritten&&t.int32();const s=this.inputs.length;this.Bags=t.booleans(s)}},mlnet.TypeConvertingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e)}},mlnet.ImageLoadingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e),this.ImageFolder=e.string(null)}},mlnet.ImageResizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;if(1==this.inputs.length)this._option(t,this);else{this.Options=[];for(let e=0;e<this.inputs.length;e++){const e={};this._option(t,e),this.Options.push(e)}}}_option(e,t){t.Width=e.int32(),t.Height=e.int32(),t.Resizing=e.byte(),t.Anchor=e.byte()}},mlnet.ImageResizingTransformer.ResizingKind={IsoPad:0,IsoCrop:1,Fill:2},mlnet.ImageResizingTransformer.Anchor={Right:0,Left:1,Top:2,Bottom:3,Center:4},mlnet.ImagePixelExtractingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;if(1==this.inputs.length)this._option(e,t,this);else{this.Options=[];for(let s=0;s<this.inputs.length;s++){const s={};this._option(e,t,s),this.Options.push(s)}}}_option(e,t,s){s.ColorsToExtract=t.byte(),s.OrderOfExtraction=e.modelVersionWritten<=65538?mlnet.ImagePixelExtractingTransformer.ColorsOrder.ARGB:t.byte();let r=s.ColorsToExtract;r=(5&r)+(r>>1&5),r=(3&r)+(r>>2&3),s.Planes=255&r,s.OutputAsFloatArray=t.boolean(),s.OffsetImage=t.float32(),s.ScaleImage=t.float32(),s.InterleavePixelColors=t.boolean()}},mlnet.ImagePixelExtractingTransformer.ColorBits={Alpha:1,Red:2,Green:4,Blue:8,Rgb:14,All:15},mlnet.ImagePixelExtractingTransformer.ColorsOrder={ARGB:1,ARBG:2,ABRG:3,ABGR:4,AGRB:5,AGBR:6},mlnet.NormalizingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;this.Options=[];for(let s=0;s<this.inputs.length;s++){let r=!1,n=0,i="";e.modelVersionWritten<65538?(r=t.boolean(),n=[t.int32()],i=t.byte()):(r=t.boolean(),i=t.byte(),n=t.int32s(t.int32()));let o="";switch(i){case 9:o="float32";break;case 10:o="float64";break;default:throw new mlnet.Error("Unknown NormalizingTransformer item kind '"+i+"'.")}const a=o+(r?"["+n.map((e=>e.toString())).join(",")+"]":""),l="Normalizer_"+("00"+s).slice(-3),m=e.open(l);this.Options.push({type:a,func:m})}}},mlnet.KeyToValueMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e)}},mlnet.ValueToKeyMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e);const t=e.reader;if(e.modelVersionWritten>=65539)this.textMetadata=t.booleans(this.outputs.length+this.inputs.length);else{this.textMetadata=[];for(let e=0;e<this.columnPairs.length;e++)this.textMetadata.push(!1)}const s=e.open("Vocabulary");s&&(this.termMap=s.termMap)}},mlnet.TermMap=class{constructor(e){const t=e.reader,s=t.byte();switch(s){case 0:{this.values=[];const s=t.int32();for(let t=0;t<s;t++)this.values.push(e.string());break}case 1:{const e=new mlnet.Codec(t),s=t.int32();this.values=e.read(t,s);break}default:throw new mlnet.Error("Unknown term map type '"+s.toString()+"'.")}}},mlnet.TermManager=class{constructor(e){const t=e.reader.int32();if(this.termMap=[],!(e.modelVersionWritten>=65538))throw new mlnet.Error("Unsupported TermManager version.");for(let s=0;s<t;++s)this.termMap.push(new mlnet.TermMap(e))}},mlnet.ValueMappingTransformer=class extends mlnet.OneToOneTransformerBase{constructor(e){super(e),this.keyColumnName="Key",e.check("TXTLOOKT",65538,65538)&&(this.keyColumnName="Term")}},mlnet.KeyToVectorTransform=class{constructor(){}},mlnet.GenericScoreTransform=class{constructor(){}},mlnet.CompositeDataLoader=class{constructor(e){e.open("Loader");const t=e.reader;t.int32();const s=t.int32(),r=[];for(let t=0;t<s;t++){let t="",s=null;e.modelVersionReadable>=65538&&(t=e.string(),s=e.string(null)),r.push([t,s])}this.chain=[];for(let t=0;t<s;t++){const s="Transform_"+("00"+t).slice(-3),r=e.open(s);this.chain.push(r)}}},mlnet.RowToRowMapperTransform=class extends mlnet.RowToRowTransformBase{constructor(e){super(e);const t=e.open("Mapper");this.__type__=t.__type__;for(const e of Object.keys(t))this[e]=t[e]}},mlnet.ImageClassificationTransformer=class extends mlnet.RowToRowTransformerBase{constructor(e){super(e);const t=e.reader;this.addBatchDimensionInput=t.boolean();const s=t.int32();this.inputs=[];for(let t=0;t<s;t++)this.inputs.push({name:e.string()});this.outputs=[];const r=t.int32();for(let t=0;t<r;t++)this.outputs.push({name:e.string()});this.labelColumn=t.string(),this.checkpointName=t.string(),this.arch=t.int32(),this.scoreColumnName=t.string(),this.predictedColumnName=t.string(),this.learningRate=t.float32(),this.classCount=t.int32(),this.keyValueAnnotations=[];for(let t=0;t<this.classCount;t++)this.keyValueAnnotations.push(e.string());this.predictionTensorName=t.string(),this.softMaxTensorName=t.string(),this.jpegDataTensorName=t.string(),this.resizeTensorName=t.string()}},mlnet.OnnxTransformer=class extends mlnet.RowToRowTransformerBase{constructor(e){super(e);const t=e.reader;this.modelFile="OnnxModel";const s=e.modelVersionWritten>65537?t.int32():1;this.inputs=[];for(let t=0;t<s;t++)this.inputs.push({name:e.string()});const r=e.modelVersionWritten>65537?t.int32():1;this.outputs=[];for(let t=0;t<r;t++)this.outputs.push({name:e.string()});if(e.modelVersionWritten>65548){const s=t.int32();this.LoadedCustomShapeInfos=[];for(let r=0;r<s;r++)this.LoadedCustomShapeInfos.push({name:e.string(),shape:t.int32s(t.int32())})}}},mlnet.OptionalColumnTransform=class extends mlnet.RowToRowMapperTransformBase{constructor(e){super(e)}},mlnet.TensorFlowTransformer=class extends mlnet.RowToRowTransformerBase{constructor(e){super(e);const t=e.reader;this.IsFrozen=!(e.modelVersionReadable>=65538)||t.boolean(),this.AddBatchDimensionInput=!(e.modelVersionReadable>=65539)||t.boolean();const s=t.int32();this.inputs=[];for(let t=0;t<s;t++)this.inputs.push({name:e.string()});const r=e.modelVersionReadable>=65538?t.int32():1;this.outputs=[];for(let t=0;t<r;t++)this.outputs.push({name:e.string()})}},mlnet.OneVersusAllModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this.UseDist=t.boolean();const s=t.int32();this.chain=[];for(let t=0;t<s;t++){const s="SubPredictor_"+("00"+t).slice(-3),r=e.open(s);this.chain.push(r)}}},mlnet.TextFeaturizingEstimator=class{constructor(e){if(65537===e.modelVersionReadable){const t=e.reader.int32();this.chain=[],e.open("Loader");for(let s=0;s<t;s++){const t="Step_"+("00"+s).slice(-3),r=e.open(t);this.chain.push(r)}}else{const t=e.open("Chain");this.chain=t.chain}}},mlnet.TextLoader=class{constructor(e){const t=e.reader;t.int32(),this.MaxRows=t.int64(),this.Flags=t.uint32(),this.InputSize=t.int32();const s=t.int32();this.Separators=[];for(let e=0;e<s;e++)this.Separators.push(String.fromCharCode(t.uint16()));this.Bindinds=new mlnet.TextLoader.Bindinds(e)}},mlnet.TextLoader.Bindinds=class{constructor(e){const t=e.reader.int32();for(let e=0;e<t;e++);}},mlnet.CalibratedPredictorBase=class{constructor(e,t){this.SubPredictor=e,this.Calibrator=t}},mlnet.ValueMapperCalibratedPredictorBase=class extends mlnet.CalibratedPredictorBase{constructor(e,t){super(e,t)}},mlnet.CalibratedModelParametersBase=class{constructor(e){this.Predictor=e.open("Predictor"),this.Calibrator=e.open("Calibrator")}},mlnet.ValueMapperCalibratedModelParametersBase=class extends mlnet.CalibratedModelParametersBase{constructor(e){super(e)}},mlnet.CalibratedPredictor=class extends mlnet.ValueMapperCalibratedPredictorBase{constructor(e){super(e.open("Predictor"),e.open("Calibrator"))}},mlnet.ParameterMixingCalibratedModelParameters=class extends mlnet.ValueMapperCalibratedModelParametersBase{constructor(e){super(e)}},mlnet.FieldAwareFactorizationMachineModelParameters=class{constructor(e){const t=e.reader;this.Norm=t.boolean(),this.FieldCount=t.int32(),this.FeatureCount=t.int32(),this.LatentDim=t.int32(),this.LinearWeights=t.float32s(t.int32()),this.LatentWeights=t.float32s(t.int32())}},mlnet.KMeansModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this.k=t.int32(),this.Dimensionality=t.int32(),this.Centroids=[];for(let s=0;s<this.k;s++){const s=e.modelVersionWritten>=65538?t.int32():this.Dimensionality,r=s<this.Dimensionality?t.int32s(s):null,n=t.float32s(s);this.Centroids.push({indices:r,values:n})}}},mlnet.PcaModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader;this.Dimension=t.int32(),this.Rank=t.int32();const s=t.boolean();this.Mean=s?t.float32s(this.Dimension):[],this.EigenVectors=[];for(let e=0;e<this.Rank;++e)this.EigenVectors.push(t.float32s(this.Dimension))}},mlnet.TreeEnsembleModelParameters=class extends mlnet.ModelParametersBase{constructor(e){super(e);const t=e.reader,s=e.modelVersionWritten>=this.VerDefaultValueSerialized,r=e.modelVersionWritten>=this.VerCategoricalSplitSerialized;this.TrainedEnsemble=new mlnet.InternalTreeEnsemble(e,s,r),this.InnerOptions=e.string(null),e.modelVersionWritten>=this.verNumFeaturesSerialized&&(this.NumFeatures=t.int32())}},mlnet.InternalTreeEnsemble=class{constructor(e,t,s){const r=e.reader;this.Trees=[];const n=r.int32();for(let i=0;i<n;i++)switch(r.byte()){case mlnet.InternalTreeEnsemble.TreeType.Regression:this.Trees.push(new mlnet.InternalRegressionTree(e,t,s));break;case mlnet.InternalTreeEnsemble.TreeType.FastForest:this.Trees.push(new mlnet.InternalQuantileRegressionTree(e,t,s));break;case mlnet.InternalTreeEnsemble.TreeType.Affine:throw new mlnet.Error("Affine regression trees unsupported");default:throw new mlnet.Error("Unknown ensemble tree type.")}this.Bias=r.float64(),this.FirstInputInitializationContent=e.string(null)}},mlnet.InternalRegressionTree=class{constructor(e,t,s){const r=e.reader;if(this.NumLeaves=r.int32(),this.MaxOuptut=r.float64(),this.Weight=r.float64(),this.LteChild=r.int32s(r.int32()),this.GtChild=r.int32s(r.int32()),this.SplitFeatures=r.int32s(r.int32()),s){const e=r.int32s(r.int32());if(e.length>0){this.CategoricalSplitFeatures=[],this.CategoricalSplitFeatureRanges=[];for(const t of e)this.CategoricalSplitFeatures[t]=r.int32s(r.int32()),this.CategoricalSplitFeatureRanges[t]=r.int32s(2)}}this.Thresholds=r.uint32s(r.int32()),this.RawThresholds=r.float32s(r.int32()),this.DefaultValueForMissing=t?r.float32s(r.int32()):null,this.LeafValues=r.float64s(r.int32()),this.SplitGain=r.float64s(r.int32()),this.GainPValue=r.float64s(r.int32()),this.PreviousLeafValue=r.float64s(r.int32())}},mlnet.InternalTreeEnsemble.TreeType={Regression:0,Affine:1,FastForest:2},mlnet.TreeEnsembleModelParametersBasedOnRegressionTree=class extends mlnet.TreeEnsembleModelParameters{constructor(e){super(e)}},mlnet.FastTreeTweedieModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65537}get VerDefaultValueSerialized(){return 65538}get VerCategoricalSplitSerialized(){return 65539}},mlnet.FastTreeRankingModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FastTreeBinaryModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FastTreeRegressionModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.LightGbmRegressionModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.LightGbmBinaryModelParameters=class extends mlnet.TreeEnsembleModelParametersBasedOnRegressionTree{constructor(e){super(e)}get VerNumFeaturesSerialized(){return 65538}get VerDefaultValueSerialized(){return 65540}get VerCategoricalSplitSerialized(){return 65541}},mlnet.FeatureWeightsCalibratedModelParameters=class extends mlnet.ValueMapperCalibratedModelParametersBase{constructor(e){super(e)}},mlnet.FastTreePredictionWrapper=class{constructor(){}},mlnet.FastForestClassificationPredictor=class extends mlnet.FastTreePredictionWrapper{constructor(e){super(e)}},mlnet.PlattCalibrator=class{constructor(e){const t=e.reader;this.ParamA=t.float64(),this.ParamB=t.float64()}},mlnet.Codec=class{constructor(e){this.name=e.string();const t=e.leb128(),s=e.bytes(t);switch(e=new mlnet.Reader(s),this.name){case"Boolean":case"Single":case"Double":case"Byte":case"Int32":case"UInt32":case"Int64":case"TextSpan":break;case"VBuffer":this.itemType=new mlnet.Codec(e),this.dims=e.int32s(e.int32());break;case"Key":case"Key2":this.itemType=new mlnet.Codec(e),this.count=e.uint64();break;default:throw new mlnet.Error("Unknown codec '"+this.name+"'.")}}read(e,t){const s=[];switch(this.name){case"Single":for(let r=0;r<t;r++)s.push(e.float32());break;case"Int32":for(let r=0;r<t;r++)s.push(e.int32());break;case"Int64":for(let r=0;r<t;r++)s.push(e.int64());break;default:throw new mlnet.Error("Unknown codec read operation '"+this.name+"'.")}return s}},mlnet.SequentialTransformerBase=class{constructor(e){const t=e.reader;this.WindowSize=t.int32(),this.InitialWindowSize=t.int32(),this.inputs=[],this.inputs.push({name:e.string()}),this.outputs=[],this.outputs.push({name:e.string()}),this.ConfidenceLowerBoundColumn=t.string(),this.ConfidenceUpperBoundColumn=t.string(),this.Type=new mlnet.Codec(t)}},mlnet.AnomalyDetectionStateBase=class{constructor(e){const t=e.reader;this.LogMartingaleUpdateBuffer=mlnet.AnomalyDetectionStateBase._deserializeFixedSizeQueueDouble(t),this.RawScoreBuffer=mlnet.AnomalyDetectionStateBase._deserializeFixedSizeQueueDouble(t),this.LogMartingaleValue=t.float64(),this.SumSquaredDist=t.float64(),this.MartingaleAlertCounter=t.int32()}static _deserializeFixedSizeQueueDouble(e){e.int32();const t=e.int32(),s=[];for(let r=0;r<t;r++)s.push(e.float64());return s}},mlnet.SequentialAnomalyDetectionTransformBase=class extends mlnet.SequentialTransformerBase{constructor(e){super(e);const t=e.reader;this.Martingale=t.byte(),this.ThresholdScore=t.byte(),this.Side=t.byte(),this.PowerMartingaleEpsilon=t.float64(),this.AlertThreshold=t.float64(),this.State=new mlnet.AnomalyDetectionStateBase(e)}},mlnet.TimeSeriesUtils=class{static deserializeFixedSizeQueueSingle(e){e.int32();const t=e.int32(),s=[];for(let r=0;r<t;r++)s.push(e.float32());return s}},mlnet.IidAnomalyDetectionBase=class extends mlnet.SequentialAnomalyDetectionTransformBase{constructor(e){super(e);const t=e.reader;this.WindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(t),this.InitialWindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(t)}},mlnet.IidAnomalyDetectionBaseWrapper=class{constructor(e){const t=new mlnet.IidAnomalyDetectionBase(e);for(const e of Object.keys(t))this[e]=t[e]}},mlnet.IidChangePointDetector=class extends mlnet.IidAnomalyDetectionBaseWrapper{constructor(e){super(e)}},mlnet.IidSpikeDetector=class extends mlnet.IidAnomalyDetectionBaseWrapper{constructor(e){super(e)}},mlnet.SequenceModelerBase=class{constructor(){}},mlnet.RankSelectionMethod={Fixed:0,Exact:1,Fact:2},mlnet.AdaptiveSingularSpectrumSequenceModelerInternal=class extends mlnet.SequenceModelerBase{constructor(e){super(e);const t=e.reader;this._seriesLength=t.int32(),this._windowSize=t.int32(),this._trainSize=t.int32(),this._rank=t.int32(),this._discountFactor=t.float32(),this._rankSelectionMethod=t.byte();const s=t.byte();this._alpha=t.float32s(t.int32()),e.modelVersionReadable>=65538&&(this._state=t.float32s(t.int32())),this.ShouldComputeForecastIntervals=t.byte(),this._observationNoiseVariance=t.float32(),this._autoregressionNoiseVariance=t.float32(),this._observationNoiseMean=t.float32(),this._autoregressionNoiseMean=t.float32(),e.modelVersionReadable>=65538&&(this._nextPrediction=t.float32()),this._maxRank=t.int32(),this._shouldStablize=t.byte(),this._shouldMaintainInfo=t.byte(),this._maxTrendRatio=t.float64(),s&&(this._wTrans=t.float32s(t.int32()),this._y=t.float32s(t.int32())),this._buffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(t)}},mlnet.SequentialForecastingTransformBase=class extends mlnet.SequentialTransformerBase{constructor(e){super(e);const t=e.reader;this._outputLength=t.int32()}},mlnet.SsaForecastingBaseWrapper=class extends mlnet.SequentialForecastingTransformBase{constructor(e){super(e);const t=e.reader;this.IsAdaptive=t.boolean(),this.Horizon=t.int32(),this.ConfidenceLevel=t.float32(),this.WindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(t),this.InitialWindowedBuffer=mlnet.TimeSeriesUtils.deserializeFixedSizeQueueSingle(t),this.Model=e.open("SSA")}},mlnet.SsaForecastingTransformer=class extends mlnet.SsaForecastingBaseWrapper{constructor(e){super(e)}},mlnet.ColumnSelectingTransformer=class{constructor(e){const t=e.reader;if(e.check("DRPCOLST",65538,65538))throw new mlnet.Error("'LoadDropColumnsTransform' not supported.");if(e.check("CHSCOLSF",65537,65537)){t.int32(),this.KeepHidden=this._getHiddenOption(t.byte());const s=t.int32();this.inputs=[];for(let r=0;r<s;r++){const s=e.string();this.inputs.push(s),e.string(),this._getHiddenOption(t.byte())}}else{const s=t.boolean();this.KeepHidden=t.boolean(),this.IgnoreMissing=t.boolean();const r=t.int32();this.inputs=[];for(let t=0;t<r;t++)this.inputs.push({name:e.string()});s?this.ColumnsToKeep=this.inputs:this.ColumnsToDrop=this.inputs}}_getHiddenOption(e){switch(e){case 1:return!0;case 2:return!1;default:throw new mlnet.Error("Unsupported hide option specified")}}},mlnet.XGBoostMulticlass=class{},mlnet.NltTokenizeTransform=class{},mlnet.DropColumnsTransform=class{},mlnet.StopWordsTransform=class{},mlnet.CSharpTransform=class{},mlnet.GenericScoreTransform=class{},mlnet.NormalizeTransform=class{},mlnet.CdfColumnFunction=class{constructor(){}},mlnet.MultiClassNetPredictor=class{},mlnet.ProtonNNMCPred=class{},mlnet.Error=class extends Error{constructor(e){super(e),this.name="ML.NET Error"}},module&&module.exports&&(module.exports.ModelFactory=mlnet.ModelFactory);