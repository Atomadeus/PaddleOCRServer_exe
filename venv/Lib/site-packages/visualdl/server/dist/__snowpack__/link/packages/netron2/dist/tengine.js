var tengine=tengine||{},base=base||require("./base");tengine.ModelFactory=class{match(t){if("tmfile"===t.identifier.split(".").pop().toLowerCase()){const i=t.buffer;if(i.length>4&&(i[0]|i[1]<<8)<4)return!0}return!1}open(t,i){return tengine.Metadata.open(i).then((i=>{const e=t.identifier.toLowerCase();try{const e=t.buffer,s=e[0]|e[1]<<8,n=e[2]|e[3]<<8;if(2!==s)throw new tengine.Error("Unsupported format version 'v"+s.toString()+"."+n.toString()+"'.");return new tengine.Model(i,e)}catch(t){const i=t&&t.message?t.message:t.toString();throw new tengine.Error(i.replace(/\.$/,"")+" in '"+e+"'.")}}))}},tengine.Model=class{constructor(t,i){const e=new tengine.ModelFileReader(i);this._version=e.version,this._source=e.source,this._graphs=e.graphs.map((i=>new tengine.Graph(t,i)))}get format(){return"Tengine v"+this._version}get source(){return this._source}get graphs(){return this._graphs}},tengine.Graph=class{constructor(t,i){this._name=i.id.toString(),this._inputs=[],this._outputs=[],this._nodes=[];const e=i.tensors.map((t=>new tengine.Argument(t)));for(const t of i.inputs){const i=e[t];this._inputs.push(new tengine.Parameter(i.name,!0,[i]))}for(const t of i.outputs){const i=e[t];i.type&&i.type.shape&&i.type.shape.dimensions&&0==i.type.shape.dimensions.length&&null!==i.initializer||this._outputs.push(new tengine.Parameter(i.name,!0,[i]))}for(const s of i.nodes)"INPUT"!==s.type&&this._nodes.push(new tengine.Node(t,s,e))}get name(){return this._name}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},tengine.Parameter=class{constructor(t,i,e){this._name=t,this._visible=i,this._arguments=e}get name(){return this._name}get visible(){return this._visible}get arguments(){return this._arguments}},tengine.Argument=class{constructor(t){this._name=t.name,this._type=new tengine.TensorType(t.dataType,new tengine.TensorShape(t.dims)),this._initializer=2===t.type?new tengine.Tensor(this._type,t.buffer):null}get name(){return this._name}get type(){return this._initializer?this._initializer.type:this._type}get quantization(){return null}get initializer(){return this._initializer}},tengine.Node=class{constructor(t,i,e){this._metadata=t,this._name=i.name,this._type=i.type+(i.version&&1!==i.version?":"+i.version.toString():""),this._inputs=[],this._outputs=[],this._attributes=[];const s=t.type(this._type);for(let t=0;t<i.params.length;t++){const e=s&&s.attributes&&t<s.attributes.length?s.attributes[t]:null,n=e?e.name:t.toString();this._attributes.push(new tengine.Attribute(e,n,i.params[t]))}const n=i.inputs;let a=0;if(s&&s.inputs){for(const t of s.inputs)if(a<n.length||"optional"!=t.option){const i="variadic"==t.option?n.length-a:1,s=n.slice(a,a+i).filter((i=>""!=i||"optional"!=t.option)).map((t=>e[t]));this._inputs.push(new tengine.Parameter(t.name,!0,s)),a+=i}}else this._inputs=this._inputs.concat(n.slice(a).map(((t,i)=>{const s=a+i==0?"input":(a+i).toString();return new tengine.Parameter(s,!0,[e[t]])})));const r=i.outputs;let o=0;if(s&&s.outputs){for(const t of s.outputs)if(o<r.length||"optional"!=t.option){const i="variadic"==t.option?r.length-o:1,s=r.slice(o,o+i).map((t=>e[t]));this._outputs.push(new tengine.Parameter(t.name,!0,s)),o+=i}}else this._outputs=this._outputs.concat(r.slice(o).map(((t,i)=>{const s=o+i==0?"output":(o+i).toString();return new tengine.Parameter(s,!0,[e[t]])})))}get type(){return this._type.split(":")[0]}get name(){return this._name}get metadata(){return this._metadata.type(this._type)}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}},tengine.Attribute=class{constructor(t,i,e){this._type="",this._name=i,this._value=e,t&&(this._name=t.name,t.type&&(this._type=t.type),(Object.prototype.hasOwnProperty.call(t,"visible")&&!t.visible||Object.prototype.hasOwnProperty.call(t,"default")&&(this._value==t.default||this._value&&this._value.toString()==t.default.toString()))&&(this._visible=!1))}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return 0!=this._visible}},tengine.Tensor=class{constructor(t,i,e){this._type=t,this._data=i,this._kind=e}get kind(){return this._kind}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const i=this._decode(t,0);return JSON.stringify(i,null,4)}_context(){const t={index:0,count:0,state:null};if("?"==this._type.dataType)return t.state="Tensor has unknown data type.",t;if(!this._type.shape||this._type.shape.dimensions&&0==this._type.shape.dimensions.length)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"int8":case"uint8":case"float16":case"float32":case"int32":case"int16":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,i){const e=0==t.shape.length?[1]:t.shape,s=[],n=e[i];if(i==e.length-1)for(let i=0;i<n;i++){if(t.count>t.limit)return s.push("..."),s;switch(this._type.dataType){case"float32":s.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++;break;case"float16":s.push(t.data.getFloat16(t.index,!0)),t.index+=2,t.count++;break;case"int8":s.push(t.data.getInt8(t.index,!0)),t.index+=1,t.count++;break;case"uint8":s.push(t.data.getUint8(t.index,!0)),t.index+=1,t.count++;break;case"int32":s.push(t.data.getInt32(t.index,!0)),t.index+=4,t.count++;break;case"int16":s.push(t.data.getInt16(t.index,!0)),t.index+=2,t.count++}}else for(let e=0;e<n;e++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,i+1))}return 0==t.shape.length?s[0]:s}},tengine.TensorType=class{constructor(t,i){switch(t){case 0:this._dataType="float32";break;case 1:this._dataType="float16";break;case 2:this._dataType="int8";break;case 3:this._dataType="uint8";break;case 4:this._dataType="int32";break;case 5:this._dataType="int16";break;default:throw new tengine.Error("Unknown data type'"+t+"'.")}this._shape=i}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},tengine.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map((t=>t?t.toString():"?")).join(",")+"]":""}},tengine.Metadata=class{static open(t){return tengine.Metadata._metadata?Promise.resolve(tengine.Metadata._metadata):t.request(null,"tengine-metadata.json","utf-8").then((t=>(tengine.Metadata._metadata=new tengine.Metadata(t),tengine.Metadata._metadata))).catch((()=>(tengine.Metadata._metadata=new tengine.Metadata(null),tengine.Metadata._metadata)))}constructor(t){if(this._map={},this._attributeCache={},t){const i=JSON.parse(t);if(i)for(const t of i)if(t.name&&t.schema){t.schema.name=t.name;const i=t.name+(t.version&&1!==t.version?":"+t.version.toString():"");this._map[i]=t.schema}}}type(t){return this._map[t]||null}attribute(t,i){let e=this._attributeCache[t];if(!e){e={};const i=this.type(t);if(i&&i.attributes&&i.attributes.length>0)for(const t of i.attributes)e[t.name]=t;this._attributeCache[t]=e}return e[i]||null}},tengine.ModelFileReader=class{constructor(t){const i=new Map,e=(t,e,s,n)=>{i.set(t.toString()+":"+e.toString(),{name:s,params:n})};e(0,1,"Accuracy",[]),e(1,1,"BatchNormalization",["f","f","i"]),e(2,1,"BilinearResize",["f","f","i"]),e(3,1,"Concat",["i"]),e(4,1,"Const",[]),e(5,1,"Convolution",["i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),e(6,1,"DeConvolution",["i","i","i","i","i","i","i","i","i","i","i","i","i"]),e(7,1,"DetectionOutput",["i","i","i","f","f"]),e(8,1,"DropOut",[]),e(9,1,"Eltwise",["i","i"]),e(10,1,"Flatten",["i"]),e(11,1,"FullyConnected",["i"]),e(12,1,"INPUT",[]),e(13,1,"LRN",["i","f","f","i","f"]),e(14,1,"Normalize",["i","i"]),e(15,1,"Permute",["i","i","i","i","i"]),e(16,1,"Pooling",["i","i","i","i","i","i","i","i","i","i","i"]),e(17,1,"Prelu",[]),e(18,1,"PriorBox",["f[]","f[]","f[]","f[]","i","i","i","i","i","f","f","f","i","i"]),e(19,1,"Region",["i","i","i","i","f","f","f[]"]),e(20,1,"ReLU",["f"]),e(21,1,"ReLU6",[]),e(22,1,"Reorg",["i"]),e(23,1,"Reshape",["i","i","i","i","i","i"]),e(23,2,"Reshape",["i","i","i[]"]),e(24,1,"RoiPooling",["i","i","f"]),e(25,1,"RPN",["f[]","f[]","i","i","i","i","i","f","anchors"]),e(26,1,"Scale",["i","i","i"]),e(27,1,"Slice",["i","i[]","i[]","i[]","i","i","i","i","i"]),e(28,1,"SoftMax",["i"]),e(29,1,"Split",["i","i","boolean","boolean","i[]"]),e(30,1,"DetectionPostProcess",["i","i","f","f","i","f[]"]),e(31,1,"Gemm",["f","f","i","i"]),e(32,1,"Generic",["i","i","string"]),e(33,1,"Logistic",[]),e(34,1,"LSTM",["f","f","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i","i"]),e(35,1,"RNN",["f","i","i","i","i","i","i","i","i","i"]),e(36,1,"TanH",[]),e(37,1,"Sigmoid",[]),e(38,1,"Squeeze",["i","i","i","i"]),e(39,1,"FusedbnScaleRelu",[]),e(40,1,"Pad",["i","i","i","i","i","i","i","i","i","f"]),e(41,1,"StridedSlice",["i","i","i","i","i","i","i","i","i","i","i","i"]),e(42,1,"ArgMax",["i"]),e(43,1,"ArgMin",["i"]),e(44,1,"TopKV2",["i","i"]),e(45,1,"Reduction",["i","i","i","i","i","i"]),e(46,1,"Max",[]),e(47,1,"Min",[]),e(48,1,"GRU",["f","i","i","i","i","i","i","i","i","i"]),e(49,1,"Addn","i"),e(50,1,"SwapAxis",["i","i"]),e(51,1,"Upsample",["f"]),e(52,1,"SpaceToBatchND",["i","i","i","i","i","i"]),e(53,1,"BatchToSpaceND",["i","i","i","i","i","i"]),e(54,1,"Resize",["f","f","i"]),e(55,1,"ShuffleChannel",["i"]),e(56,1,"Crop",["i","i","i","i","i","i","boolean","i","i"]),e(57,1,"ROIAlign",["i","i","f"]),e(58,1,"Psroipooling",["i","i","f","i"]),e(59,1,"Unary",["i"]),e(60,1,"Expanddims",["i"]),e(61,1,"Bias",["i"]),e(62,1,"Noop",[]),e(63,1,"Threshold",["f"]),e(64,1,"Hardsigmoid",["f","f"]),e(65,1,"Embed",["f","f","f","f"]),e(66,1,"InstanceNorm",["f"]),e(67,1,"MVN",["i","i","f"]),e(68,1,"Absval",[]),e(69,1,"Cast",["i","i"]),e(70,1,"HardSwish",["f","f"]),e(71,1,"Interp",["i","i","f","f","i"]),e(72,1,"SELU",["f","f"]),e(73,1,"ELU",["f"]),e(74,1,"BroadMul",[]),e(75,1,"Logical",["i"]),e(76,1,"Gather",["i","i"]),e(77,1,"Transpose",["i[]"]),e(78,1,"Comparison",["i"]),e(79,1,"SpaceToDepth",["i"]),e(80,1,"DepthToSpace",["i"]),e(81,1,"Reverse",[]),e(82,1,"SparseToDense",["i","i","i"]),e(83,1,"Ceil",[]),e(84,1,"SquaredDifference",[]),e(85,1,"Round",[]),e(86,1,"ZerosLike",[]),e(87,1,"Clip",["f","f"]),e(88,1,"MatMul",[]),e(89,1,"ReduceL2",["i","i"]),e(90,1,"Unsqueeze",["i[]"]),e(91,1,"Num",[]);const s=new tengine.BinaryReader(t);this._majorVersion=s.uint16(),this._minorVersion=s.uint16(),this._compileVersion=s.uint16(),s.skip(2),s.seek(s.uint32()),this._originalFormat=s.int32(),this._subFormat=s.int32(),this._graphs=[];const n=s.uint32s();for(const t of n){s.seek(t);const e={};e.id=s.int32(),e.graphLayout=s.int32(),e.originalLayout=s.int32(),e.inputs=s.uint32s(),e.outputs=s.uint32s();const n=s.uint32s(),a=s.uint32s(),r=s.uint32s();e.name=s.string(),e.nodes=[],e.tensors=[],this._graphs.push(e);for(const t of n){s.seek(t);const n={};n.id=s.int32(),n.inputs=s.uint32s(),n.outputs=s.uint32s();const a=s.int32();n.name=s.string();const r=s.uint32s();n.dynamicShape=!!s.boolean(),s.seek(a),n.version=s.int32();const o=s.int32(),h=s.uint32(),u=o.toString()+":"+n.version.toString(),p=i.has(u)?i.get(u):null;n.type=p?p.name:o.toString();const c=p?p.params:[];if(n.params=[],h){s.seek(h);for(const t of c)switch("boolean"!==t&&s.align(4),t){case"i":n.params.push(s.int32());break;case"f":n.params.push(s.float32());break;case"i[]":n.params.push(s.int32s());break;case"f[]":n.params.push(s.float32s());break;case"boolean":n.params.push(s.boolean());break;case"string":n.params.push(s.string());break;case"anchors":n.params.push(s.anchors(4));break;default:throw new tengine.Error("Unsupported param type '"+t+"' in '"+n.type+"'.")}}"Slice"===n.type&&(n.params[6]=5==this._originalFormat?n.params[6]:0),n.attributes=[];for(const t of r){s.seek(t);const i=s.string(),e=s.string(),a=s.int32();n.attributes.push({name:i,value:e,type:a})}"Const"!==n.type&&e.nodes.push(n)}const o=[];for(const t of r){s.seek(t);const i=s.uint32();s.seek(s.int32()),o.push(s.bytes(i))}for(const t of a){s.seek(t);const i={};i.id=s.int32(),i.buffer=o[s.int32()],i.dims=s.int32s(),i.name=s.string();const n=s.int32();i.layout=s.int32(),i.type=s.int32(),i.dataType=s.int32(),n&&(s.seek(n),i.quantparams={zeroPoint:s.int32(),scale:s.float32(),width:s.int32()}),e.tensors.push(i)}for(const t of e.nodes)if("Convolution"===t.type)switch(e.graphLayout){case 0:t.params[6]=e.tensors[t.inputs[1]].dims[1];break;case 1:t.params[6]=e.tensors[t.inputs[1]].dims[3]}}}get version(){return this._majorVersion+"."+this._minorVersion}get source(){switch(this._originalFormat){case 0:return"";case 1:return"Tengine";case 2:return"Caffe";case 3:return"ONNX";case 4:return"MXNet";case 5:return"TensorFlow";case 6:return"TensorFlow Lite";case 7:return"Darknet";case 8:return"DLA v"+this._subFormat;default:throw new tengine.Error("Unknown source '"+this._originalFormat.toString()+"'.")}}get graphs(){return this._graphs}},tengine.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}seek(t){if(this._position=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new tengine.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}align(t){this._position%t!=0&&this.skip(t-this._position%t)}bytes(t){const i=this._position;return this.skip(t),this._buffer.slice(i,this._position)}byte(){return this.skip(1),this._dataView.getUint8(this._position)}boolean(){return 0==this.byte()}uint16(){const t=this._position;return this.skip(2),this._dataView.getUint16(t,!0)}uint32(){const t=this._position;return this.skip(4),this._dataView.getUint32(t,!0)}uint32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.uint32());this.seek(e)}return t}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.int32());this.seek(e)}return t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}float32s(){const t=[],i=this.uint32();if(i){const e=this._position;this.seek(i);const s=this.uint32();for(let i=0;i<s;i++)t.push(this.float32());this.seek(e)}return t}anchors(t){const i=[],e=this.uint32();if(e){const s=this._position;this.seek(e);const n=this.uint32();for(let e=0;e<n;e++){const e=[];for(let i=0;i<t;i++)e.push(this.float32());i.push(e)}this.seek(s)}return i}string(){const t=this.uint32();let i="";if(t){const e=this._position;this.seek(t);const s=this.uint32();this.seek(this.uint32());for(let t=0;t<s-1;t++)i+=String.fromCharCode(this._buffer[this._position++]);this.seek(e)}return i}},tengine.Error=class extends Error{constructor(t){super(t),this.name="Error loading Tengine model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=tengine.ModelFactory);