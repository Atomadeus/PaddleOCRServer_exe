var barracuda=barracuda||{},base=base||require("./base"),long=long||{Long:require("long")};barracuda.ModelFactory=class{match(t){if("nn"===t.identifier.split(".").pop().toLowerCase()){const e=t.buffer;if(e.length>12&&e[0]<=16&&e.subarray(1,8).every((t=>0==t)))return!0}return!1}open(t){return barracuda.Metadata.open().then((e=>{try{const s=new barracuda.NNModel(t.buffer);return new barracuda.Model(e,s)}catch(e){const s=t.identifier.toLowerCase(),r=e&&e.message?e.message:e.toString();throw new barracuda.Error(r.replace(/\.$/,"")+" in '"+s+"'.")}}))}},barracuda.Model=class{constructor(t,e){this._version=e.version.toString(),this._graphs=[new barracuda.Graph(t,e)]}get format(){return"Barracuda v"+this._version}get graphs(){return this._graphs}},barracuda.Graph=class{constructor(t,e){this._inputs=[],this._outputs=[],this._nodes=[];for(const t of e.inputs)this._inputs.push(new barracuda.Parameter(t.name,[new barracuda.Argument(t.name,new barracuda.TensorType(4,new barracuda.TensorShape(t.shape)))]));for(const t of e.outputs)this._outputs.push(new barracuda.Parameter(t,[new barracuda.Argument(t)]));const s=[],r=new Map;for(const t of e.layers)if(255!==t.type||t.inputs.length>0)s.push(t);else for(const e of t.tensors)r.set(e.name,new barracuda.Tensor(e));for(const e of s)this._nodes.push(new barracuda.Node(t,e,r))}get name(){return""}get inputs(){return this._inputs}get outputs(){return this._outputs}get nodes(){return this._nodes}},barracuda.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},barracuda.Argument=class{constructor(t,e,s){this._name=t,this._type=e||null,this._initializer=s||null}get name(){return this._name}get type(){return this._type}get initializer(){return this._initializer}},barracuda.Node=class{constructor(t,e,s){this._name=e.name||"",this._metadata=t.type(e.type)||{name:e.type.toString()},this._type=this._metadata.name,this._inputs=[],this._outputs=[],this._attributes=[];const r=Array.prototype.slice.call(this._metadata.inputs||["input"]);if(this._metadata.inputs&&1===this._metadata.inputs.length&&"inputs"===this._metadata.inputs[0])this._inputs.push(new barracuda.Parameter("inputs",e.inputs.map((t=>{const e=s.has(t)?s.get(t):null;return new barracuda.Argument(t,e?e.type:null,e)}))));else if(e.inputs)for(let t=0;t<e.inputs.length;t++){const a=e.inputs[t],i=s.has(a)?s.get(a):null;this._inputs.push(new barracuda.Parameter(r.length>0?r.shift():t.toString(),[new barracuda.Argument(a,i?i.type:null,i)]))}if(e.tensors)for(let t=0;t<e.tensors.length;t++){const s=e.tensors[t],a=new barracuda.Tensor(s);this._inputs.push(new barracuda.Parameter(r.length>0?r.shift():t.toString(),[new barracuda.Argument(s.name,a.type,a)]))}if(void 0!==e.inputs&&this._outputs.push(new barracuda.Parameter("output",[new barracuda.Argument(this._name)])),!barracuda.Activation[e.activation])throw new barracuda.Error("Unknown activation '"+e.activation+"'.");"Activation"===this._type?this._type=barracuda.Activation[e.activation]:0!==e.activation&&(this._chain=[new barracuda.Node(t,{type:50,activation:e.activation},s)]);const a=(t,e,s,r)=>{void 0!==s&&(Array.isArray(r)&&Array.isArray(s)&&s.length==r.length&&s.every(((t,e)=>t===r[e]))||"function"==typeof r&&r(s)||r!==s&&this._attributes.push(new barracuda.Attribute(t,e,s)))};a("strides","int32[]",e.strides,[]),a("pads","int32[]",e.pads,(t=>Array.isArray(t)&&(t.every((t=>0===t))||t.every((t=>-1===t))))),a("size","int32[]",e.pool_size,[]),a("alpha","float32",e.alpha,1),a("beta","float32",e.beta,0),a("axis","int32",e.axis,-1)}get type(){return this._type}get name(){return this._name}get metadata(){return this._metadata}get attributes(){return this._attributes}get inputs(){return this._inputs}get outputs(){return this._outputs}get chain(){return this._chain}},barracuda.Attribute=class{constructor(t,e,s){this._name=t,this._type=e,this._value=s}get type(){return this._type}get name(){return this._name}get value(){return this._value}get visible(){return!0}},barracuda.Tensor=class{constructor(t){this._type=new barracuda.TensorType(t.itemsize,new barracuda.TensorShape(t.shape)),this._data=t.data}get kind(){return""}get type(){return this._type}get state(){return this._context().state||null}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return JSON.stringify(e,null,4)}_context(){const t={index:0,count:0,state:null};if("?"==this._type.dataType)return t.state="Tensor has unknown data type.",t;if(!this._type.shape||this._type.shape.dimensions&&0==this._type.shape.dimensions.length)return t.state="Tensor has no dimensions.",t;if(!this._data)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"float32":t.data=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength);break;default:t.state="Tensor data type is not implemented."}return t.dataType=this._type.dataType,t.shape=this._type.shape.dimensions,t}_decode(t,e){const s=0==t.shape.length?[1]:t.shape,r=[],a=s[e];if(e==s.length-1)for(let e=0;e<a;e++){if(t.count>t.limit)return r.push("..."),r;switch(this._type.dataType){case"float32":r.push(t.data.getFloat32(t.index,!0)),t.index+=4,t.count++}}else for(let s=0;s<a;s++){if(t.count>t.limit)return r.push("..."),r;r.push(this._decode(t,e+1))}return 0==t.shape.length?r[0]:r}},barracuda.TensorType=class{constructor(t,e){switch(t){case 4:this._dataType="float32";break;default:throw new barracuda.Error("Unsupported data type size '"+t.toString()+"'.")}this._shape=e}get dataType(){return this._dataType}get shape(){return this._shape}toString(){return this._dataType+this._shape.toString()}},barracuda.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions?"["+this._dimensions.map((t=>t?t.toString():"?")).join(",")+"]":""}},barracuda.NNModel=class{constructor(t){const e=new barracuda.BinaryReader(t);this._version=e.int32(),e.int32(),this._inputs=[];const s=e.int32();for(let t=0;t<s;t++)this._inputs.push({name:e.string(),shape:e.shape()});this._outputs=e.strings(),this._memories=[];const r=e.int32();for(let t=0;t<r;t++)this._memories.push({shape:e.shape(),in:e.string(),out:e.string()});this._layers=[];const a=e.int32();for(let t=0;t<a;t++){const t={};t.name=e.string(),t.type=e.int32(),t.activation=e.int32(),e.int32(),e.int32(),t.pads=e.int32s(),t.strides=e.int32s(),t.pool_size=e.int32s(),t.axis=e.int32(),t.alpha=e.float32(),t.beta=e.float32(),e.int32(),t.inputs=e.strings(),t.tensors=[];const s=e.int32();for(let r=0;r<s;r++)t.tensors.push({name:e.string(),shape:e.shape(),offset:e.int64(),itemsize:e.int32(),length:e.int32()});this._layers.push(t)}for(const t of this._layers)for(const s of t.tensors)s.data=e.bytes(s.offset*s.itemsize,s.length*s.itemsize)}get version(){return this._version}get inputs(){return this._inputs}get outputs(){return this._outputs}get memories(){return this._memories}get layers(){return this._layers}},barracuda.Activation={0:"Linear",1:"Relu",2:"Softmax",3:"Tanh",4:"Sigmoid",5:"Elu",6:"Relu6",7:"LeakyRelu",8:"Selu",9:"Swish",10:"LogSoftmax",11:"Softplus",12:"Softsign",100:"Abs",101:"Neg",102:"Ceil",104:"Floor",111:"Sqrt",113:"Exp",114:"Log",200:"Acos",201:"Acosh",202:"Asin",203:"Asinh",204:"Atan",205:"Atanh",206:"Cos",207:"Cosh",208:"Sin",209:"Sinh",210:"Tan"},barracuda.BinaryReader=class{constructor(t){this._buffer=t,this._dataView=new DataView(t.buffer,t.byteOffset,t.byteLength),this._position=0}skip(t){if(this._position+=t,this._position>this._buffer.length)throw new barracuda.Error("Expected "+(this._position-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.")}bytes(t,e){const s=this._position+t,r=s+e;if(r>this._buffer.length)throw new barracuda.Error("Expected "+(r-this._buffer.length)+" more bytes. The file might be corrupted. Unexpected end of file.");return this._buffer.slice(s,r)}int32(){const t=this._position;return this.skip(4),this._dataView.getInt32(t,!0)}int32s(){const t=[],e=this.int32();for(let s=0;s<e;s++)t.push(this.int32());return t}int64(){const t=this.int32();if(0!==this.int32())throw new barracuda.Error("Invalid int64 value.");return t}float32(){const t=this._position;return this.skip(4),this._dataView.getFloat32(t,!0)}string(){let t="";const e=this.int32();let s=this._position;this.skip(e);for(let r=0;r<e;r++)t+=String.fromCharCode(this._buffer[s++]);return t}strings(){const t=[],e=this.int32();for(let s=0;s<e;s++)t.push(this.string());return t}shape(){return this.int32s()}},barracuda.Metadata=class{static open(){return barracuda.Metadata._metadata=barracuda.Metadata._metadata||new barracuda.Metadata,Promise.resolve(barracuda.Metadata._metadata)}constructor(){this._map=new Map,this._register(0,"Nop",""),this._register(1,"Dense","Layer",["input","kernel","bias"]),this._register(2,"MatMul","",["input","kernel","bias"]),this._register(20,"Conv2D","Layer",["input","kernel","bias"]),this._register(21,"DepthwiseConv2dNative","Layer",["input","kernel","bias"]),this._register(22,"Conv2DBackpropInput",""),this._register(23,"Upsample2D",""),this._register(25,"MaxPool","Pool"),this._register(26,"AvgPool","Pool"),this._register(28,"GlobalAvgPool","Pool"),this._register(29,"Pad",""),this._register(50,"Activation","Activation"),this._register(51,"ScaleBias","Normalization",["input","scale","bias"]),this._register(52,"InstanceNormalization","Normalization"),this._register(53,"LRN","Normalization"),this._register(64,"RandomStandardNormal",""),this._register(65,"RandomUniform",""),this._register(67,"OneHot",""),this._register(100,"Add","",["inputs"]),this._register(101,"Sub","",["inputs"]),this._register(102,"Mul","",["inputs"]),this._register(103,"RealDiv","",["inputs"]),this._register(104,"Pow","",["inputs"]),this._register(110,"Minimum","",["inputs"]),this._register(111,"Maximum","",["inputs"]),this._register(124,"Max","",["inputs"]),this._register(125,"Mean","",["inputs"]),this._register(126,"Min","",["inputs"]),this._register(127,"Prod","",["inputs"]),this._register(128,"Sum","",["inputs"]),this._register(200,"Flatten","Shape"),this._register(201,"Reshape","Shape"),this._register(210,"Concat","Tensor",["inputs"]),this._register(211,"StridedSlice","Shape")}_register(t,e,s,r){this._map.set(t,{name:e,category:s,inputs:r})}type(t){return this._map.has(t)?this._map.get(t):null}},barracuda.Error=class extends Error{constructor(t){super(t),this.name="Error loading Barracuda model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=barracuda.ModelFactory);