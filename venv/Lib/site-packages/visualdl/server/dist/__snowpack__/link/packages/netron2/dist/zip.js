var zip=zip||{};zip.Archive=class{constructor(t){if(this._entries=[],t.length<4||80!=t[0]||75!=t[1])throw new zip.Error("Invalid Zip archive.");let e=null;for(let i=t.length-4;i>=0;i--)if(80===t[i]&&75===t[i+1]&&5===t[i+2]&&6===t[i+3]){e=new zip.Reader(t,i+4,t.length);break}if(!e)throw new zip.Error("End of central directory not found.");for(e.skip(12),e.position=e.uint32();e.match([80,75,1,2]);)this._entries.push(new zip.Entry(e))}get entries(){return this._entries}},zip.Entry=class{constructor(t){if(t.uint16(),t.skip(2),this._flags=t.uint16(),1==(1&this._flags))throw new zip.Error("Encrypted entries not supported.");this._compressionMethod=t.uint16(),t.uint32(),t.uint32(),this._compressedSize=t.uint32(),this._size=t.uint32();let e=t.uint16(),i=t.uint16();const s=t.uint16();t.uint16(),t.uint16(),t.uint32();const r=t.uint32();t.skip(e),t.skip(i),t.bytes(s);const n=t.position;if(t.position=r,!t.match([80,75,3,4]))throw new zip.Error("Invalid local file header signature.");t.skip(22),e=t.uint16(),i=t.uint16();const o=t.bytes(e);this._name="";for(const t of o)this._name+=String.fromCharCode(t);t.skip(i),this._compressedData=t.bytes(this._compressedSize),t.position=n}get name(){return this._name}get data(){if(!this._data){switch(this._compressionMethod){case 0:if(this._size!=this._compressedSize)throw new zip.Error("Invalid compression size.");this._data=new Uint8Array(this._compressedData.length),this._data.set(this._compressedData);break;case 8:if(this._data=(new zip.Inflater).inflateRaw(this._compressedData),this._size!=this._data.length)throw new zip.Error("Invalid uncompressed size.");break;default:throw new zip.Error("Invalid compression method.")}delete this._size,delete this._compressedData}return this._data}},zip.HuffmanTree=class{constructor(){this.table=new Uint16Array(16),this.symbol=new Uint16Array(288),zip.HuffmanTree._offsets=zip.HuffmanTree._offsets||new Uint16Array(16)}build(t,e,i){for(let t=0;t<16;++t)this.table[t]=0;for(let s=0;s<i;++s)this.table[t[e+s]]++;this.table[0]=0;let s=0;for(let t=0;t<16;t++)zip.HuffmanTree._offsets[t]=s,s+=this.table[t];for(let s=0;s<i;s++)t[e+s]&&(this.symbol[zip.HuffmanTree._offsets[t[e+s]]++]=s)}static initialize(){if(!zip.HuffmanTree.staticLiteralLengthTree){zip.HuffmanTree.staticLiteralLengthTree=new zip.HuffmanTree,zip.HuffmanTree.staticLiteralLengthTree.table=new Uint8Array([0,0,0,0,0,0,0,24,152,112,0,0,0,0,0,0]);for(let t=0;t<24;++t)zip.HuffmanTree.staticLiteralLengthTree.symbol[t]=256+t;for(let t=0;t<144;++t)zip.HuffmanTree.staticLiteralLengthTree.symbol[24+t]=t;for(let t=0;t<8;++t)zip.HuffmanTree.staticLiteralLengthTree.symbol[168+t]=280+t;for(let t=0;t<112;++t)zip.HuffmanTree.staticLiteralLengthTree.symbol[176+t]=144+t;zip.HuffmanTree.staticDistanceTree=new zip.HuffmanTree,zip.HuffmanTree.staticDistanceTree.table=new Uint8Array([0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0]),zip.HuffmanTree.staticDistanceTree.symbol=new Uint8Array([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31])}}},zip.Inflater=class{inflate(t){if("object"==typeof process&&"object"==typeof process.versions&&void 0!==process.versions.node)return require("zlib").inflateSync(t);if("undefined"!=typeof pako)return pako.inflate(t);throw new zip.Error("zlib inflate not supported.")}inflateRaw(t){if("object"==typeof process&&"object"==typeof process.versions&&void 0!==process.versions.node)return require("zlib").inflateRawSync(t);if("undefined"!=typeof pako)return pako.inflateRaw(t);zip.Inflater.initilize(),zip.HuffmanTree.initialize();const e=new zip.BitReader(t),i=new zip.Ouptut,s=new zip.HuffmanTree,r=new zip.HuffmanTree;let n;do{switch(n=e.bits(3),n>>>1){case 0:this._inflateUncompressedBlock(e,i);break;case 1:this._inflateBlockData(e,i,zip.HuffmanTree.staticLiteralLengthTree,zip.HuffmanTree.staticDistanceTree);break;case 2:this._decodeTrees(e,s,r),this._inflateBlockData(e,i,s,r);break;default:throw new zip.Error("Unknown block type.")}}while(0==(1&n));return i.merge()}_inflateUncompressedBlock(t,e){for(;t.data>8;)t.position--,t.data-=8;t.data=0;const i=t.uint16();if(i!==(65535&~t.uint16()))throw new zip.Error("Invalid uncompressed block length.");const s=t.bytes(i);e.push(s),i>32768?(e.buffer.set(s.subarray(s.length-32768,s.length),0),e.position=32768):(e.reset(),e.buffer.set(s,e.position),e.position+=s.length)}_decodeTrees(t,e,i){const s=t.bits(5)+257,r=t.bits(5)+1,n=t.bits(4)+4;for(let t=0;t<19;t++)zip.Inflater._lengths[t]=0;for(let e=0;e<n;e++)zip.Inflater._lengths[zip.Inflater._codeOrder[e]]=t.bits(3);let o;zip.Inflater._codeTree.build(zip.Inflater._lengths,0,19);for(let e=0;e<s+r;){const i=t.symbol(zip.Inflater._codeTree);switch(i){case 16:{const i=zip.Inflater._lengths[e-1];for(o=t.bits(2)+3;o;o--)zip.Inflater._lengths[e++]=i;break}case 17:for(o=t.bits(3)+3;o;o--)zip.Inflater._lengths[e++]=0;break;case 18:for(o=t.bits(7)+11;o;o--)zip.Inflater._lengths[e++]=0;break;default:zip.Inflater._lengths[e++]=i}}e.build(zip.Inflater._lengths,0,s),i.build(zip.Inflater._lengths,s,r)}_inflateBlockData(t,e,i,s){const r=e.buffer;let n=e.position,o=n;for(;;){n>62464&&(e.position=n,e.push(new Uint8Array(r.subarray(o,n))),n=e.reset(),o=n);let a=t.symbol(i);if(256===a)return e.position=n,e.push(new Uint8Array(r.subarray(o,e.position))),void e.reset();if(a<256)r[n++]=a;else{a-=257;const e=t.bitsBase(zip.Inflater._lengthBits[a],zip.Inflater._lengthBase[a]),i=t.symbol(s);let o=n-t.bitsBase(zip.Inflater._distanceBits[i],zip.Inflater._distanceBase[i]);for(let t=0;t<e;t++)r[n++]=r[o++]}}}static initilize(){zip.HuffmanTree.staticLiteralLengthTree||(zip.Inflater._codeOrder=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],zip.Inflater._codeTree=new zip.HuffmanTree,zip.Inflater._lengths=new Uint8Array(320),zip.Inflater._lengthBits=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,6],zip.Inflater._lengthBase=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,323],zip.Inflater._distanceBits=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],zip.Inflater._distanceBase=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577])}},zip.Ouptut=class{constructor(){this._blocks=[],this.buffer=new Uint8Array(65536),this.position=0}reset(){return this.position>32768&&(this.buffer.set(this.buffer.subarray(this.position-32768,this.position),0),this.position=32768),this.position}push(t){this._blocks.push(t)}merge(){let t=0;for(const e of this._blocks)t+=e.length;const e=new Uint8Array(t);let i=0;for(const t of this._blocks)e.set(t,i),i+=t.length;return e}},zip.BitReader=class{constructor(t){this.buffer=t,this.position=0,this.data=0,this.value=0}bits(t){for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;const e=this.value&65535>>>16-t;return this.value>>>=t,this.data-=t,e}bitsBase(t,e){if(0==t)return e;for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;const i=this.value&65535>>>16-t;return this.value>>>=t,this.data-=t,i+e}bytes(t){const e=this.buffer.subarray(this.position,this.position+t);return this.position+=t,e}uint16(){const t=this.buffer[this.position]|this.buffer[this.position+1]<<8;return this.position+=2,t}symbol(t){for(;this.data<24;)this.value|=this.buffer[this.position++]<<this.data,this.data+=8;let e=0,i=0,s=0,r=this.value;const n=t.table;do{i=(i<<1)+(1&r),r>>>=1,s++,e+=n[s],i-=n[s]}while(i>=0);return this.value=r,this.data-=s,t.symbol[e+i]}},zip.Reader=class{constructor(t,e,i){this._buffer=t,this._position=e,this._end=i}match(t){if(this._position+t.length<=this._end)for(let e=0;e<t.length;e++)if(this._buffer[this._position+e]!=t[e])return!1;return this._position+=t.length,!0}get position(){return this._position}set position(t){this._position=t>=0?t:this._end+t}peek(){return this._position<this._end}skip(t){if(this._position+t>this._end)throw new zip.Error("Data not available.");this._position+=t}bytes(t){if(this._position+t>this._end)throw new zip.Error("Data not available.");t=void 0===t?this._end:t;const e=this._buffer.subarray(this._position,this._position+t);return this._position+=t,e}uint16(){if(this._position+2>this._end)throw new zip.Error("Data not available.");const t=this._buffer[this._position]|this._buffer[this._position+1]<<8;return this._position+=2,t}uint32(){return this.uint16()|this.uint16()<<16}},zip.Error=class extends Error{constructor(t){super(t),this.name="Zip Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.Archive=zip.Archive,module.exports.Inflater=zip.Inflater);