var npz=npz||{},long=long||{Long:require("long")};npz.ModelFactory=class{match(t){if("npz"===t.identifier.split(".").pop().toLowerCase()){const e=t.entries("zip");return e.length>0&&e.every((t=>t.name.endsWith(".npy")))}return!1}open(t,e){return e.require("./numpy").then((n=>e.require("./pickle").then((e=>{const i=t.identifier;try{const i=[],s=new Map,a=new Map,r=new Map;a.set("_codecs.encode",(function(t){return t})),r.set("numpy.core.multiarray._reconstruct",(function(t,e,n){this.subtype=t,this.shape=e,this.dtype=n,this.__setstate__=function(t){this.version=t[0],this.shape=t[1],this.typecode=t[2],this.is_f_order=t[3],this.rawdata=t[4]},this.__read__=function(t){const e={};e.__type__=this.subtype,e.dtype=this.typecode,e.shape=this.shape;let n=e.dtype.itemsize;for(let t=0;t<e.shape.length;t++)n*=e.shape[t];if("string"==typeof this.rawdata){if(e.data=t.unescape(this.rawdata,n),e.data.length!=n)throw new npz.Error("Invalid string array data size.")}else e.data=this.rawdata,e.data.length;return e}})),r.set("numpy.dtype",(function(t,e,n){switch(t){case"i1":this.name="int8",this.itemsize=1;break;case"i2":this.name="int16",this.itemsize=2;break;case"i4":this.name="int32",this.itemsize=4;break;case"i8":this.name="int64",this.itemsize=8;break;case"u1":this.name="uint8",this.itemsize=1;break;case"u2":this.name="uint16",this.itemsize=2;break;case"u4":this.name="uint32",this.itemsize=4;break;case"u8":this.name="uint64",this.itemsize=8;break;case"f4":this.name="float32",this.itemsize=4;break;case"f8":this.name="float64",this.itemsize=8;break;default:if(t.startsWith("V"))this.itemsize=Number(t.substring(1)),this.name="void"+(8*this.itemsize).toString();else if(t.startsWith("O"))this.itemsize=Number(t.substring(1)),this.name="object";else if(t.startsWith("S"))this.itemsize=Number(t.substring(1)),this.name="string";else if(t.startsWith("U"))this.itemsize=Number(t.substring(1)),this.name="string";else{if(!t.startsWith("M"))throw new npz.Error("Unknown dtype '"+t.toString()+"'.");this.itemsize=Number(t.substring(1)),this.name="datetime"}}this.align=e,this.copy=n,this.__setstate__=function(t){switch(t.length){case 8:this.version=t[0],this.byteorder=t[1],this.subarray=t[2],this.names=t[3],this.fields=t[4],this.elsize=t[5],this.alignment=t[6],this.int_dtypeflags=t[7];break;default:throw new npz.Error("Unknown numpy.dtype setstate length '"+t.length.toString()+"'.")}}}));const h=(t,e)=>{if(a.has(t))return a.get(t).apply(null,e);const n={__type__:t};if(!r.has(t))throw new npz.Error("Unknown function '"+t+"'.");return r.get(t).apply(n,e),n},o=new Map([["i1","int8"],["i2","int16"],["i4","int32"],["i8","int64"],["u1","uint8"],["u2","uint16"],["u4","uint32"],["u8","uint64"],["f2","float16"],["f4","float32"],["f8","float64"]]);for(const a of t.entries("zip")){if(!a.name.endsWith(".npy"))throw new npz.Error("Invalid file name '"+a.name+"'.");const t=a.name.replace(/\.npy$/,"").split("/"),r=t.pop(),p=t.length>=2?t.join("/"):"";if(!s.has(p)){const t={name:p,parameters:[]};i.push(t),s.set(p,t)}const u=s.get(p);let d=new n.Array(a.data);if("|"===d.byteOrder){if("O"!==d.dataType)throw new npz.Error("Invalid data type '"+d.dataType+"'.");d={dataType:new e.Unpickler(d.data).load(h).dtype.name,shape:null,data:null,byteOrder:"|"}}u.parameters.push({name:r,dataType:o.has(d.dataType)?o.get(d.dataType):d.dataType,shape:d.shape,data:d.data,byteOrder:d.byteOrder})}return new npz.Model(i,"NumPy Zip")}catch(t){const e=t&&t.message?t.message:t.toString();throw new npz.Error(e.replace(/\.$/,"")+" in '"+i+"'.")}}))))}},npz.Model=class{constructor(t,e){this._format=e,this._graphs=[],this._graphs.push(new npz.Graph(t))}get format(){return this._format}get graphs(){return this._graphs}},npz.Graph=class{constructor(t){this._nodes=[];for(const e of t)this._nodes.push(new npz.Node(e))}get inputs(){return[]}get outputs(){return[]}get nodes(){return this._nodes}},npz.Parameter=class{constructor(t,e){this._name=t,this._arguments=e}get name(){return this._name}get visible(){return!0}get arguments(){return this._arguments}},npz.Argument=class{constructor(t,e){if("string"!=typeof t)throw new npz.Error("Invalid argument identifier '"+JSON.stringify(t)+"'.");this._name=t,this._initializer=e||null}get name(){return this._name}get type(){return this._initializer.type}get initializer(){return this._initializer}},npz.Node=class{constructor(t){this._name=t.name,this._inputs=[];for(const e of t.parameters){const t=this._name?[this._name,e.name].join("/"):e.name,n=new npz.Tensor(t,e.dataType,e.shape,e.data,e.byteOrder);this._inputs.push(new npz.Parameter(e.name,[new npz.Argument(t,n)]))}}get type(){return"Module"}get name(){return this._name}get metadata(){return null}get inputs(){return this._inputs}get outputs(){return[]}get attributes(){return[]}},npz.Tensor=class{constructor(t,e,n,i,s){this._name=t,this._type=new npz.TensorType(e,new npz.TensorShape(n)),this._shape=n,this._data=i,this._byteOrder=s}get kind(){return""}get name(){return this._name}get type(){return this._type}get state(){return this._context().state}get value(){const t=this._context();return t.state?null:(t.limit=Number.MAX_SAFE_INTEGER,this._decode(t,0))}toString(){const t=this._context();if(t.state)return"";t.limit=1e4;const e=this._decode(t,0);return npz.Tensor._stringify(e,"","    ")}_context(){const t={index:0,count:0,state:null};if("<"!==this._byteOrder&&">"!==this._byteOrder)return t.state="Tensor byte order is not supported.",t;if(this._reference)return t.state="Tensor reference not implemented.",t;if(!this._data||0==this._data.length)return t.state="Tensor data is empty.",t;switch(this._type.dataType){case"float16":t.itemSize=2;break;case"float32":t.itemSize=4;break;case"float64":t.itemSize=8;break;case"int8":t.itemSize=1;break;case"int16":t.itemSize=2;break;case"int32":t.itemSize=4;break;case"int64":t.itemSize=8;break;case"uint8":t.itemSize=1;break;case"uint16":t.itemSize=2;break;case"uint32":t.itemSize=4;break;default:return t.state="Tensor data type is not supported.",t}return t.dimensions=this._type.shape.dimensions,t.dataType=this._type.dataType,t.littleEndian="<"==this._byteOrder,t.data=this._data,t.rawData=new DataView(this._data.buffer,this._data.byteOffset,this._data.byteLength),t}_decode(t,e){const n=t.littleEndian,i=0==t.dimensions.length?[1]:t.dimensions,s=[],a=i[e];if(e==i.length-1)for(let e=0;e<a;e++){if(t.count>t.limit)return s.push("..."),s;if(t.rawData){switch(t.dataType){case"float16":s.push(t.rawData.getFloat16(t.index,n));break;case"float32":s.push(t.rawData.getFloat32(t.index,n));break;case"float64":s.push(t.rawData.getFloat64(t.index,n));break;case"int8":s.push(t.rawData.getInt8(t.index,n));break;case"int16":s.push(t.rawData.getInt16(t.index,n));break;case"int32":s.push(t.rawData.getInt32(t.index,n));break;case"int64":s.push(long.Long.fromBytes(t.data.subarray(t.index,t.index+8),!0,n));break;case"uint8":s.push(t.rawData.getUint8(t.index,n));break;case"uint16":s.push(t.rawData.getUint16(t.index,n));break;case"uint32":s.push(t.rawData.getUint32(t.index,n))}t.index+=t.itemSize,t.count++}}else for(let n=0;n<a;n++){if(t.count>t.limit)return s.push("..."),s;s.push(this._decode(t,e+1))}return 0==t.dimensions.length?s[0]:s}static _stringify(t,e,n){if(Array.isArray(t)){const i=[];i.push(e+"[");const s=t.map((t=>npz.Tensor._stringify(t,e+n,n)));return s.length>0&&i.push(s.join(",\n")),i.push(e+"]"),i.join("\n")}return"string"==typeof t?e+t:t==1/0?e+"Infinity":t==-1/0?e+"-Infinity":isNaN(t)?e+"NaN":e+t.toString()}},npz.TensorType=class{constructor(t,e){this._dataType=t,this._shape=e}get dataType(){return this._dataType||"?"}get shape(){return this._shape}toString(){return this.dataType+this._shape.toString()}},npz.TensorShape=class{constructor(t){this._dimensions=t}get dimensions(){return this._dimensions}toString(){return this._dimensions&&0!=this._dimensions.length?"["+this._dimensions.join(",")+"]":""}},npz.Error=class extends Error{constructor(t){super(t),this.name="Error loading Chainer model."}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.ModelFactory=npz.ModelFactory);