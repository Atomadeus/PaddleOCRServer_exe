var numpy=numpy||{};numpy.Array=class{constructor(t){if(t){const e=new numpy.Reader(t),r=[147,78,85,77,80,89];if(!e.bytes(6).every(((t,e)=>t==r[e])))throw new numpy.Error("Invalid signature.");const s=e.byte(),i=e.byte();if(1!==s&&0!==i)throw new numpy.Error("Invalid version '"+[s,i].join(".")+"'.");const a=JSON.parse(e.string().trim().replace(/'/g,'"').replace("False","false").replace("(","[").replace(/,*\),*/g,"]"));if(a.fortran_order)throw new numpy.Error("Fortran order is not supported.'");if(!a.descr||a.descr.length<2)throw new numpy.Error("Missing property 'descr'.");if(!a.shape)throw new numpy.Error("Missing property 'shape'.");switch(this._shape=a.shape,this._byteOrder=a.descr[0],this._byteOrder){case"|":this._dataType=a.descr.substring(1),this._data=e.bytes(e.size-e.position);break;case">":case"<":{if(3!==a.descr.length)throw new numpy.Error("Unsupported data type '"+a.descr+"'.");this._dataType=a.descr.substring(1);const t=parseInt(a.descr[2],10)*this._shape.reduce(((t,e)=>t*e),1);this._data=e.bytes(t);break}default:throw new numpy.Error("Unsupported data type '"+a.descr+"'.")}}}get data(){return this._data}set data(t){this._data=t}get dataType(){return this._dataType}set dataType(t){this._dataType=t}get shape(){return this._shape}set shape(t){this._shape=t}get byteOrder(){return this._byteOrder}set byteOrder(t){this._byteOrder=t}toBuffer(){const t=new numpy.Writer;t.bytes([147,78,85,77,80,89]),t.byte(1),t.byte(0);const e={itemSize:1,position:0,dataType:this._dataType,byteOrder:this._byteOrder||"<",shape:this._shape,descr:""};if("<"!==e.byteOrder&&">"!==e.byteOrder)throw new numpy.Error("Unknown byte order '"+this._byteOrder+"'.");if(2!==e.dataType.length||"f"!==e.dataType[0]&&"i"!==e.dataType[0]&&"u"!==e.dataType[0])throw new numpy.Error("Unsupported data type '"+this._dataType+"'.");e.itemSize=parseInt(e.dataType[1],10);let r="";switch(this._shape.length){case 0:throw new numpy.Error("Invalid shape.");case 1:r="("+this._shape[0].toString()+",)";break;default:r="("+this._shape.map((t=>t.toString())).join(", ")+")"}let s="{ "+["'descr': '"+e.byteOrder+e.dataType+"'","'fortran_order': False","'shape': "+r].join(", ")+" }";s+=" ".repeat(16-(s.length+2+8+1&15))+"\n",t.string(s);const i=e.itemSize*this._shape.reduce(((t,e)=>t*e));return e.data=new Uint8Array(i),e.dataView=new DataView(e.data.buffer,e.data.byteOffset,i),numpy.Array._encodeDimension(e,this._data,0),t.bytes(e.data),t.toBuffer()}static _encodeDimension(t,e,r){const s=t.shape[r],i="<"===t.byteOrder;if(r==t.shape.length-1)for(let r=0;r<s;r++){switch(t.dataType){case"f2":t.dataView.setFloat16(t.position,e[r],i);break;case"f4":t.dataView.setFloat32(t.position,e[r],i);break;case"f8":t.dataView.setFloat64(t.position,e[r],i);break;case"i1":t.dataView.setInt8(t.position,e[r],i);break;case"i2":t.dataView.setInt16(t.position,e[r],i);break;case"i4":t.dataView.setInt32(t.position,e[r],i);break;case"i8":t.data.set(e[r].toBytes(i),t.position);break;case"u1":t.dataView.setUint8(t.position,e[r],i);break;case"u2":t.dataView.setUint16(t.position,e[r],i);break;case"u4":t.dataView.setUint32(t.position,e[r],i);break;case"u8":t.data.set(e[r].toBytes(i),t.position)}t.position+=t.itemSize}else for(let i=0;i<s;i++)numpy.Array._encodeDimension(t,e[i],r+1)}},numpy.Reader=class{constructor(t){this._buffer=t,this._position=0}get position(){return this._position}get size(){return this._buffer.length}byte(){return this._buffer[this._position++]}bytes(t){const e=this._buffer.slice(this._position,this._position+t);return this._position+=t,e}uint16(){return this.byte()|this.byte()<<8}string(){const t=this.uint16();let e="";for(let r=0;r<t;r++)e+=String.fromCharCode(this.byte());return e}},numpy.Writer=class{constructor(){this._length=0,this._head=null,this._tail=null}byte(t){this.bytes([t])}uint16(t){this.bytes([255&t,t>>8&255])}bytes(t){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r];this._write(e)}string(t){this.uint16(t.length);const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);this._write(e)}_write(t){const e={buffer:t,next:null};this._tail?this._tail.next=e:this._head=e,this._tail=e,this._length+=e.buffer.length}toBuffer(){const t=new Uint8Array(this._length);let e=0,r=this._head;for(;null!=r;)t.set(r.buffer,e),e+=r.buffer.length,r=r.next;return t}},numpy.Error=class extends Error{constructor(t){super(t),this.name="NumPy Error"}},"undefined"!=typeof module&&"object"==typeof module.exports&&(module.exports.Array=numpy.Array);