var $root=flatbuffers.get("mnn");$root.MNN=$root.MNN||{},$root.MNN.OpType={AbsVal:0,QuantizedAdd:1,ArgMax:2,AsString:3,InstanceNorm:4,BatchToSpaceND:5,Bias:6,BinaryOp:7,Bnll:8,Cast:9,Concat:10,Const:11,Convolution:12,ConvolutionDepthwise:13,Crop:14,CropAndResize:15,Cubic:16,Deconvolution:17,DeconvolutionDepthwise:18,Dequantize:19,DetectionOutput:20,Dropout:21,Eltwise:22,ELU:23,Embed:24,Exp:25,ExpandDims:26,Fill:27,Flatten:28,FloorMod:29,Gather:30,GatherV2:31,Im2Seq:32,InnerProduct:33,Input:34,Interp:35,Log:36,LRN:37,LSTM:38,MatMul:39,MVN:40,NonMaxSuppression:41,NonMaxSuppressionV2:42,Normalize:43,Pack:44,Padding:45,Permute:46,Pooling:47,Power:48,PReLU:49,PriorBox:50,Proposal:51,QuantizedAvgPool:52,QuantizedBiasAdd:53,QuantizedConcat:54,QuantizedDepthwiseConv2D:55,QuantizedLogistic:56,QuantizedMatMul:57,QuantizedMaxPool:58,QuantizedRelu:59,QuantizedRelu6:60,QuantizedReshape:61,QuantizedSoftmax:62,QuantizeMaxMin:63,QuantizeV2:64,Range:65,Rank:66,ReduceJoin:67,Reduction:68,ReLU:69,ReLU6:70,RequantizationRange:71,Requantize:72,Reshape:73,Resize:74,RNN:75,ROIPooling:76,Scale:77,Selu:78,Seq2Out:79,Shape:80,Sigmoid:81,Size:82,Slice:83,SliceTf:84,Softmax:85,SpaceToBatchND:86,SpatialProduct:87,Split:88,SPP:89,Squeeze:90,StridedSlice:91,StringJoin:92,StringSplit:93,StringToNumber:94,TanH:95,TfQuantizedConv2D:96,Threshold:97,Tile:98,TopKV2:99,Transpose:100,UnaryOp:101,Unpack:102,Where:103,Moments:104,RNNSequenceGRU:105,BatchMatMul:106,Unsqueeze:107,CosineSimilarity:108,DepthToSpace:109,SpaceToDepth:110,ReverseSequence:111,Pooling3D:112,Convolution3D:113,MatrixBandPart:114,GatherND:115,DetectionPostProcess:116,UnravelIndex:117,ScatterNd:118,OneHot:119,BroadcastTo:120,Dilation2D:121,MaxLayerCount:128,ConvertTensor:129,ArgMin:130,LinSpace:131,Plugin:256,Select:257,ZerosLike:258,Broastcast:259,SetDiff1D:260,ReluGrad:261,Relu6Grad:262,PoolGrad:263,SoftmaxGrad:264,Conv2DBackPropFilter:265,TrainableParam:266,BatchNorm:267,ZeroGrad:268,Extra:512,ConvInt8:513,Int8ToFloat:514,DepthwiseConvInt8:515,PoolInt8:516,FloatToInt8:517,EltwiseInt8:518},$root.MNN.Plugin=class{static decode(e,t){const o=new $root.MNN.Plugin;return o.type=e.string_(t,4,null),o.attr=e.tableArray(t,6,$root.MNN.Attribute.decode),o}},$root.MNN.Extra=class{static decode(e,t){const o=new $root.MNN.Extra;return o.type=e.string_(t,4,null),o.engine=e.string_(t,6,null),o.info=e.typedArray(t,8,Int8Array),o.attr=e.tableArray(t,10,$root.MNN.Attribute.decode),o}},$root.MNN.OpParameter=class{static decode(e,t,o){switch(o){case 1:return $root.MNN.QuantizedAdd.decode(e,t);case 2:return $root.MNN.ArgMax.decode(e,t);case 3:return $root.MNN.AsString.decode(e,t);case 4:return $root.MNN.Axis.decode(e,t);case 5:return $root.MNN.BatchNorm.decode(e,t);case 6:return $root.MNN.BinaryOp.decode(e,t);case 7:return $root.MNN.Blob.decode(e,t);case 8:return $root.MNN.CastParam.decode(e,t);case 9:return $root.MNN.Convolution2D.decode(e,t);case 10:return $root.MNN.Crop.decode(e,t);case 11:return $root.MNN.CropAndResize.decode(e,t);case 12:return $root.MNN.Dequantize.decode(e,t);case 13:return $root.MNN.DetectionOutput.decode(e,t);case 14:return $root.MNN.Eltwise.decode(e,t);case 15:return $root.MNN.ExpandDims.decode(e,t);case 16:return $root.MNN.Fill.decode(e,t);case 17:return $root.MNN.Flatten.decode(e,t);case 18:return $root.MNN.Gather.decode(e,t);case 19:return $root.MNN.GatherV2.decode(e,t);case 20:return $root.MNN.InnerProduct.decode(e,t);case 21:return $root.MNN.Input.decode(e,t);case 22:return $root.MNN.Interp.decode(e,t);case 23:return $root.MNN.LRN.decode(e,t);case 24:return $root.MNN.LSTM.decode(e,t);case 25:return $root.MNN.MatMul.decode(e,t);case 26:return $root.MNN.NonMaxSuppressionV2.decode(e,t);case 27:return $root.MNN.Normalize.decode(e,t);case 28:return $root.MNN.PackParam.decode(e,t);case 29:return $root.MNN.Permute.decode(e,t);case 30:return $root.MNN.Plugin.decode(e,t);case 31:return $root.MNN.Pool.decode(e,t);case 32:return $root.MNN.PRelu.decode(e,t);case 33:return $root.MNN.PriorBox.decode(e,t);case 34:return $root.MNN.Proposal.decode(e,t);case 35:return $root.MNN.QuantizedAvgPool.decode(e,t);case 36:return $root.MNN.QuantizedBiasAdd.decode(e,t);case 37:return $root.MNN.QuantizedConcat.decode(e,t);case 38:return $root.MNN.QuantizedLogistic.decode(e,t);case 39:return $root.MNN.QuantizedMatMul.decode(e,t);case 40:return $root.MNN.QuantizedMaxPool.decode(e,t);case 41:return $root.MNN.QuantizedRelu.decode(e,t);case 42:return $root.MNN.QuantizedRelu6.decode(e,t);case 43:return $root.MNN.QuantizedReshape.decode(e,t);case 44:return $root.MNN.QuantizedSoftmax.decode(e,t);case 45:return $root.MNN.QuantizeMaxMin.decode(e,t);case 46:return $root.MNN.QuantizeV2.decode(e,t);case 47:return $root.MNN.Range.decode(e,t);case 48:return $root.MNN.Rank.decode(e,t);case 49:return $root.MNN.ReduceJoin.decode(e,t);case 50:return $root.MNN.ReductionParam.decode(e,t);case 51:return $root.MNN.Relu.decode(e,t);case 52:return $root.MNN.Relu6.decode(e,t);case 53:return $root.MNN.RequantizationRange.decode(e,t);case 54:return $root.MNN.Requantize.decode(e,t);case 55:return $root.MNN.Reshape.decode(e,t);case 56:return $root.MNN.Resize.decode(e,t);case 57:return $root.MNN.RoiPooling.decode(e,t);case 58:return $root.MNN.Scale.decode(e,t);case 59:return $root.MNN.Selu.decode(e,t);case 60:return $root.MNN.Size.decode(e,t);case 61:return $root.MNN.Slice.decode(e,t);case 62:return $root.MNN.SliceTf.decode(e,t);case 63:return $root.MNN.SpaceBatch.decode(e,t);case 64:return $root.MNN.SqueezeParam.decode(e,t);case 65:return $root.MNN.StridedSliceParam.decode(e,t);case 66:return $root.MNN.TensorConvertInfo.decode(e,t);case 67:return $root.MNN.TfQuantizedConv2D.decode(e,t);case 68:return $root.MNN.TopKV2.decode(e,t);case 69:return $root.MNN.Transpose.decode(e,t);case 70:return $root.MNN.UnaryOp.decode(e,t);case 71:return $root.MNN.MomentsParam.decode(e,t);case 72:return $root.MNN.RNNParam.decode(e,t);case 73:return $root.MNN.BatchMatMulParam.decode(e,t);case 74:return $root.MNN.QuantizedFloatParam.decode(e,t);case 75:return $root.MNN.DepthSpaceParam.decode(e,t);case 76:return $root.MNN.EltwiseInt8.decode(e,t);case 77:return $root.MNN.ReverseSequenceParam.decode(e,t);case 78:return $root.MNN.Extra.decode(e,t);case 79:return $root.MNN.Pool3D.decode(e,t);case 80:return $root.MNN.Convolution3D.decode(e,t);case 81:return $root.MNN.ELU.decode(e,t);case 82:return $root.MNN.DetectionPostProcessParam.decode(e,t);case 83:return $root.MNN.OneHotParam.decode(e,t);case 84:return $root.MNN.PadParam.decode(e,t)}}static decodeText(e,t,o){switch(o){case"QuantizedAdd":return $root.MNN.QuantizedAdd.decodeText(e,t);case"ArgMax":return $root.MNN.ArgMax.decodeText(e,t);case"AsString":return $root.MNN.AsString.decodeText(e,t);case"Axis":return $root.MNN.Axis.decodeText(e,t);case"BatchNorm":return $root.MNN.BatchNorm.decodeText(e,t);case"BinaryOp":return $root.MNN.BinaryOp.decodeText(e,t);case"Blob":return $root.MNN.Blob.decodeText(e,t);case"CastParam":return $root.MNN.CastParam.decodeText(e,t);case"Convolution2D":return $root.MNN.Convolution2D.decodeText(e,t);case"Crop":return $root.MNN.Crop.decodeText(e,t);case"CropAndResize":return $root.MNN.CropAndResize.decodeText(e,t);case"Dequantize":return $root.MNN.Dequantize.decodeText(e,t);case"DetectionOutput":return $root.MNN.DetectionOutput.decodeText(e,t);case"Eltwise":return $root.MNN.Eltwise.decodeText(e,t);case"ExpandDims":return $root.MNN.ExpandDims.decodeText(e,t);case"Fill":return $root.MNN.Fill.decodeText(e,t);case"Flatten":return $root.MNN.Flatten.decodeText(e,t);case"Gather":return $root.MNN.Gather.decodeText(e,t);case"GatherV2":return $root.MNN.GatherV2.decodeText(e,t);case"InnerProduct":return $root.MNN.InnerProduct.decodeText(e,t);case"Input":return $root.MNN.Input.decodeText(e,t);case"Interp":return $root.MNN.Interp.decodeText(e,t);case"LRN":return $root.MNN.LRN.decodeText(e,t);case"LSTM":return $root.MNN.LSTM.decodeText(e,t);case"MatMul":return $root.MNN.MatMul.decodeText(e,t);case"NonMaxSuppressionV2":return $root.MNN.NonMaxSuppressionV2.decodeText(e,t);case"Normalize":return $root.MNN.Normalize.decodeText(e,t);case"PackParam":return $root.MNN.PackParam.decodeText(e,t);case"Permute":return $root.MNN.Permute.decodeText(e,t);case"Plugin":return $root.MNN.Plugin.decodeText(e,t);case"Pool":return $root.MNN.Pool.decodeText(e,t);case"PRelu":return $root.MNN.PRelu.decodeText(e,t);case"PriorBox":return $root.MNN.PriorBox.decodeText(e,t);case"Proposal":return $root.MNN.Proposal.decodeText(e,t);case"QuantizedAvgPool":return $root.MNN.QuantizedAvgPool.decodeText(e,t);case"QuantizedBiasAdd":return $root.MNN.QuantizedBiasAdd.decodeText(e,t);case"QuantizedConcat":return $root.MNN.QuantizedConcat.decodeText(e,t);case"QuantizedLogistic":return $root.MNN.QuantizedLogistic.decodeText(e,t);case"QuantizedMatMul":return $root.MNN.QuantizedMatMul.decodeText(e,t);case"QuantizedMaxPool":return $root.MNN.QuantizedMaxPool.decodeText(e,t);case"QuantizedRelu":return $root.MNN.QuantizedRelu.decodeText(e,t);case"QuantizedRelu6":return $root.MNN.QuantizedRelu6.decodeText(e,t);case"QuantizedReshape":return $root.MNN.QuantizedReshape.decodeText(e,t);case"QuantizedSoftmax":return $root.MNN.QuantizedSoftmax.decodeText(e,t);case"QuantizeMaxMin":return $root.MNN.QuantizeMaxMin.decodeText(e,t);case"QuantizeV2":return $root.MNN.QuantizeV2.decodeText(e,t);case"Range":return $root.MNN.Range.decodeText(e,t);case"Rank":return $root.MNN.Rank.decodeText(e,t);case"ReduceJoin":return $root.MNN.ReduceJoin.decodeText(e,t);case"ReductionParam":return $root.MNN.ReductionParam.decodeText(e,t);case"Relu":return $root.MNN.Relu.decodeText(e,t);case"Relu6":return $root.MNN.Relu6.decodeText(e,t);case"RequantizationRange":return $root.MNN.RequantizationRange.decodeText(e,t);case"Requantize":return $root.MNN.Requantize.decodeText(e,t);case"Reshape":return $root.MNN.Reshape.decodeText(e,t);case"Resize":return $root.MNN.Resize.decodeText(e,t);case"RoiPooling":return $root.MNN.RoiPooling.decodeText(e,t);case"Scale":return $root.MNN.Scale.decodeText(e,t);case"Selu":return $root.MNN.Selu.decodeText(e,t);case"Size":return $root.MNN.Size.decodeText(e,t);case"Slice":return $root.MNN.Slice.decodeText(e,t);case"SliceTf":return $root.MNN.SliceTf.decodeText(e,t);case"SpaceBatch":return $root.MNN.SpaceBatch.decodeText(e,t);case"SqueezeParam":return $root.MNN.SqueezeParam.decodeText(e,t);case"StridedSliceParam":return $root.MNN.StridedSliceParam.decodeText(e,t);case"TensorConvertInfo":return $root.MNN.TensorConvertInfo.decodeText(e,t);case"TfQuantizedConv2D":return $root.MNN.TfQuantizedConv2D.decodeText(e,t);case"TopKV2":return $root.MNN.TopKV2.decodeText(e,t);case"Transpose":return $root.MNN.Transpose.decodeText(e,t);case"UnaryOp":return $root.MNN.UnaryOp.decodeText(e,t);case"MomentsParam":return $root.MNN.MomentsParam.decodeText(e,t);case"RNNParam":return $root.MNN.RNNParam.decodeText(e,t);case"BatchMatMulParam":return $root.MNN.BatchMatMulParam.decodeText(e,t);case"QuantizedFloatParam":return $root.MNN.QuantizedFloatParam.decodeText(e,t);case"DepthSpaceParam":return $root.MNN.DepthSpaceParam.decodeText(e,t);case"EltwiseInt8":return $root.MNN.EltwiseInt8.decodeText(e,t);case"ReverseSequenceParam":return $root.MNN.ReverseSequenceParam.decodeText(e,t);case"Extra":return $root.MNN.Extra.decodeText(e,t);case"Pool3D":return $root.MNN.Pool3D.decodeText(e,t);case"Convolution3D":return $root.MNN.Convolution3D.decodeText(e,t);case"ELU":return $root.MNN.ELU.decodeText(e,t);case"DetectionPostProcessParam":return $root.MNN.DetectionPostProcessParam.decodeText(e,t);case"OneHotParam":return $root.MNN.OneHotParam.decodeText(e,t);case"PadParam":return $root.MNN.PadParam.decodeText(e,t)}}},$root.MNN.Op=class{static decode(e,t){const o=new $root.MNN.Op;return o.inputIndexes=e.typedArray(t,4,Int32Array),o.main=e.union(t,6,$root.MNN.OpParameter.decode),o.name=e.string_(t,10,null),o.outputIndexes=e.typedArray(t,12,Int32Array),o.type=e.int32_(t,14,0),o.defaultDimentionFormat=e.int8_(t,16,void 0),o}},$root.MNN.TensorDescribe=class{static decode(e,t){const o=new $root.MNN.TensorDescribe;return o.blob=e.table(t,4,$root.MNN.Blob.decode),o.index=e.int32_(t,6,0),o.name=e.string_(t,8,null),o}},$root.MNN.ForwardType={CPU:0,METAL:1,OPENCL:2,OPENGLES:3,VULKAN:4},$root.MNN.Usage={INFERENCE:0,TRAIN:1},$root.MNN.Net=class{static create(e){return $root.MNN.Net.decode(e,e.root)}static decode(e,t){const o=new $root.MNN.Net;return o.bizCode=e.string_(t,4,null),o.extraTensorDescribe=e.tableArray(t,6,$root.MNN.TensorDescribe.decode),o.gpulibrary=e.table(t,8,$root.MNN.GpuLibrary.decode),o.oplists=e.tableArray(t,10,$root.MNN.Op.decode),o.outputName=e.strings_(t,12),o.preferForwardType=e.int8_(t,14,0),o.sourceType=e.int8_(t,16,0),o.tensorName=e.strings_(t,18),o.tensorNumber=e.int32_(t,20,0),o.usage=e.int8_(t,22,0),o}},$root.MNN.PadMode={CAFFE:0,VALID:1,SAME:2},$root.MNN.Convolution2DCommon=class{static decode(e,t){const o=new $root.MNN.Convolution2DCommon;return o.padX=e.int32_(t,4,0),o.padY=e.int32_(t,6,0),o.kernelX=e.int32_(t,8,1),o.kernelY=e.int32_(t,10,1),o.strideX=e.int32_(t,12,1),o.strideY=e.int32_(t,14,1),o.dilateX=e.int32_(t,16,1),o.dilateY=e.int32_(t,18,1),o.padMode=e.int8_(t,20,0),o.group=e.int32_(t,22,1),o.outputCount=e.int32_(t,24,0),o.inputCount=e.int32_(t,26,0),o.relu=e.bool_(t,28,!1),o.relu6=e.bool_(t,30,!1),o.pads=e.typedArray(t,32,Int32Array),o}},$root.MNN.Convolution3DCommon=class{static decode(e,t){const o=new $root.MNN.Convolution3DCommon;return o.dilates=e.typedArray(t,4,Int32Array),o.strides=e.typedArray(t,6,Int32Array),o.kernels=e.typedArray(t,8,Int32Array),o.pads=e.typedArray(t,10,Int32Array),o.padMode=e.int8_(t,12,0),o.inputCount=e.int32_(t,14,0),o.outputCount=e.int32_(t,16,0),o.relu=e.bool_(t,18,!1),o.relu6=e.bool_(t,20,!1),o}},$root.MNN.IDSTQuan=class{static decode(e,t){const o=new $root.MNN.IDSTQuan;return o.buffer=e.typedArray(t,4,Int8Array),o.alpha=e.typedArray(t,6,Float32Array),o.type=e.int32_(t,8,0),o.useInt32=e.bool_(t,10,!1),o.quantScale=e.float32_(t,12,0),o.scaleIn=e.float32_(t,14,0),o.scaleOut=e.float32_(t,16,0),o.aMax=e.int32_(t,18,0),o.aMin=e.int32_(t,20,0),o.readType=e.int32_(t,22,0),o.has_scaleInt=e.bool_(t,24,!1),o}},$root.MNN.QuantizeAlgo={DEFAULT:0,OVERFLOW_AWARE:1},$root.MNN.QuantizedFloatParam=class{static decode(e,t){const o=new $root.MNN.QuantizedFloatParam;return o.weight=e.typedArray(t,4,Int8Array),o.bias=e.typedArray(t,6,Int32Array),o.scale=e.typedArray(t,8,Float32Array),o.tensorScale=e.typedArray(t,10,Float32Array),o.method=e.int8_(t,12,0),o}},$root.MNN.Convolution2D=class{static decode(e,t){const o=new $root.MNN.Convolution2D;return o.common=e.table(t,4,$root.MNN.Convolution2DCommon.decode),o.weight=e.typedArray(t,6,Float32Array),o.bias=e.typedArray(t,8,Float32Array),o.quanParameter=e.table(t,10,$root.MNN.IDSTQuan.decode),o.symmetricQuan=e.table(t,12,$root.MNN.QuantizedFloatParam.decode),o}},$root.MNN.Convolution3D=class{static decode(e,t){const o=new $root.MNN.Convolution3D;return o.common=e.table(t,4,$root.MNN.Convolution3DCommon.decode),o.weight=e.typedArray(t,6,Float32Array),o.bias=e.typedArray(t,8,Float32Array),o}},$root.MNN.InnerProduct=class{static decode(e,t){const o=new $root.MNN.InnerProduct;return o.outputCount=e.int32_(t,4,0),o.biasTerm=e.int32_(t,6,0),o.weightSize=e.int32_(t,8,0),o.weight=e.typedArray(t,10,Float32Array),o.bias=e.typedArray(t,12,Float32Array),o.axis=e.int32_(t,14,0),o.transpose=e.bool_(t,16,!1),o.quanParameter=e.table(t,18,$root.MNN.IDSTQuan.decode),o}},$root.MNN.PoolType={MAXPOOL:0,AVEPOOL:1},$root.MNN.PoolPadType={CAFFE:0,VALID:1,SAME:2},$root.MNN.Pool=class{static decode(e,t){const o=new $root.MNN.Pool;return o.padX=e.int32_(t,4,0),o.padY=e.int32_(t,6,0),o.isGlobal=e.bool_(t,8,!1),o.kernelX=e.int32_(t,10,0),o.kernelY=e.int32_(t,12,0),o.strideX=e.int32_(t,14,0),o.strideY=e.int32_(t,16,0),o.type=e.int8_(t,18,0),o.padType=e.int8_(t,20,0),o.dataType=e.int32_(t,22,1),o.ceilModel=e.bool_(t,24,!0),o.pads=e.typedArray(t,26,Int32Array),o}},$root.MNN.Pool3D=class{static decode(e,t){const o=new $root.MNN.Pool3D;return o.strides=e.typedArray(t,4,Int32Array),o.kernels=e.typedArray(t,6,Int32Array),o.pads=e.typedArray(t,8,Int32Array),o.type=e.int8_(t,10,0),o.padType=e.int8_(t,12,0),o}},$root.MNN.Relu=class{static decode(e,t){const o=new $root.MNN.Relu;return o.slope=e.float32_(t,4,0),o}},$root.MNN.Relu6=class{static decode(e,t){const o=new $root.MNN.Relu6;return o.minValue=e.float32_(t,4,0),o.maxValue=e.float32_(t,6,6),o}},$root.MNN.PRelu=class{static decode(e,t){const o=new $root.MNN.PRelu;return o.slopeCount=e.int32_(t,4,0),o.slope=e.typedArray(t,6,Float32Array),o}},$root.MNN.ELU=class{static decode(e,t){const o=new $root.MNN.ELU;return o.alpha=e.float32_(t,4,0),o}},$root.MNN.LRN=class{static decode(e,t){const o=new $root.MNN.LRN;return o.regionType=e.int32_(t,4,0),o.localSize=e.int32_(t,6,0),o.alpha=e.float32_(t,8,0),o.beta=e.float32_(t,10,0),o}},$root.MNN.ArgMax=class{static decode(e,t){const o=new $root.MNN.ArgMax;return o.outMaxVal=e.int32_(t,4,0),o.topK=e.int32_(t,6,0),o.axis=e.int32_(t,8,0),o.softmaxThreshold=e.int32_(t,10,0),o}},$root.MNN.Axis=class{static decode(e,t){const o=new $root.MNN.Axis;return o.axis=e.int32_(t,4,0),o}},$root.MNN.Input=class{static decode(e,t){const o=new $root.MNN.Input;return o.dims=e.typedArray(t,4,Int32Array),o.dtype=e.int32_(t,6,1),o.dformat=e.int8_(t,8,void 0),o}},$root.MNN.LSTM=class{static decode(e,t){const o=new $root.MNN.LSTM;return o.outputCount=e.int32_(t,4,0),o.weightSize=e.int32_(t,6,0),o.clippingThreshold=e.float32_(t,8,0),o.weightI=e.table(t,10,$root.MNN.Blob.decode),o.weightH=e.table(t,12,$root.MNN.Blob.decode),o.bias=e.table(t,14,$root.MNN.Blob.decode),o.weightIQ=e.table(t,16,$root.MNN.Blob.decode),o.weightIA=e.table(t,18,$root.MNN.Blob.decode),o.quantScale=e.float32_(t,20,0),o}},$root.MNN.Slice=class{static decode(e,t){const o=new $root.MNN.Slice;return o.axis=e.int32_(t,4,0),o.slicePoints=e.typedArray(t,6,Int32Array),o.sourceType=e.int8_(t,8,0),o}},$root.MNN.BatchNorm=class{static decode(e,t){const o=new $root.MNN.BatchNorm;return o.channels=e.int32_(t,4,0),o.slopeData=e.typedArray(t,6,Float32Array),o.meanData=e.typedArray(t,8,Float32Array),o.varData=e.typedArray(t,10,Float32Array),o.biasData=e.typedArray(t,12,Float32Array),o.Adata=e.typedArray(t,14,Float32Array),o.Bdata=e.typedArray(t,16,Float32Array),o.epsilon=e.float32_(t,18,.001),o}},$root.MNN.Scale=class{static decode(e,t){const o=new $root.MNN.Scale;return o.channels=e.int32_(t,4,0),o.scaleData=e.typedArray(t,6,Float32Array),o.biasData=e.typedArray(t,8,Float32Array),o}},$root.MNN.EltwiseType={PROD:0,SUM:1,MAXIMUM:2,SUB:3},$root.MNN.Eltwise=class{static decode(e,t){const o=new $root.MNN.Eltwise;return o.type=e.int8_(t,4,0),o.coeff=e.typedArray(t,6,Float32Array),o}},$root.MNN.Flatten=class{static decode(e,t){const o=new $root.MNN.Flatten;return o.axis=e.int32_(t,4,0),o.endAxis=e.int32_(t,6,0),o}},$root.MNN.Permute=class{static decode(e,t){const o=new $root.MNN.Permute;return o.dims=e.typedArray(t,4,Int32Array),o}},$root.MNN.Reshape=class{static decode(e,t){const o=new $root.MNN.Reshape;return o.dims=e.typedArray(t,4,Int32Array),o.dimType=e.int8_(t,6,void 0),o}},$root.MNN.DetectionOutput=class{static decode(e,t){const o=new $root.MNN.DetectionOutput;return o.classCount=e.int32_(t,4,0),o.nmsThresholdold=e.float32_(t,6,0),o.nmsTopK=e.int32_(t,8,0),o.keepTopK=e.int32_(t,10,0),o.confidenceThreshold=e.float32_(t,12,0),o.shareLocation=e.int32_(t,14,0),o.backgroundLable=e.int32_(t,16,0),o.varianceEncodedTarget=e.int32_(t,18,0),o.codeType=e.int32_(t,20,0),o.objectnessScore=e.float32_(t,22,.01),o}},$root.MNN.RoiPooling=class{static decode(e,t){const o=new $root.MNN.RoiPooling;return o.pooledWidth=e.int32_(t,4,0),o.pooledHeight=e.int32_(t,6,0),o.spatialScale=e.float32_(t,8,0),o}},$root.MNN.Proposal=class{static decode(e,t){const o=new $root.MNN.Proposal;return o.featStride=e.int32_(t,4,0),o.baseSize=e.int32_(t,6,0),o.preNmsTopN=e.int32_(t,8,0),o.afterNmsTopN=e.int32_(t,10,0),o.nmsThreshold=e.float32_(t,12,0),o.minSize=e.int32_(t,14,0),o.ratios=e.table(t,16,$root.MNN.Blob.decode),o.scales=e.table(t,18,$root.MNN.Blob.decode),o.anchors=e.table(t,20,$root.MNN.Blob.decode),o}},$root.MNN.Interp=class{static decode(e,t){const o=new $root.MNN.Interp;return o.widthScale=e.float32_(t,4,0),o.heightScale=e.float32_(t,6,0),o.outputWidth=e.int32_(t,8,0),o.outputHeight=e.int32_(t,10,0),o.resizeType=e.int32_(t,12,0),o.alignCorners=e.bool_(t,14,!1),o.halfPixelCenters=e.bool_(t,16,!1),o}},$root.MNN.Resize=class{static decode(e,t){const o=new $root.MNN.Resize;return o.xScale=e.float32_(t,4,0),o.yScale=e.float32_(t,6,0),o}},$root.MNN.PriorBox=class{static decode(e,t){const o=new $root.MNN.PriorBox;return o.minSizes=e.typedArray(t,4,Float32Array),o.maxSizes=e.typedArray(t,6,Float32Array),o.aspectRatios=e.typedArray(t,8,Float32Array),o.variances=e.typedArray(t,10,Float32Array),o.flip=e.bool_(t,12,!1),o.clip=e.bool_(t,14,!1),o.imageWidth=e.int32_(t,16,0),o.imageHeight=e.int32_(t,18,0),o.stepWidth=e.int32_(t,20,0),o.stepHeight=e.int32_(t,22,0),o.offset=e.float32_(t,24,0),o}},$root.MNN.Normalize=class{static decode(e,t){const o=new $root.MNN.Normalize;return o.acrossSpatial=e.int32_(t,4,0),o.channelShared=e.int32_(t,6,0),o.eps=e.float32_(t,8,0),o.scale=e.typedArray(t,10,Float32Array),o}},$root.MNN.EltwiseInt8=class{static decode(e,t){const o=new $root.MNN.EltwiseInt8;return o.type=e.int8_(t,4,0),o.inputQuan0=e.table(t,6,$root.MNN.QuantizedFloatParam.decode),o.inputQuan1=e.table(t,8,$root.MNN.QuantizedFloatParam.decode),o.outputQuan=e.table(t,10,$root.MNN.QuantizedFloatParam.decode),o}},$root.MNN.MNN_DATA_FORMAT={NCHW:0,NHWC:1,NC4HW4:2,NHWC4:3,UNKNOWN:4},$root.MNN.Blob=class{static decode(e,t){const o=new $root.MNN.Blob;return o.dims=e.typedArray(t,4,Int32Array),o.dataFormat=e.int8_(t,6,0),o.dataType=e.int32_(t,8,1),o.uint8s=e.typedArray(t,10,Uint8Array),o.int8s=e.typedArray(t,12,Int8Array),o.int32s=e.typedArray(t,14,Int32Array),o.int64s=e.int64s_(t,16),o.float32s=e.typedArray(t,18,Float32Array),o.strings=e.strings_(t,20),o}},$root.MNN.ListValue=class{static decode(e,t){const o=new $root.MNN.ListValue;return o.s=e.strings_(t,4),o.i=e.typedArray(t,6,Int32Array),o.f=e.typedArray(t,8,Float32Array),o.b=e.bools_(t,10),o.type=e.typedArray(t,12,Int32Array),o}},$root.MNN.Attribute=class{static decode(e,t){const o=new $root.MNN.Attribute;return o.s=e.string_(t,4,null),o.i=e.int32_(t,6,0),o.b=e.bool_(t,8,!1),o.key=e.string_(t,10,null),o.type=e.int32_(t,12,void 0),o.f=e.float32_(t,14,0),o.tensor=e.table(t,16,$root.MNN.Blob.decode),o.list=e.table(t,18,$root.MNN.ListValue.decode),o}},$root.MNN.NetSource={CAFFE:0,TENSORFLOW:1,TFLITE:2,ONNX:3},$root.MNN.DataType={DT_INVALID:0,DT_FLOAT:1,DT_DOUBLE:2,DT_INT32:3,DT_UINT8:4,DT_INT16:5,DT_INT8:6,DT_STRING:7,DT_COMPLEX64:8,DT_INT64:9,DT_BOOL:10,DT_QINT8:11,DT_QUINT8:12,DT_QINT32:13,DT_BFLOAT16:14,DT_QINT16:15,DT_QUINT16:16,DT_UINT16:17,DT_COMPLEX128:18,DT_HALF:19,DT_RESOURCE:20,DT_VARIANT:21},$root.MNN.BinaryOpOperation={ADD:0,SUB:1,MUL:2,DIV:3,MAX_TEMP:4,MIN_TEMP:5,POW:6,REALDIV:7,MINIMUM:8,MAXIMUM:9,GREATER:10,GREATER_EQUAL:11,LESS:12,FLOORDIV:13,SquaredDifference:14,EQUAL:15,LESS_EQUAL:16,FLOORMOD:17,MOD:19,ATAN2:20,LOGICALOR:21,NOTEQUAL:22},$root.MNN.BinaryOp=class{static decode(e,t){const o=new $root.MNN.BinaryOp;return o.opType=e.int32_(t,4,0),o.T=e.int32_(t,6,1),o}},$root.MNN.PackParam=class{static decode(e,t){const o=new $root.MNN.PackParam;return o.dataType=e.int32_(t,4,0),o.axis=e.int32_(t,6,0),o}},$root.MNN.StridedSliceParam=class{static decode(e,t){const o=new $root.MNN.StridedSliceParam;return o.Index=e.int32_(t,4,0),o.T=e.int32_(t,6,0),o.beginMask=e.int32_(t,8,0),o.endMask=e.int32_(t,10,0),o.ellipsisMask=e.int32_(t,12,0),o.newAxisMask=e.int32_(t,14,0),o.shrinkAxisMask=e.int32_(t,16,0),o}},$root.MNN.SqueezeParam=class{static decode(e,t){const o=new $root.MNN.SqueezeParam;return o.squeezeDims=e.typedArray(t,4,Int32Array),o}},$root.MNN.CastParam=class{static decode(e,t){const o=new $root.MNN.CastParam;return o.srcT=e.int32_(t,4,0),o.dstT=e.int32_(t,6,0),o}},$root.MNN.ReductionType={SUM:0,ASUM:1,SUMSQ:2,MEAN:3,MAXIMUM:4,MINIMUM:5,PROD:6,ANY:7,ALL:8},$root.MNN.ReductionParam=class{static decode(e,t){const o=new $root.MNN.ReductionParam;return o.operation=e.int8_(t,4,0),o.dim=e.typedArray(t,6,Int32Array),o.coeff=e.float32_(t,8,0),o.keepDims=e.bool_(t,10,!1),o.dType=e.int32_(t,12,1),o}},$root.MNN.Gather=class{static decode(e,t){const o=new $root.MNN.Gather;return o.Tindices=e.int32_(t,4,0),o.Tparams=e.int32_(t,6,0),o.validateIndices=e.bool_(t,8,!1),o.axis=e.int32_(t,10,0),o}},$root.MNN.ExpandDims=class{static decode(e,t){const o=new $root.MNN.ExpandDims;return o.T=e.int32_(t,4,0),o.Tdim=e.int32_(t,6,0),o.axis=e.int32_(t,8,0),o}},$root.MNN.Selu=class{static decode(e,t){const o=new $root.MNN.Selu;return o.scale=e.float32_(t,4,0),o.alpha=e.float32_(t,6,0),o}},$root.MNN.AsString=class{static decode(e,t){const o=new $root.MNN.AsString;return o.T=e.int32_(t,4,0),o.precision=e.int32_(t,6,0),o.scientific=e.bool_(t,8,!1),o.shortest=e.bool_(t,10,!1),o.width=e.int32_(t,12,0),o.fillString=e.string_(t,14,null),o}},$root.MNN.ReduceJoin=class{static decode(e,t){const o=new $root.MNN.ReduceJoin;return o.keepDims=e.bool_(t,4,!1),o.separator=e.string_(t,6,null),o}},$root.MNN.UnaryOpOperation={ABS:0,NEG:1,FLOOR:2,CEIL:3,SQUARE:4,SQRT:5,RSQRT:6,EXP:7,LOG:8,SIN:9,COS:10,TAN:11,ASIN:12,ACOS:13,ATAN:14,RECIPROCAL:15,LOG1P:16,BNLL:17,ACOSH:18,SINH:19,ASINH:20,ATANH:21,SIGN:22,ROUND:23,COSH:24,ERF:25,ERFC:26,ERFINV:27,EXPM1:28},$root.MNN.UnaryOp=class{static decode(e,t){const o=new $root.MNN.UnaryOp;return o.opType=e.int32_(t,4,0),o.T=e.int32_(t,6,0),o}},$root.MNN.TopKV2=class{static decode(e,t){const o=new $root.MNN.TopKV2;return o.T=e.int32_(t,4,1),o.sorted=e.bool_(t,6,!1),o}},$root.MNN.CropAndResizeMethod={BILINEAR:0,NEAREST:1},$root.MNN.CropAndResize=class{static decode(e,t){const o=new $root.MNN.CropAndResize;return o.extrapolationValue=e.float32_(t,4,0),o.method=e.int8_(t,6,0),o}},$root.MNN.Fill=class{static decode(e,t){return new $root.MNN.Fill}},$root.MNN.GatherV2=class{static decode(e,t){const o=new $root.MNN.GatherV2;return o.Taxis=e.int32_(t,4,0),o.Tindices=e.int32_(t,6,0),o.Tparams=e.int32_(t,8,0),o}},$root.MNN.NonMaxSuppressionV2=class{static decode(e,t){return new $root.MNN.NonMaxSuppressionV2}},$root.MNN.Range=class{static decode(e,t){const o=new $root.MNN.Range;return o.Tidx=e.int32_(t,4,0),o}},$root.MNN.Rank=class{static decode(e,t){return new $root.MNN.Rank}},$root.MNN.Size=class{static decode(e,t){const o=new $root.MNN.Size;return o.outputDataType=e.int32_(t,4,0),o}},$root.MNN.Transpose=class{static decode(e,t){const o=new $root.MNN.Transpose;return o.Tperm=e.int32_(t,4,0),o}},$root.MNN.SliceTf=class{static decode(e,t){const o=new $root.MNN.SliceTf;return o.T=e.int32_(t,4,0),o}},$root.MNN.QuantizeMaxMin=class{static decode(e,t){const o=new $root.MNN.QuantizeMaxMin;return o.T=e.int32_(t,4,0),o}},$root.MNN.Crop=class{static decode(e,t){const o=new $root.MNN.Crop;return o.axis=e.int32_(t,4,2),o.offset=e.typedArray(t,6,Int32Array),o}},$root.MNN.SpaceBatch=class{static decode(e,t){const o=new $root.MNN.SpaceBatch;return o.blockShape=e.table(t,4,$root.MNN.Blob.decode),o.padding=e.table(t,6,$root.MNN.Blob.decode),o}},$root.MNN.MatMul=class{static decode(e,t){const o=new $root.MNN.MatMul;return o.T=e.int32_(t,4,0),o.transposeA=e.bool_(t,6,!1),o.transposeB=e.bool_(t,8,!1),o.weight=e.typedArray(t,10,Float32Array),o.bias=e.typedArray(t,12,Float32Array),o}},$root.MNN.MomentsParam=class{static decode(e,t){const o=new $root.MNN.MomentsParam;return o.dim=e.typedArray(t,4,Int32Array),o.keepDims=e.bool_(t,6,!0),o.dType=e.int32_(t,8,1),o}},$root.MNN.RNNParam=class{static decode(e,t){const o=new $root.MNN.RNNParam;return o.numUnits=e.int32_(t,4,0),o.isBidirectionalRNN=e.bool_(t,6,!1),o.keepAllOutputs=e.bool_(t,8,!1),o.fwGateWeight=e.table(t,10,$root.MNN.Blob.decode),o.fwGateBias=e.table(t,12,$root.MNN.Blob.decode),o.fwCandidateWeight=e.table(t,14,$root.MNN.Blob.decode),o.fwCandidateBias=e.table(t,16,$root.MNN.Blob.decode),o.bwGateWeight=e.table(t,18,$root.MNN.Blob.decode),o.bwGateBias=e.table(t,20,$root.MNN.Blob.decode),o.bwCandidateWeight=e.table(t,22,$root.MNN.Blob.decode),o.bwCandidateBias=e.table(t,24,$root.MNN.Blob.decode),o}},$root.MNN.BatchMatMulParam=class{static decode(e,t){const o=new $root.MNN.BatchMatMulParam;return o.adjX=e.bool_(t,4,!1),o.adjY=e.bool_(t,6,!1),o}},$root.MNN.DepthSpaceParam=class{static decode(e,t){const o=new $root.MNN.DepthSpaceParam;return o.blockSize=e.int32_(t,4,0),o}},$root.MNN.ReverseSequenceParam=class{static decode(e,t){const o=new $root.MNN.ReverseSequenceParam;return o.batchDim=e.int32_(t,4,0),o.seqDim=e.int32_(t,6,0),o}},$root.MNN.DetectionPostProcessParam=class{static decode(e,t){const o=new $root.MNN.DetectionPostProcessParam;return o.maxDetections=e.int32_(t,4,0),o.maxClassesPerDetection=e.int32_(t,6,0),o.detectionsPerClass=e.int32_(t,8,0),o.nmsScoreThreshold=e.float32_(t,10,0),o.iouThreshold=e.float32_(t,12,0),o.numClasses=e.int32_(t,14,0),o.useRegularNMS=e.bool_(t,16,!1),o.centerSizeEncoding=e.typedArray(t,18,Float32Array),o}},$root.MNN.OneHotParam=class{static decode(e,t){const o=new $root.MNN.OneHotParam;return o.dType=e.int32_(t,4,1),o.axis=e.int32_(t,6,-1),o}},$root.MNN.PadValueMode={CONSTANT:0,REFLECT:1,SYMMETRIC:2},$root.MNN.PadParam=class{static decode(e,t){const o=new $root.MNN.PadParam;return o.mode=e.int8_(t,4,0),o}},$root.MNN.FusedActivation={kTfLiteActNone:0,kTfLiteActRelu:1,kTfLiteActRelu1:2,kTfLiteActRelu6:3,kTfLiteActTanh:4,kTfLiteActSignBit:5,kTfLiteActSigmoid:6},$root.MNN.QuantizedParam=class{static decode(e,t){const o=new $root.MNN.QuantizedParam;return o.zeroPoint=e.int32_(t,4,0),o.scale=e.float32_(t,6,0),o}},$root.MNN.QuantizedAdd=class{static decode(e,t){const o=new $root.MNN.QuantizedAdd;return o.activationType=e.int8_(t,4,0),o.input1QuantizedParam=e.table(t,6,$root.MNN.QuantizedParam.decode),o.input2QuantizedParam=e.table(t,8,$root.MNN.QuantizedParam.decode),o.outputQuantizedParam=e.table(t,10,$root.MNN.QuantizedParam.decode),o}},$root.MNN.ModeFormat={TENSORFLOW:0,TFLITE:1},$root.MNN.QuantizeMode={MIN_COMBINED:0,MIN_FIRST:1,SCALED:2},$root.MNN.Dequantize=class{static decode(e,t){const o=new $root.MNN.Dequantize;return o.inputQuantizedParam=e.table(t,4,$root.MNN.QuantizedParam.decode),o.mode=e.int8_(t,6,0),o.modelFormat=e.int8_(t,8,0),o.type=e.int32_(t,10,0),o}},$root.MNN.QuantizedAvgPool=class{static decode(e,t){const o=new $root.MNN.QuantizedAvgPool;return o.kernelX=e.int32_(t,4,0),o.kernelY=e.int32_(t,6,0),o.modelFormat=e.int8_(t,8,0),o.outputActivationMax=e.int32_(t,10,0),o.outputActivationMin=e.int32_(t,12,0),o.padType=e.int8_(t,14,0),o.padX=e.int32_(t,16,0),o.padY=e.int32_(t,18,0),o.strideX=e.int32_(t,20,0),o.strideY=e.int32_(t,22,0),o.type=e.int32_(t,24,0),o}},$root.MNN.QuantizedBiasAdd=class{static decode(e,t){const o=new $root.MNN.QuantizedBiasAdd;return o.bias=e.typedArray(t,4,Int32Array),o.inputType=e.int32_(t,6,0),o.max=e.int32_(t,8,0),o.min=e.int32_(t,10,0),o.outputType=e.int32_(t,12,0),o}},$root.MNN.QuantizedConcat=class{static decode(e,t){const o=new $root.MNN.QuantizedConcat;return o.activationType=e.int8_(t,4,0),o.axis=e.int32_(t,6,0),o.inputScale=e.typedArray(t,8,Float32Array),o.inputZeroPoint=e.typedArray(t,10,Int32Array),o.outputQuantizedParam=e.table(t,12,$root.MNN.QuantizedParam.decode),o}},$root.MNN.QuantizedLogistic=class{static decode(e,t){const o=new $root.MNN.QuantizedLogistic;return o.inputQuantizedParam=e.table(t,4,$root.MNN.QuantizedParam.decode),o.outputQuantizedParam=e.table(t,6,$root.MNN.QuantizedParam.decode),o}},$root.MNN.QuantizedMatMul=class{static decode(e,t){const o=new $root.MNN.QuantizedMatMul;return o.transposeA=e.bool_(t,4,!1),o.transposeB=e.bool_(t,6,!1),o}},$root.MNN.QuantizedMaxPool=class{static decode(e,t){const o=new $root.MNN.QuantizedMaxPool;return o.kernelX=e.int32_(t,4,0),o.kernelY=e.int32_(t,6,0),o.modelFormat=e.int8_(t,8,0),o.outputActivationMax=e.int32_(t,10,0),o.outputActivationMin=e.int32_(t,12,0),o.padType=e.int8_(t,14,0),o.padX=e.int32_(t,16,0),o.padY=e.int32_(t,18,0),o.strideX=e.int32_(t,20,0),o.strideY=e.int32_(t,22,0),o.type=e.int32_(t,24,0),o}},$root.MNN.QuantizedRelu=class{static decode(e,t){const o=new $root.MNN.QuantizedRelu;return o.type=e.int32_(t,4,0),o}},$root.MNN.QuantizedRelu6=class{static decode(e,t){const o=new $root.MNN.QuantizedRelu6;return o.type=e.int32_(t,4,0),o}},$root.MNN.QuantizedReshape=class{static decode(e,t){const o=new $root.MNN.QuantizedReshape;return o.dims=e.typedArray(t,4,Int32Array),o.modelFormat=e.int8_(t,6,0),o}},$root.MNN.QuantizedSoftmax=class{static decode(e,t){const o=new $root.MNN.QuantizedSoftmax;return o.beta=e.float32_(t,4,0),o.inputScale=e.float32_(t,6,0),o}},$root.MNN.QuantizeRoundMode={HALF_AWAY_FROM_ZERO:0,HALF_TO_EVEN:1},$root.MNN.QuantizeV2=class{static decode(e,t){const o=new $root.MNN.QuantizeV2;return o.type=e.int32_(t,4,0),o.mode=e.int8_(t,6,0),o.roundMode=e.int8_(t,8,0),o}},$root.MNN.RequantizationRange=class{static decode(e,t){return new $root.MNN.RequantizationRange}},$root.MNN.Requantize=class{static decode(e,t){return new $root.MNN.Requantize}},$root.MNN.TfQuantizedConv2D=class{static decode(e,t){const o=new $root.MNN.TfQuantizedConv2D;return o.bias=e.typedArray(t,4,Int32Array),o.biasflag=e.bool_(t,6,!1),o.common=e.table(t,8,$root.MNN.Convolution2DCommon.decode),o.weight=e.typedArray(t,10,Uint8Array),o.activationType=e.int8_(t,12,0),o.multiplier=e.int32_(t,14,0),o.outMax=e.int32_(t,16,0),o.outMin=e.int32_(t,18,0),o.shift=e.int32_(t,20,0),o.biasQuantizedParam=e.table(t,22,$root.MNN.QuantizedParam.decode),o.depthMultiplier=e.int32_(t,24,0),o.filterQuantizedParam=e.table(t,26,$root.MNN.QuantizedParam.decode),o.inputQuantizedParam=e.table(t,28,$root.MNN.QuantizedParam.decode),o.modelFormat=e.int8_(t,30,0),o.outputQuantizedParam=e.table(t,32,$root.MNN.QuantizedParam.decode),o}},$root.MNN.STORAGE_TYPE={BUFFER:0,UNIFORM:1,IMAGE:2},$root.MNN.ACCESS_TYPE={READ_ONLY:0,WRITE_ONLY:1,READ_WRITE:2},$root.MNN.GpuBuffer=class{static decode(e,t){const o=new $root.MNN.GpuBuffer;return o.access=e.int8_(t,4,0),o.storage=e.int8_(t,6,0),o.content=e.table(t,8,$root.MNN.Blob.decode),o}},$root.MNN.GpuPipeline=class{static decode(e,t){const o=new $root.MNN.GpuPipeline;return o.localSize=e.typedArray(t,4,Int32Array),o.key=e.string_(t,6,null),o.metal=e.typedArray(t,8,Int8Array),o.vulkan=e.typedArray(t,10,Int8Array),o.openglComputeShader=e.string_(t,12,null),o.openclKernel=e.string_(t,14,null),o}},$root.MNN.GpuStage=class{static decode(e,t){const o=new $root.MNN.GpuStage;return o.pipeline=e.string_(t,4,null),o.groupSize=e.typedArray(t,6,Int32Array),o.inputIndexes=e.typedArray(t,8,Int32Array),o.outputIndexes=e.typedArray(t,10,Int32Array),o.middleBuffer=e.tableArray(t,12,$root.MNN.GpuBuffer.decode),o.constBuffer=e.tableArray(t,14,$root.MNN.GpuBuffer.decode),o.globalSizeIndex=e.int32_(t,16,0),o.globalSizeDivide=e.typedArray(t,18,Int32Array),o.requireSize=e.bool_(t,20,!1),o}},$root.MNN.GpuFunction=class{static decode(e,t){const o=new $root.MNN.GpuFunction;return o.stags=e.tableArray(t,4,$root.MNN.GpuStage.decode),o.name=e.string_(t,6,null),o}},$root.MNN.GpuLibrary=class{static decode(e,t){const o=new $root.MNN.GpuLibrary;return o.functions=e.tableArray(t,4,$root.MNN.GpuFunction.decode),o.pipeline=e.tableArray(t,6,$root.MNN.GpuPipeline.decode),o.name=e.string_(t,8,null),o}},$root.MNN.TensorConvertInfo=class{static decode(e,t){const o=new $root.MNN.TensorConvertInfo;return o.source=e.int8_(t,4,0),o.dest=e.int8_(t,6,0),o}};