import{LabelType as u}from"./types.js";import{safeSplit as E}from"../../utils/index.js";import C from"../../../__snowpack__/pkg/lodash/uniq.js";const D="__index__",I="__metadata__",N={NUMBER_MISMATCH:Symbol("NUMBER_MISMATCH"),TENSER_EMPTY:Symbol("TENSER_EMPTY"),METADATA_EMPTY:Symbol("METADATA_EMPTY"),SHAPE_MISMATCH:Symbol("SHAPE_MISMATCH")};export class ParserError extends Error{constructor(t,e,a){super(t);this.code=e,this.data=a}}ParserError.CODES=N;function A(n,t){return E(n,`
`).map(e=>E(e,"	").map(a=>t?t(a):a)).filter(e=>e.length)}function _(n,t,e){return n.map(a=>{const r=a.length;return r>t?a.slice(0,t):r<t?[...a,...Array.from({length:t-r}).fill(e)]:a})}function S(n){const t=Array.from({length:n}).map((a,r)=>r);let e=n;for(;e;){const a=Math.floor(Math.random()*e);e--;const r=t[e];t[e]=t[a],t[a]=r}return t}function T(n,t,e){const{count:a,dimension:r,vectors:o,metadata:s}=n,l=t?Math.min(a,t):a,i=e?Math.min(r,e):r,m=S(a),w=S(r),d=new Float32Array(l*i),p=[];for(let c=0;c<l;c++){const h=m[c]*r;if(i<r)for(let f=0;f<i;f++)d[c+f]=o[h+w[f]];else d.set(o.subarray(h,h+i),c*i);p.push(s[m[c]])}return{...n,count:l,dimension:i,vectors:d,metadata:p}}function M(n,t){return n.map(e=>e[t])}function g(n){if(!n.length)return[];const t=[],e=n[0].length;for(let a=0;a<e;a++)t.push(M(n,a));return t}function b(n){const t=n.map(Number.parseFloat),e=t.every(Number.isFinite)?u.Value:u.Category;switch(e){case u.Value:return{type:e,minValue:Math.min(...t),maxValue:Math.max(...t)};case u.Category:return{type:e,categories:C(n)};default:return null}}function F(n){if(!n)throw new ParserError("Tenser file is empty",ParserError.CODES.TENSER_EMPTY);const t=[0,0];let e=A(n,Number.parseFloat);t[0]=e.length;const a=Math.min(...e.map(r=>r.length));return t[1]=a,e=_(e,a,0),{rawShape:t,dimension:a,count:e.length,vectors:new Float32Array(e.flat())}}function P(n){var r;if(!n)throw new ParserError("Metadata file is empty",ParserError.CODES.METADATA_EMPTY);let t=A(n);const e=t[0].length;t=_(t,e,"");let a=[];return e>1?a=((r=t.shift())!=null?r:[]).map((s,l)=>({label:s,...b(M(t,l))})):a=[{label:I,...b(M(t,0))}],{dimension:e,labels:a,metadata:t}}function y(n,t){if(n){const e=P(n),a=e.metadata.length;if(t!==a)throw new ParserError(`Number of tensors (${t}) do not match the number of lines in metadata (${a}).`,ParserError.CODES.NUMBER_MISMATCH,{vectors:t,metadata:a});return{labels:e.labels,metadata:e.metadata}}return{labels:[{label:D,type:u.Null}],metadata:Array.from({length:t},(e,a)=>[`${a}`])}}export function parseFromString({vectors:n,metadata:t,maxCount:e,maxDimension:a}){const r={rawShape:[0,0],count:0,dimension:0,vectors:new Float32Array,labels:[],metadata:[]};n&&(Object.assign(r,F(n)),Object.assign(r,y(t,r.count)));const{metadata:o,...s}=T(r,e,a);return{...s,metadata:g(o)}}export async function parseFromBlob({shape:n,vectors:t,metadata:e,maxCount:a,maxDimension:r}){const[o,s]=n,l=new Float32Array(await t.arrayBuffer());if(o*s!==l.length)throw new ParserError("Size of tensor does not match.",ParserError.CODES.SHAPE_MISMATCH);const{metadata:i,...m}=T({rawShape:n,count:o,dimension:s,vectors:l,...y(e,o)},a,r);return{...m,metadata:g(i)}}
